<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-x16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="veaTBtqt4ArdFO7yL4lECMYJsOeSwdptb1k8vJJBzMA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://lyreal666.com").hostname,root:"/",scheme:"Pisces",version:"7.7.1",exturl:!0,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!0,style:"default"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="记得以前知乎上看到过一个问题：面试一个 5 年的前端，却连原型链也搞不清楚，满口都是 Vue，React 之类的实现，这样的人该用吗？ 。写文章的时候又回去看了下这个问题，300 多个回答，有很多大佬都回答了这个问题，说明这个问题还是挺受关注的。最近几年，随着 ES6 ，TypeScript 及类似的中间语言的流行，我们平时做业务开发很少能接触到原型，基本上都是用 ES6 class 来去更简单的"><meta property="og:type" content="article"><meta property="og:title" content="讲清楚 JavaScript 原型"><meta property="og:url" content="https://lyreal666.com/%E8%AE%B2%E6%B8%85%E6%A5%9A-JavaScript-%E5%8E%9F%E5%9E%8B/index.html"><meta property="og:site_name" content="余腾靖的博客"><meta property="og:description" content="记得以前知乎上看到过一个问题：面试一个 5 年的前端，却连原型链也搞不清楚，满口都是 Vue，React 之类的实现，这样的人该用吗？ 。写文章的时候又回去看了下这个问题，300 多个回答，有很多大佬都回答了这个问题，说明这个问题还是挺受关注的。最近几年，随着 ES6 ，TypeScript 及类似的中间语言的流行，我们平时做业务开发很少能接触到原型，基本上都是用 ES6 class 来去更简单的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2020/01/28/Ax7FsXQne84PNkg.png"><meta property="og:image" content="https://i.loli.net/2020/01/28/pdbT1nxw57lDijS.png"><meta property="og:image" content="https://i.loli.net/2020/01/28/hNn4dPgkiAI2pML.png"><meta property="og:image" content="https://i.loli.net/2020/01/28/QitjOq1NJWzYcVl.png"><meta property="og:image" content="https://i.loli.net/2020/01/28/A6YISmxrLuVNfyP.png"><meta property="article:published_time" content="2020-01-27T07:24:00.000Z"><meta property="article:modified_time" content="2020-02-06T11:16:23.753Z"><meta property="article:author" content="余腾靖"><meta property="article:tag" content="prototype"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2020/01/28/Ax7FsXQne84PNkg.png"><link rel="canonical" href="https://lyreal666.com/%E8%AE%B2%E6%B8%85%E6%A5%9A-JavaScript-%E5%8E%9F%E5%9E%8B/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>讲清楚 JavaScript 原型 | 余腾靖的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="余腾靖的博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">余腾靖的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://lyreal666.com/%E8%AE%B2%E6%B8%85%E6%A5%9A-JavaScript-%E5%8E%9F%E5%9E%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="余腾靖"><meta itemprop="description" content="总结和分享我的所学所思"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余腾靖的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">讲清楚 JavaScript 原型</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-27 15:24:00" itemprop="dateCreated datePublished" datetime="2020-01-27T15:24:00+08:00">2020-01-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-06 19:16:23" itemprop="dateModified" datetime="2020-02-06T19:16:23+08:00">2020-02-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>记得以前知乎上看到过一个问题：<a href="https://www.zhihu.com/question/60165921" target="_blank" rel="noopener">面试一个 5 年的前端，却连<strong>原型链</strong>也搞不清楚，满口都是 Vue，React 之类的实现，这样的人该用吗？</a> 。写文章的时候又回去看了下这个问题，300 多个回答，有很多大佬都回答了这个问题，说明这个问题还是挺受关注的。最近几年，随着 ES6 ，TypeScript 及类似的中间语言的流行，我们平时做业务开发很少能接触到原型，基本上都是用 ES6 class 来去更简单的，更直观的实现以前构造器加原型做的事情。</p><p>其实在我看来，我觉得原型链是一个非常重要的基础知识。如果一个人说他 C 语言很精通，但是他汇编不熟，你信吗？我觉得 winter 说的挺简洁到位的：</p><blockquote><p>这又涉及到我之前讲过的面试官技巧，面试，是对一个人的能力系统性评价，搞清楚一个人擅长什么不会什么，所以问知识性问题，为了避免误判，一定要大量问、系统化地问。</p><p>不会原型很能说明问题，至少他在库的设计方面会有极大劣势，而且可能学习习惯上是有问题的，也有可能他根本就不太会 JS 语言，但是这不意味着凭借一个问题就可以判定这个人不能用。</p></blockquote><p>本文包括以下内容：</p><ol><li>JavaScript 原型</li><li>构造器和 <code>prototype</code></li><li>原型链</li><li>原型的用途</li><li>ES6 class 和构造器的关系</li><li>原型继承</li><li>JavaScript 和原型相关语法特性</li><li>原型污染</li></ol><a id="more"></a><h2 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h2><p>原型的英文应该叫做 <code>prototype</code>，任何一个对象都有原型，我们可以通过非标准属性 <code>__proto__</code> 来访问一个对象的原型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> Student(<span class="string">'xiaoMing'</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// Student 类型实例的原型，默认也是一个空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.__proto__); <span class="comment">// =&gt; Student &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code> 是非标准属性，如果要访问一个对象的原型，建议使用 ES6 新增的 <code>Object.getPrototypeOf()</code> 方法。非标准属性意味着未来可能直接会修改或者移除该属性，说不定以后出了个新标准用 <code>Symbol.proto</code> 作为 key 来访问对象的原型，那这个非标准属性可能就要被移除了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>我们可以直接修改对象的原型，不过被设置的值的类型只能是对象或者 null，其它类型不起作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'xiaoMing'</span> &#125;;</span><br><span class="line"><span class="comment">// 原型为空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 非对象和 null 不生效</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 设置为 null 返回 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置原型为对象</span></span><br><span class="line">obj.__proto__ = &#123; <span class="attr">constructor</span>: <span class="string">'Function Student'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123; constructor: 'Function Student' &#125;</span></span><br></pre></td></tr></table></figure><p>如果被设置的值是不可扩展的，将抛出 TypeError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> frozenObj = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// Object.isExtensible(obj) 可以判断 obj 是不是可扩展的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(frozenObj)); <span class="comment">// =&gt; false</span></span><br><span class="line">frozenObj.__proto__ = <span class="literal">null</span>; <span class="comment">// =&gt; TypeError: #&lt;Object&gt; is not extensible</span></span><br></pre></td></tr></table></figure><p>原型上的属性都是不可枚举的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.xxx = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure><p>其实 <code>__proto__</code> 是个访问器属性（getter 和 setter 都有），通过 <code>__proto__</code> 访问器我们可以访问对象的<code>[[Prototype]]</code>， 也就是原型。简单实现一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype = &#123;</span><br><span class="line">  <span class="keyword">get</span> __proto__() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> __proto__(newPrototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.isExtensible(newPrototype)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;newPrototype&#125;</span> is not extensible`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newPrototype === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>] = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newPrototype === <span class="string">'object'</span> || <span class="keyword">typeof</span> newPrototype === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>] = newPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其它属性如 toString，hasOwnProperty 等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构造器和-prototype"><a href="#构造器和-prototype" class="headerlink" title="构造器和 prototype"></a>构造器和 prototype</h2><p>构造器的英文就是 <code>constructor</code>，在 JavaScript 中，<strong>函数都可以用作构造器</strong>。构造器我们也可以称之为类，Student 构造器不就可以称之为 Student 类嘛。我们可以通过 new 构造器来构造一个实例。习惯上我们对用作构造器的函数使用大驼峰命名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> Apple();</span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> Apple); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><strong>任何构造器都有一个 prototype 属性，默认是一个空的纯对象，所有由构造器构造的实例的原型都是指向它。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例的原型即 apple1.__proto__</span></span><br><span class="line"><span class="built_in">console</span>.log(apple1.__proto__ === Apple.prototype); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(apple2.__proto__ === Apple.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>下面的测试结果可以证明构造器的 prototype 属性默认是个空对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Apple.prototype); <span class="comment">// =&gt; Apple &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Apple.prototype)); <span class="comment">// =&gt; []</span></span><br><span class="line"><span class="built_in">console</span>.log(Apple.prototype.__proto__ === &#123;&#125;.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>构造器的 prototype 有一个 constructor 属性，指向构造器本身：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Apple.prototype.constructor === Apple); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code> ，<code>prototype</code>，<code>constructor</code>，<code>Apple</code>函数，实例 <code>apple</code> 和原型对象 <code>[[prototype]]</code> 之间的关系：</p><p><img data-src="https://i.loli.net/2020/01/28/Ax7FsXQne84PNkg.png" alt="relationship.png"></p><p>有些人可能会把 <code>__proto__</code> 和 <code>prototype</code> 搞混淆。从翻译的角度来说，它们都可以叫原型，但是其实是完全不同的两个东西。</p><p><code>__proto__</code> 存在于所有的对象上，<code>prototype</code> 存在于所有的函数上，他俩的关系就是：函数的 <code>prototype</code> 是所有使用 new 这个函数构造的实例的 <code>__proto__</code>。函数也是对象，所以函数同时有 <code>__proto__</code> 和<code>prototype</code>。</p><p><strong>注意</strong>：如果我文章中提到了构造器的原型，指的是构造器的 <code>__proto__</code>，而不是构造器的 prototype 属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那么<strong>对象的原型</strong>有什么特点呢？</p><blockquote><p>当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 <code>obj.__proto__</code> 上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 <code>obj.__proto__.__proto__</code>去找，重复以上步骤。一直到访问<strong>纯对象</strong>的原型的原型<code>{}.__proto.__proto__</code>，也就是 null，直接返回 undefined。</p></blockquote><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(stu.notExists); <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure><p>访问 <code>stu.notExists</code> 的整个过程是：</p><ol><li>先看 <code>stu</code> 上是否存在 <code>notExists</code>，不存在，所以看 <code>stu.__proto__</code></li><li><code>stu.__proto__</code> 上也不存在 <code>notExists</code> 属性，再看 <code>stu.__proto__.__proto__</code>，其实就是<strong>纯对象</strong>的原型：<code>{}.__proto__</code></li><li><strong>纯对象</strong>的原型上也不存在 <code>notExists</code> 属性，再往上，到 <code>stu.__proto__.__proto__.__proto__</code> 上去找，其实就是 null</li><li>null 不存在 <code>notExists</code> 属性，返回 undefined</li></ol><p>可能有读者看了上面会有疑问，对象的原型一直查找最后会找到<strong>纯对象</strong>的原型？测试一下就知道了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stu.__proto__.__proto__ === &#123;&#125;.__proto__); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><strong>纯对象</strong>的原型的原型是 null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>().__proto__.__proto__); <span class="comment">// =&gt; null</span></span><br></pre></td></tr></table></figure><blockquote><p>各个原型之间构成的链，我们称之为原型链。</p></blockquote><p><img data-src="https://i.loli.net/2020/01/28/pdbT1nxw57lDijS.png" alt="prototypeChain1.png"></p><p>想想看，函数 <code>Student</code> 的原型链应该是怎样的？</p><p><img data-src="https://i.loli.net/2020/01/28/hNn4dPgkiAI2pML.png" alt="functionPrototypeChain.png"></p><h2 id="原型的用途"><a href="#原型的用途" class="headerlink" title="原型的用途"></a>原型的用途</h2><p>在使用构造器定义一个类型的时候，我们一般会将类的方法定义在原型上，和 this 的指向特性简直是绝配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">workingYears</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.workingYears = workingYears;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能使用箭头函数，箭头函数的 this 在声明的时候就根据上下文确定了</span></span><br><span class="line">Engineer.prototype.built = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我已经工作 <span class="subst">$&#123;<span class="keyword">this</span>.workingYears&#125;</span> 年了, 我的工作是拧螺丝...`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> Engineer(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// this 会正确指向实例，所以 this.workingYears 是 5</span></span><br><span class="line">engineer.built(); <span class="comment">// =&gt; 我已经工作 5 年了, 我的工作是拧螺丝...</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(engineer)); <span class="comment">// =&gt; [ 'workingYears' ]</span></span><br></pre></td></tr></table></figure><p>通过这种方式，所有的实例都可以访问到这个方法，并且这个方法只需要占用一份内存，节省内存，this 的指向还能正确指向类的实例。</p><p>不过这种方式定义的方法都是不可枚举的，毕竟不是自身的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  func() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// =&gt; [ 'func' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Func.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 空数组，说明 func 不可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(<span class="keyword">new</span> Func())); <span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure><p>如果你就是要定义实例属性的话还是只能通过 <code>this.xxx = xxx</code> 的方式定义实例方法了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">workingYears</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.workingYears = workingYears;</span><br><span class="line">  <span class="keyword">this</span>.built = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我已经工作 <span class="subst">$&#123;<span class="keyword">this</span>.workingYears&#125;</span> 年了, 我的工作是拧螺丝...`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> Engineer(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(engineer)); <span class="comment">// =&gt; [ 'workingYears', 'built' ]</span></span><br></pre></td></tr></table></figure><p>其实 JavaScript 中很多方法都定义在构造器的原型上，例如 Array.prototype.slice，Object.prototype.toString 等。</p><h2 id="ES6-class-和构造器的关系"><a href="#ES6-class-和构造器的关系" class="headerlink" title="ES6 class 和构造器的关系"></a>ES6 class 和构造器的关系</h2><p>很多语言都有拥有面向对象编程范式，例如 java, c#, python 等。ES6 class 让从它们转到 JavaScript 的开发者更容易进行面向对象编程。</p><h3 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h3><p>其实，<strong>ES6 class 就是构造器的语法糖</strong>。 我们来看一下 babel 将 ES6 class 编译成了啥：</p><p>原代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, r) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`画个坐标为 (<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)，半径为 <span class="subst">$&#123;<span class="keyword">this</span>.r&#125;</span> 的圆`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babel + babel-preset-es2015-loose</code> 编译出的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle class 可以理解为就是一个构造器函数</span></span><br><span class="line"><span class="keyword">var</span> Circle = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">x, y, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _proto = Circle.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// class 方法定义在 prototype 上</span></span><br><span class="line">  _proto.draw = <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">'\u753B\u4E2A\u5750\u6807\u4E3A ('</span> +</span><br><span class="line">        <span class="keyword">this</span>.x +</span><br><span class="line">        <span class="string">', '</span> +</span><br><span class="line">        <span class="keyword">this</span>.y +</span><br><span class="line">        <span class="string">')\uFF0C\u534A\u5F84\u4E3A '</span> +</span><br><span class="line">        <span class="keyword">this</span>.r +</span><br><span class="line">        <span class="string">' \u7684\u5706'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一看就明白了， ES6 的 class 就是构造器，class 上的方法定义在构造器的 prototype 上，因此你也可以理解为什么 class 的方法是不可枚举的。</p><h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h3><p>我们再来看一下使用 <code>extends</code> 继承时是怎样转换的。</p><p>原代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, r) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`画个坐标为 (<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)，半径为 <span class="subst">$&#123;<span class="keyword">this</span>.r&#125;</span> 的圆`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babel + babel-preset-es2015-loose</code> 编译出的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inheritsLoose</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass.prototype);</span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line">  subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Circle = (<span class="function"><span class="keyword">function</span>(<span class="params">_Shape</span>) </span>&#123;</span><br><span class="line">  _inheritsLoose(Circle, _Shape);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">x, y, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合继承</span></span><br><span class="line">    _this = _Shape.call(<span class="keyword">this</span>, x, y) || <span class="keyword">this</span>;</span><br><span class="line">    _this.r = r;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _proto = Circle.prototype;</span><br><span class="line"></span><br><span class="line">  _proto.draw = <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">'\u753B\u4E2A\u5750\u6807\u4E3A ('</span> +</span><br><span class="line">        <span class="keyword">this</span>.x +</span><br><span class="line">        <span class="string">', '</span> +</span><br><span class="line">        <span class="keyword">this</span>.y +</span><br><span class="line">        <span class="string">')\uFF0C\u534A\u5F84\u4E3A '</span> +</span><br><span class="line">        <span class="keyword">this</span>.r +</span><br><span class="line">        <span class="string">' \u7684\u5706'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;)(Shape);</span><br></pre></td></tr></table></figure><p>整个 ES6 的 extends 实现的是原型继承 + 组合继承。</p><p>子类构造器中调用了父类构造器并将 this 指向子类实例达到<strong>将父类的实例属性组合到子类实例上</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line">_this = _Shape.call(<span class="keyword">this</span>, x, y) || <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p><code>_inheritsLoose</code> 这个函数就是实现了下一节要讲的原型继承。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>在讲<code>原型继承</code> 之前我们先讲讲<code>继承</code>这个词。我觉得，通俗意义上的<code>继承</code>是说：<strong>如果类 A 继承自类 B，那么 A 的实例继承了 B 的实例属性</strong>。</p><p><code>原型继承</code>的这个<code>继承</code>和通俗意义上的<code>继承</code>还不太一样，它是要：<strong>A 的实例能够继承 B 的原型上的属性</strong>。</p><p>给原型继承下个定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于类 A 和类 B，如果满足 A.prototype.__proto__ === B.prototype，那么 A 原型继承 B</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/01/28/QitjOq1NJWzYcVl.png" alt="prototypeExtends.png"></p><p>如何实现原型继承呢？最简单的方式就是直接设置 <code>A.prototype === new B()</code>，让 A 的 prototype 是 B 的实例即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.xxx = <span class="string">'污染 A 的原型'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>但是这种方式会导致 B 的实例属性污染 A 的原型。解决办法就是通过一个空的函数桥接一下，空的函数总不会有实例属性污染原型链喽：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.xxx = <span class="string">'污染原型'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Empty</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Empty.prototype = B.prototype;</span><br><span class="line">A.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line"><span class="comment">// 修正 constructor 指向</span></span><br><span class="line">A.prototype.constructor = A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足原型继承的定义</span></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a 也是 B 的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> B); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>用 Windows 自带的画图软件画的原型链_〆(´Д ｀ )：</p><p><img data-src="https://i.loli.net/2020/01/28/A6YISmxrLuVNfyP.png" alt="prototypeChain.png"></p><p>利用 <code>Object.create</code>，我们可以更简单的实现原型继承，也就是上面的 babel 用到的工具函数 <code>_inheritsLoose</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inheritsLoose</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object.create(prototype) 返回一个以 prototype 为原型的对象</span></span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass.prototype);</span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 我们上面实现的原型继承没有设置这个，但是 class 的继承会设置子类的原型为父类</span></span><br><span class="line">  subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript-和原型相关语法特性"><a href="#JavaScript-和原型相关语法特性" class="headerlink" title="JavaScript 和原型相关语法特性"></a>JavaScript 和原型相关语法特性</h2><p>其实由很多语法特性是和原型有关系的，讲到原型那么我们就再继续讲讲 JavaScrip 语法特性中涉及到原型的一些知识点。</p><h3 id="new-运算符原理"><a href="#new-运算符原理" class="headerlink" title="new 运算符原理"></a>new 运算符原理</h3><p>当我们对函数使用 new 的时候发生了什么。</p><p>使用代码来描述就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">return</span> value !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * constructor 表示 new 的构造器</span></span><br><span class="line"><span class="comment"> * args 表示传给构造器的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// new 的对象不是函数就抛 TypeError</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">constructor</span> !== 'function') throw new TypeError(`$&#123;<span class="keyword">constructor</span>&#125; is not a <span class="keyword">constructor</span>`);</span><br><span class="line"></span><br><span class="line">  // 创建一个原型为构造器的 prototype 的空对象 target</span><br><span class="line">  const target = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">  // 将构造器的 this 指向上一步创建的空对象，并执行，为了给 this 添加实例属性</span><br><span class="line">  const result = <span class="keyword">constructor</span>.apply(target, args);</span><br><span class="line"></span><br><span class="line">  // 上一步的返回如果是对象就直接返回，否则返回 target</span><br><span class="line">  return isObject(result) ? result : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Computer</span>(<span class="params">brand</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = New(Computer, <span class="string">'Apple'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; Computer &#123; brand: 'Apple' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-运算符原理"><a href="#instanceof-运算符原理" class="headerlink" title="instanceof 运算符原理"></a>instanceof 运算符原理</h3><p>instanceof 用于判断对象是否是某个类的实例，如果 obj instance A，我们就说 obj 是 A 的实例。</p><p>它的原理很简单，一句话概括就是：<strong>obj instanceof 构造器 A，等同于判断 A 的 prototype 是不是 obj 的原型（也可能是二级原型）</strong>。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">obj, constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(<span class="keyword">constructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not an object`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">constructor</span> !== 'function') &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not callable`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要就这一句</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">constructor</span>.prototype.isPrototypeOf(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceOf(a, A)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="原型污染"><a href="#原型污染" class="headerlink" title="原型污染"></a>原型污染</h2><p>在去年 2019 年秋天我还在国内某大厂实习的时候，lodash 爆出了一个严重的安全漏洞：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdGZacTJQWnlsR2ZNak9wOGg4ZWVUdw==" title="https://mp.weixin.qq.com/s/tfZq2PZylGfMjOp8h8eeTw">Lodash 库爆出严重安全漏洞，波及 400 万+项目<i class="fa fa-external-link"></i></span>。这个安全漏洞就是由于<strong>原型污染</strong>导致的。</p><p>原型污染指的是：</p><blockquote><p>攻击者通过某种手段修改 JavaScript 对象的原型</p></blockquote><p>虽然说任何一个原型被污染了都有可能导致问题，但是我们一般提原型污染说的就是 <code>Object.prototype</code> 被污染。</p><h3 id="原型污染的危害"><a href="#原型污染的危害" class="headerlink" title="原型污染的危害"></a>原型污染的危害</h3><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>举个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.hack = <span class="string">'污染原型的属性'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'xiaoHong'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">xiaoHong</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>原型被污染会增加遍历的次数，每次访问对象自身不存在的属性时也要访问下原型上被污染的属性。</p><h4 id="导致意外的逻辑-bug"><a href="#导致意外的逻辑-bug" class="headerlink" title="导致意外的逻辑 bug"></a>导致意外的逻辑 bug</h4><p>看一个具体的 node 安全漏洞案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;</span><br><span class="line">      merge(a[attr], b[attr]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> admin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, express.static(path.join(__dirname, <span class="string">'views'</span>)));</span><br><span class="line">app.post(<span class="string">'/signup'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.body));</span><br><span class="line">  <span class="keyword">var</span> copybody = clone(body);</span><br><span class="line">  <span class="keyword">if</span> (copybody.name) &#123;</span><br><span class="line">    res.cookie(<span class="string">'name'</span>, copybody.name).json(&#123;</span><br><span class="line">      done: <span class="string">'cookie set'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      error: <span class="string">'cookie not set'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/getFlag'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> аdmin = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.cookies));</span><br><span class="line">  <span class="keyword">if</span> (admin.аdmin == <span class="number">1</span>) &#123;</span><br><span class="line">    res.send(<span class="string">'hackim19&#123;&#125;'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'You are not authorized'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这段代码的漏洞就在于 merge 函数上，我们可以这样攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -vv --header <span class="string">'Content-type: application/json'</span> -d <span class="string">'&#123;"__proto__": &#123;"admin": 1&#125;&#125;'</span> <span class="string">'http://127.0.0.1:4000/signup'</span>;</span><br><span class="line"></span><br><span class="line">curl -vv <span class="string">'http://127.0.0.1/getFlag'</span></span><br></pre></td></tr></table></figure><p>首先请求 <code>/signup</code> 接口，在 NodeJS 服务中，我们调用了有漏洞的 <code>merge</code> 方法，并通过 <code>__proto__</code> 为 <code>Object.prototype</code>（因为 <code>{}.__proto__ === Object.prototype</code>） 添加上一个新的属性 <code>admin</code>，且值为 1。</p><p>再次请求 <code>getFlag</code> 接口，访问了 Object 原型上的<code>admin</code>，条件语句 <code>admin.аdmin == 1</code> 为 <code>true</code>，服务被攻击。</p><h3 id="预防原型污染"><a href="#预防原型污染" class="headerlink" title="预防原型污染"></a>预防原型污染</h3><p>其实原型污染大多发生在调用会修改或者扩展对象属性的函数时，例如 lodash 的 defaults，jquery 的 extend。预防原型污染最主要还是要有防患意识，养成良好的编码习惯。</p><h4 id="Object-create-null"><a href="#Object-create-null" class="headerlink" title="Object.create(null)"></a>Object.create(null)</h4><p>笔者看过一些类库的源码时，经常能看到这种操作，例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ByaW11cy9ldmVudGVtaXR0ZXIzL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyMw==" title="https://github.com/primus/eventemitter3/blob/master/index.js#L23">EventEmitter3<i class="fa fa-external-link"></i></span>。通过 Object.create(null) 创建没有原型的对象，即便你对它设置<code>__proto__</code> 也没有用，因为它的原型一开始就是 null，没有 <code>__proro__</code> 的 <code>setter</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">obj.__proto__ = &#123; <span class="attr">hack</span>: <span class="string">'污染原型的属性'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h4><p>可以通过 Object.freeze(obj) 冻结对象 obj，被冻结的对象不能被修改属性，成为不可扩展对象。前面也说过不能修改不可扩展对象的原型，会抛 TypeError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.freeze(&#123; <span class="attr">name</span>: <span class="string">'xiaoHong'</span> &#125;);</span><br><span class="line">obj.xxx = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// =&gt; &#123; name: 'xiaoHong' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">// =&gt; false</span></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>; <span class="comment">// =&gt; TypeError: #&lt;Object&gt; is not extensible</span></span><br></pre></td></tr></table></figure><p>距离我从之前实习的公司离职也有将近三个月了，我记得那时候每次 <code>npm install</code> 都显示检查出几十个依赖漏洞。肯定是好久都没升级才会积累那么多漏洞，反正我是不敢随便升级，之前一个 bug 查了好半天结果是因为 axios 的升级导致的。也不知道到现在有没有升级过 😄。</p><p>参考资料：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDI3MTMzMmYyNjVkYTFiOTM0ZTJkNDg=" title="https://juejin.im/post/5d271332f265da1b934e2d48">最新：Lodash 严重安全漏洞背后你不得不知道的 JavaScript 知识<i class="fa fa-external-link"></i></span></li></ol><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p></div><p style="text-align:center">（完）</p><footer class="post-footer"><div class="post-tags"><a href="/tags/prototype/" rel="tag"><i class="fa fa-tag"></i> prototype</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E4%BD%BF%E7%94%A8-webpack-%E6%9E%84%E5%BB%BA-chrome-%E6%89%A9%E5%B1%95%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/" rel="prev" title="使用 webpack 构建 chrome 扩展的热更新问题"><i class="fa fa-chevron-left"></i> 使用 webpack 构建 chrome 扩展的热更新问题</a></div><div class="post-nav-item"><a href="/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/" rel="next" title="从零开始配置 react + typescript（一）：dotfiles">从零开始配置 react + typescript（一）：dotfiles <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-原型"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器和-prototype"><span class="nav-number">2.</span> <span class="nav-text">构造器和 prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">3.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型的用途"><span class="nav-number">4.</span> <span class="nav-text">原型的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-class-和构造器的关系"><span class="nav-number">5.</span> <span class="nav-text">ES6 class 和构造器的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-class"><span class="nav-number">5.1.</span> <span class="nav-text">ES6 class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extends-继承"><span class="nav-number">5.2.</span> <span class="nav-text">extends 继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型继承"><span class="nav-number">6.</span> <span class="nav-text">原型继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-和原型相关语法特性"><span class="nav-number">7.</span> <span class="nav-text">JavaScript 和原型相关语法特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-运算符原理"><span class="nav-number">7.1.</span> <span class="nav-text">new 运算符原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof-运算符原理"><span class="nav-number">7.2.</span> <span class="nav-text">instanceof 运算符原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型污染"><span class="nav-number">8.</span> <span class="nav-text">原型污染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型污染的危害"><span class="nav-number">8.1.</span> <span class="nav-text">原型污染的危害</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#性能问题"><span class="nav-number">8.1.1.</span> <span class="nav-text">性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导致意外的逻辑-bug"><span class="nav-number">8.1.2.</span> <span class="nav-text">导致意外的逻辑 bug</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预防原型污染"><span class="nav-number">8.2.</span> <span class="nav-text">预防原型污染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-create-null"><span class="nav-number">8.2.1.</span> <span class="nav-text">Object.create(null)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-freeze-obj"><span class="nav-number">8.2.2.</span> <span class="nav-text">Object.freeze(obj)</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="余腾靖" src="/images/avatar.png"><p class="site-author-name" itemprop="name">余腾靖</p><div class="site-description" itemprop="description">总结和分享我的所学所思</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95dS10ZW5nLWppbmcvYWN0aXZpdGllcw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yu-teng-jing&#x2F;activities"><i class="fa fa-fw fa-bookmark"></i>知乎</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81YWQwZGNhYTZmYjlhMDI4ZDkzNzk0Yjk=" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5ad0dcaa6fb9a028d93794b9"><i class="fa fa-fw fa-book"></i>掘金</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ng==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tjx666"><i class="fa fa-fw fa-github"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOnl0ajI3MTMxNTE3MTNAZ21haWwuY29t" title="E-Mail → mailto:ytj2713151713@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">余腾靖</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script></body></html>