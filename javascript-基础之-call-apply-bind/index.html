<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-x16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="veaTBtqt4ArdFO7yL4lECMYJsOeSwdptb1k8vJJBzMA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://lyreal666.com").hostname,root:"/",scheme:"Pisces",version:"7.7.1",exturl:!0,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!0,style:"default"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="系统，扎实的 javascript 语言基础是一个优秀的前端工程师必须具备的。在看了一些关于 call，apply，bind 的文章后，我还是打算写下这篇总结，原因有几个。首先，在如今 ES6 大行其道的今天，很多文章中讲述的它们的应用场景其实用 ES6 可以更优雅的解决，但是基本上·没有文章会去提 ES6 的解法。再则，讲它们的实现原理的文章其实不少，但是或多或少实现的有些不够完美，本文将把它们"><meta property="og:type" content="article"><meta property="og:title" content="javascript 基础之 call, apply, bind"><meta property="og:url" content="https://lyreal666.com/javascript-%E5%9F%BA%E7%A1%80%E4%B9%8B-call-apply-bind/index.html"><meta property="og:site_name" content="余腾靖的博客"><meta property="og:description" content="系统，扎实的 javascript 语言基础是一个优秀的前端工程师必须具备的。在看了一些关于 call，apply，bind 的文章后，我还是打算写下这篇总结，原因有几个。首先，在如今 ES6 大行其道的今天，很多文章中讲述的它们的应用场景其实用 ES6 可以更优雅的解决，但是基本上·没有文章会去提 ES6 的解法。再则，讲它们的实现原理的文章其实不少，但是或多或少实现的有些不够完美，本文将把它们"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2019/06/29/5d16c5b48ef8590170.png"><meta property="og:image" content="https://i.loli.net/2019/06/29/5d16d5a0b97eb35960.png"><meta property="og:image" content="https://i.loli.net/2019/06/29/5d16ec374162677354.png"><meta property="og:image" content="https://i.loli.net/2019/06/29/5d16fed23267568788.png"><meta property="article:published_time" content="2019-06-27T13:29:00.000Z"><meta property="article:modified_time" content="2020-03-10T14:23:24.598Z"><meta property="article:author" content="余腾靖"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2019/06/29/5d16c5b48ef8590170.png"><link rel="canonical" href="https://lyreal666.com/javascript-%E5%9F%BA%E7%A1%80%E4%B9%8B-call-apply-bind/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>javascript 基础之 call, apply, bind | 余腾靖的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="余腾靖的博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">余腾靖的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://lyreal666.com/javascript-%E5%9F%BA%E7%A1%80%E4%B9%8B-call-apply-bind/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="余腾靖"><meta itemprop="description" content="总结和分享我的所学所思"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余腾靖的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">javascript 基础之 call, apply, bind</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-06-27 21:29:00" itemprop="dateCreated datePublished" datetime="2019-06-27T21:29:00+08:00">2019-06-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-03-10 22:23:24" itemprop="dateModified" datetime="2020-03-10T22:23:24+08:00">2020-03-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>系统，扎实的 javascript 语言基础是一个优秀的前端工程师必须具备的。在看了一些关于 call，apply，bind 的文章后，我还是打算写下这篇总结，原因有几个。首先，在如今 ES6 大行其道的今天，很多文章中讲述的它们的应用场景其实用 ES6 可以更优雅的解决，但是基本上·没有文章会去提 ES6 的解法。再则，讲它们的实现原理的文章其实不少，但是或多或少实现的有些不够完美，本文将把它们通过代码一一比较完美的实现，让它们不再神秘。不谦虚的说，关于 call，apply，bind 的知识，看这一篇文章就够了。</p><p>文章中的源码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9kZWVwLWluLWZlL3RyZWUvbWFzdGVyL3NyYy9jYWxsQXBwbHlCaW5k" title="https://github.com/tjx666/deep-in-fe/tree/master/src/callApplyBind">deep-in-fe<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="改变函数中-this-指向的三兄弟"><a href="#改变函数中-this-指向的三兄弟" class="headerlink" title="改变函数中 this 指向的三兄弟"></a>改变函数中 this 指向的三兄弟</h2><p>我们知道在 javascript 的 function 中有 <code>this</code>，<code>arguments</code> 等关键字。本文不讨论 this 指向问题，那个都可以单独整一篇文章了。一个常见的使用场景是当你使用 <code>.</code> 来调用一个函数的时候，此时函数中 this 指向 <code>.</code> 前面的调用者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'YuTengjing'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  introduce() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello everyone! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 此时指向 person</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce()); <span class="comment">// =&gt; Hello everyone! My name is YuTengjing. I'm 22 years old.</span></span><br></pre></td></tr></table></figure><p>通过 call，apply，bind 这三兄弟可以改变 <code>introduce</code> 中 this 的指向。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call<i class="fa fa-external-link"></i></span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFriend = &#123;</span><br><span class="line">  name: <span class="string">'dongdong'</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce.call(myFriend)); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br></pre></td></tr></table></figure><p>通过上面代码我们可以看出 <code>introduce</code> 这个函数中的 this 指向被改成了 myFriend。Function.prototype.call 的函数签名是 <code>fun.call(thisArg, arg1, arg2, ...)</code>。第一个参数为调用函数时 this 的指向，随后的参数则作为函数的参数并调用，也就是 fn(arg1, arg2, …)。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHk=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply<i class="fa fa-external-link"></i></span></h3><p>apply 和 call 的区别只有一个，就是它只有两个参数，而且第二个参数为调用函数时的参数构成的数组。函数签名：<code>func.apply(thisArg, [argsArray])</code>。如果不用给函数传参数，那么他俩就其实是完全一样的，需要传参数的时候注意它的应该将参数转换成数组形式。</p><p>一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayHobbies</span>(<span class="params">...hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> likes <span class="subst">$&#123;hobbies.join(<span class="string">', '</span>)&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个等价</span></span><br><span class="line">displayHobbies.call(&#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;, <span class="string">'swimming'</span>, <span class="string">'basketball'</span>, <span class="string">'anime'</span>); <span class="comment">// =&gt; // =&gt; Bob likes swimming, basketball, anime.</span></span><br><span class="line">displayHobbies.apply(&#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;, [<span class="string">'swimming'</span>, <span class="string">'basketball'</span>, <span class="string">'anime'</span>]); <span class="comment">// =&gt; Bob likes swimming, basketball, anime.</span></span><br></pre></td></tr></table></figure><p>有些 API 比如 Math.max 它的参数为多参数，当我们有多参数构成的数组使或者说参数很多时该怎么办呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math.max 参数为多参数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在已知一个很大的元素为随机大小的整数数组</span></span><br><span class="line"><span class="keyword">const</span> bigRandomArray = [...Array(<span class="number">10000</span>).keys()].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.trunc(num * <span class="built_in">Math</span>.random()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎样使用 Math.max 获取 bigRandomArray 中的最大值呢？Math.max 接受的是多参数而不是数组参数啊!</span></span><br><span class="line"><span class="comment">// 思考下面的写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, bigRandomArray)); <span class="comment">// =&gt; 9936</span></span><br></pre></td></tr></table></figure><p>可以上 ES6 的话就简单了，使用扩展运算符即可，优雅简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...bigRandomArray));</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind<i class="fa fa-external-link"></i></span></h3><p>bind 和上面两个用途差别还是比较大，如同字面意思（绑定），是用来绑定 this 指向的，返回一个原函数被绑定 this 后的新函数。一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'YuTengjing'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello everyone! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFriend = &#123; <span class="attr">name</span>: <span class="string">'dongdong'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line">person.introduce = introduce.bind(myFriend);</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.introduce 的 this 已经被绑定到 myFriend 上了</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce()); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce.call(person)); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br></pre></td></tr></table></figure><p>bind 的函数签名是 <code>func.bind(thisArg, arg1, arg2, ...)</code>。春招的时候被问过 bind 的第二个参数是干嘛用的，因为我之前写代码本身不怎么用这几个 API，用的时候我也只用第一个参数，所以当时面试的时候被问这个问题的时候我还是愣了一下。不过其实如果可以传多个参数的话，猜也能猜得出来是干嘛用的，我当时就猜对了 φ(*￣ 0 ￣)。</p><h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><p>我们学习知识的时候不能只是停留在理解层面，需要去思考它们有什么用，应用场景有哪些。这样的话，当你处在这种场景中，你就能很自然的想出解决方案。</p><h3 id="多参函数转换为单个数组参数调用"><a href="#多参函数转换为单个数组参数调用" class="headerlink" title="多参函数转换为单个数组参数调用"></a>多参函数转换为单个数组参数调用</h3><p>javascript 中有很多 API 是接受多个参数的比如之前提过的 Math.max，还有很多例如 Math.min，Array.prototype.push 等它们都是接受多个参数的 API，但是有时候我们只有多个参数构成的数组，而且可能还特别大，这个时候就可以利用 apply 巧妙的来转换。</p><p>下面是利用 apply 来巧妙的合并数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>但是，其实用 ES6 可以非常的简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>所以，忘了这种用法吧（￣︶￣）↗ 　。</p><h3 id="将类数组转换为数组"><a href="#将类数组转换为数组" class="headerlink" title="将类数组转换为数组"></a>将<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9UeXBlZF9hcnJheXM=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">类数组<i class="fa fa-external-link"></i></span>转换为数组</h3><p>JavaScript 类型化数组是一种类似数组的对象，它们有数组的一些属性，但是如果你用 Array.isArray() 去测试会返回 false，常见的像 arguments，NodeList 等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testArrayLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有 length 属性没有 slice 属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// =&gt; 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.slice); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类数组不是数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// =&gt; &#123; [Iterator]  0: 'a', 1: 'b', 2: 'c', [Symbol(Symbol.iterator)]: [λ: values] &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> array = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array)); <span class="comment">// =&gt; true</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// =&gt; [ 'a', 'b', 'c' ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testArrayLike(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><p>其实 把 slice 换成 concat，splice 等其它 API 也是可以的。思考：<strong>为什么通过 Array.prototype.slice.call(arrayLike) 可以转换类数组为数组？</strong></p><p>我没有研究过 slice 的具体实现，猜测是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySlice = <span class="function"><span class="keyword">function</span>(<span class="params">start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> end = end === <span class="literal">undefined</span> ? array.length : end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resultArray = [];</span><br><span class="line">  <span class="keyword">if</span> (array.length === <span class="number">0</span>) <span class="keyword">return</span> resultArray;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">    resultArray.push(array[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我想 slice 内部实现可能就是会像我上面的代码一样只需要一个 length 属性，遍历元素返回新数组，所以调用 slice 时将其 this 指向类数组能正常工作。</p><p>其实，这个用法也可以忘了，用 ES6 来转换不造多简单，ES6 大法好 😂。</p><p>可以使用 Array.from(arrayLike)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>还可以使用扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [...arguments];</span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>ES6 class 出现之前，个人认为比较完美的继承是使用原型链加组合的继承方式，以前研究原型继承写的代码在这：<a href="https://github.com/tjx666/javascript-code-lab/tree/master/src/prototypeExtends" target="_blank" rel="noopener"><strong>prototypeExtends</strong></a>。这里不展开讲 javascript 的继承，那会又是一个巨坑。</p><p>组合继承其实很好理解，这个组合指的是子类的实例属性组合了父类的实例属性，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">type, color</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>, type);</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bird = <span class="keyword">new</span> Bird(<span class="string">'bird'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bird); <span class="comment">// =&gt; Bird &#123; type: 'bird', color: 'green' &#125;</span></span><br></pre></td></tr></table></figure><p>组合继承核心代码就是那句 Animal.call(this, type)，通过调用父类构造器并修改其 this 指向为子类实例来达到子类实例上组合父类的实例属性目的。</p><h2 id="自己实现-call，apply，bind"><a href="#自己实现-call，apply，bind" class="headerlink" title="自己实现 call，apply，bind"></a>自己实现 call，apply，bind</h2><h3 id="call-1"><a href="#call-1" class="headerlink" title="call"></a>call</h3><p>实现 call 主要有两种思路，一种是通过在 thisArg 上临时添加 func，然后直接调用 thisArg.func()。另外一种是利用 func.toString() 替换 this 为 thisArg，再 eval 来实现。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>下面这个版本主要为了说明思路，其实是有很多缺陷的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg.tempFunc = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.tempFunc(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.tempFunc;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>上面的代码中有一些缺陷：</p><ol><li><p>myCall 的第一个参数可能被传入非对象参数，要对不同类型的 thisArg 分别处理。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 中对 thisArg 的描述<i class="fa fa-external-link"></i></span>：</p><blockquote><p>在 <em>fun</em> 函数运行时指定的 <code>this</code> 值<em>。</em>需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener"><code>非严格模式</code></a>下运行，则指定为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 的 <code>this</code> 值会自动指向全局对象（浏览器中就是 window 对象），同时值为原始值（数字，字符串，布尔值）的 <code>this</code> 会指向该原始值的自动包装对象。</p></blockquote></li><li><p>可能 thisArg 原本就有一个属性叫 tempFunc，这是完全有可能的，按照上面的代码来实现 myCall 就把原有的 tempFunc 属性消除了。可以使用 ES6 Symbol 来解决这个问题。</p></li></ol><p>所以完善后的 myCall 是酱紫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> tempFunc(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">Symbol</span>(<span class="string">'Temp property'</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="built_in">Reflect</span>.deleteProperty(thisArg, tempFunc);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>讲第二中方式之前，先来聊聊其它的一些相关的东西。</p><h5 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString"></a>Function.prototype.toString</h5><p>调用一个函数的 toString 方法返回的是这个函数定义时代码字符：</p><p><img data-src="https://i.loli.net/2019/06/29/5d16c5b48ef8590170.png" alt="function toString"></p><p>我故意在 <code>console.log(&#39;hello world&#39;);</code> 上下插了一个空行，func 左右多打了几个空格，可以看到 func.toString() 返回的字符串完全是我定义 func 时的样子，多余的空行和空格依然存在，没有格式化。</p><h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5><p>eval 函数可以让我们将一个字符串当作代码来运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(ctx.name)'</span>); <span class="comment">// Bob</span></span><br></pre></td></tr></table></figure><h5 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h5><p>所以看到这里思路已经很清晰了：先通过 func.toString 拿到 func 的代码字符串，再替换其中的 this 为 thisArg，再使用 eval 获取替换 this 后的临时函数（函数名显然和 func 一样）并执行。代码实现就是酱紫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> tempFunc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换 this 为 thisArg</span></span><br><span class="line">  <span class="keyword">const</span> tempFuncString = funcString.replace(<span class="regexp">/this/g</span>, <span class="string">'thisArg'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 eval 构造一个临时函数并执行</span></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">eval</span>(<span class="string">`(<span class="subst">$&#123;tempFuncString&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 tempFunc 并传入参数</span></span><br><span class="line">  <span class="keyword">return</span> tempFunc(...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>添加一些打印语句后在 chrome 中的执行情况：<br><img data-src="https://i.loli.net/2019/06/29/5d16d5a0b97eb35960.png" alt="eval-call"></p><p>但是，<strong>这种实现方式其实是很扯淡的</strong>。它有很多不能容忍而且无解的缺陷：</p><ol><li>临时函数的作用域和 func 的作用域不一样。使用 eval(<code>(${tempFuncString})</code>) 时声明了一个和 func 同名的临时函数，它的作用域是 myCall 这个函数作用域，而 func 的作用域显然在 myCall 外。</li><li>替换 ‘this’ 时有可能 func 函数其中有字符串或者标识符本身包含了 ‘this’，比如 func 函数中有 console.log(‘this’) 这么一条输出语句，那这个 this 也被替换了，或者定义了个变量叫 xxthisxx。</li></ol><p>所以，相对而言，第一种实现更靠谱。</p><h3 id="apply-1"><a href="#apply-1" class="headerlink" title="apply"></a>apply</h3><p>call 和 apply 除了参数不一样之外没什么区别。所以稍微调整 myCall 中的参数和调用 func 时的调用形式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> func(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">Symbol</span>(<span class="string">'Temp property'</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[tempFunc];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>第二种方式就不写了，其实也很简单，不写主要时因为第二种实现没什么实用性，介绍它的就是为了扩展一下思路。</p><h3 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h3><p>使用 call 来实现 bind 是一个比较常见的面试题，类似于使用 map 实现 reduce，其实还是考察你 javascript 掌握的怎么样。如果面试被问到闭包有哪些实际应用你其实也可以说可以使用闭包来实现 bind，对吧，面试还是有些技巧的。</p><p>思路我上面其实已经说了，就是利用闭包和 call 就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行函数时 this 始终为外层函数中的 thisArg，前面的调用参数也被绑定为 args</span></span><br><span class="line">    <span class="keyword">return</span> func.call(thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printThisAndAndArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)&#125;</span>, arguments is <span class="subst">$&#123;[...<span class="built_in">arguments</span>].join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunc = printThisAndAndArgs.myBind(&#123; <span class="attr">name</span>: <span class="string">'Lily'</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">boundFunc(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// =&gt; This is &#123;"name":"Lily"&#125;, arguments is 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><p>按照惯例，上面实现的版本肯定是有些问题的ㄟ( ▔, ▔ )ㄏ。</p><h4 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h4><p>第一个问题是没处理当使用 new 调用的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent1 = Student.bind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent1(<span class="number">22</span>)); <span class="comment">// =&gt; Student &#123; name: 'ly', age: 22 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>)); <span class="comment">// =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 bind 当返回的函数被使用 new 调用时， thisArg 被忽略，此时 bind 函数的作用只是起到了绑定构造函数参数的作用。当前版本的 myBind 只是返回了一个空对象，没有在返回的实例对象上绑定属性。</p><p>这里补充一下 new 操作符的实现原理。我有一个项目<a href="https://github.com/tjx666/javascript-code-lab" target="_blank" rel="noopener"><strong>javascript-code-lab</strong></a>上保存我探索原生 js 奥秘的一些代码，有兴趣可以看看。其中我 new 操作符的实现是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _new = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">const</span> result = fn.call(target, ...args);</span><br><span class="line">    <span class="keyword">const</span> isObjectOrFunction = (result !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">'object'</span>) || <span class="keyword">typeof</span> result === <span class="string">'function'</span>);</span><br><span class="line">    <span class="keyword">return</span> isObjectOrFunction ? result : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很好理解，当我们调用 new fn(arg1, arg2, …) 的时候，其实相当于执行了 _new(fn, arg1, arg2, …)。具体内部的执行步骤是这样的：</p><p>首先构造一个空对象 target，它的原型应该为 fn.prototype，这里我使用了 ES6 的 Object.create 来实现。</p><p>然后我们需要在 target 上绑定你在 fn 中通过 this.key = value 来绑定到实例对象的属性。具体做法就是执行 fn 并且将其 this 指向 target，也就是 const result = fn.call(target, …args);。</p><p>最后还要注意的就是当 fn 的返回值 result 是对象或者函数的时候，new fn(arg1, arg2, …) 返回的就是指行 fn 的返回值而不是 target，否则直接返回 target，也就是实例对象。</p><p><img data-src="https://i.loli.net/2019/06/29/5d16ec374162677354.png" alt="new"></p><p>如果有人问你有哪些方式可以修改函数的 this 指向，其实 <strong>new 操作符也可以修改构造函数的指向</strong>，没毛病吧。</p><p>了解了 new 操作符的原理之后，我们再来看看上面我们实现的 myBind 为什么会在 new 时工作不正常。当我们调用 new BoundStudent2(22) 时，根据我上面讲的 new 的原理知道，在构造出一个以 BoundStudent.prototype 为原型的空对象 target 后，会调用 BoundStudent.call(target) 。但是，观察我们实现的 myBind，作为 myBind(thisArg) 的返回值的 BoundStudent2，它内部执行时始是调用 func.call(thisArg, …args, …otherArgs)，也就是说 this 始终是 thisArg，所以才没有绑定 name，age 属性到 target 上，其实是被绑定到了 thisArg 上去了。而且由于 BoundStudent.call(target) 返回值为 undefined，所以 new BoundStudent2(22) 的结果就是 target。</p><h4 id="区分函数是否是通过-new-调用"><a href="#区分函数是否是通过-new-调用" class="headerlink" title="区分函数是否是通过 new 调用"></a>区分函数是否是通过 new 调用</h4><p>上面我们分析了 new 调用 myBind 绑定的函数产生的问题的原因，那么该如何解决呢？想要解决这个问题我们必须得能够区分出调用 BoundFunc2 时是否是通过 new 来调用的。可以使用 ES6 中 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldy50YXJnZXQ=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target">new.target<i class="fa fa-external-link"></i></span> 来区分。</p><p><img data-src="https://i.loli.net/2019/06/29/5d16fed23267568788.png" alt="new.target"></p><p><strong>new.target</strong>属性允许你检测函数或构造方法是否是通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldw==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new<i class="fa fa-external-link"></i></span>运算符被调用的。在通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldw==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new<i class="fa fa-external-link"></i></span>运算符被初始化的函数或构造方法中，<code>new.target</code>返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent1 = Student.bind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent1(<span class="number">22</span>)); <span class="comment">// =&gt; Student &#123; name: 'ly', age: 22 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>)); <span class="comment">// =&gt; &#123; name: 'ly', age: 22 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="处理原型链"><a href="#处理原型链" class="headerlink" title="处理原型链"></a>处理原型链</h4><p>当前版本的 myBind 没有处理原型链，BoundStudent2 new 出来的实例无法访问 Student 原型链上的属性。修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">const</span> boundFunc = <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  boundFunc.prototype = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  boundFunc.prototype.constructor = boundFunc;</span><br><span class="line">  <span class="keyword">return</span> boundFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.type = <span class="string">'student'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>).type); <span class="comment">// =&gt; student</span></span><br></pre></td></tr></table></figure><h4 id="完善一些细节"><a href="#完善一些细节" class="headerlink" title="完善一些细节"></a>完善一些细节</h4><p>返回的函数毕竟是一个新的函数，它的有些属性需要我们修改。我们在处理一下 name 和 length 属性。如果一个函数 func 被绑定了英文叫 bound，那么 func.name 应该是 <code>bound func</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> boundFunc = func.bind(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(boundFunc.name); <span class="comment">// bound func</span></span><br></pre></td></tr></table></figure><p>func.length 表示函数的参数个数，但是 BoundFunc 的参数个数和 func 的参数个数可不一样，所以我们需要调整 func.length。值得注意的是 Function.prototype.name 和 Function.prototype.length 是不可写的，所以要通过 Object.defineProperties 来修改。</p><p>最终版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">const</span> boundFunc = <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  boundFunc.prototype = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  boundFunc.prototype.constructor = boundFunc;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(boundFunc, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      value: <span class="string">`bound <span class="subst">$&#123;func.name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    length: &#123;</span><br><span class="line">      value: func.length,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> boundFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.type = <span class="string">'student'</span>;</span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>).type); <span class="comment">// =&gt; student</span></span><br><span class="line"><span class="built_in">console</span>.log(BoundStudent2.name); <span class="comment">// =&gt; bound Student</span></span><br><span class="line"><span class="built_in">console</span>.log(BoundStudent2.length); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>bind 是 ES5 才新增的 API，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGlt" title="https://github.com/es-shims/es5-shim">es5-shim<i class="fa fa-external-link"></i></span> 是一个让传统和现代的浏览器引擎兼容 es5 的垫片库，其中 bind 的定义是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">defineProperties(FunctionPrototype, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .length is 1</span></span><br><span class="line">    <span class="comment">// 1. Let Target be the this value.</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 2. If IsCallable(Target) is false, throw a TypeError exception.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallable(target)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind called on incompatible '</span> + target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. Let A be a new (possibly empty) internal list of all of the</span></span><br><span class="line">    <span class="comment">//   argument values provided after thisArg (arg1, arg2 etc), in order.</span></span><br><span class="line">    <span class="comment">// XXX slicedArgs will stand in for "A" if used</span></span><br><span class="line">    <span class="keyword">var</span> args = array_slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// for normal call</span></span><br><span class="line">    <span class="comment">// 4. Let F be a new native ECMAScript object.</span></span><br><span class="line">    <span class="comment">// 11. Set the [[Prototype]] internal property of F to the standard</span></span><br><span class="line">    <span class="comment">//   built-in Function prototype object as specified in 15.3.3.1.</span></span><br><span class="line">    <span class="comment">// 12. Set the [[Call]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.1.</span></span><br><span class="line">    <span class="comment">// 13. Set the [[Construct]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.2.</span></span><br><span class="line">    <span class="comment">// 14. Set the [[HasInstance]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.3.</span></span><br><span class="line">    <span class="keyword">var</span> bound;</span><br><span class="line">    <span class="keyword">var</span> binder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> bound) &#123;</span><br><span class="line">        <span class="comment">// 15.3.4.5.2 [[Construct]]</span></span><br><span class="line">        <span class="comment">// When the [[Construct]] internal method of a function object,</span></span><br><span class="line">        <span class="comment">// F that was created using the bind function is called with a</span></span><br><span class="line">        <span class="comment">// list of arguments ExtraArgs, the following steps are taken:</span></span><br><span class="line">        <span class="comment">// 1. Let target be the value of F's [[TargetFunction]]</span></span><br><span class="line">        <span class="comment">//   internal property.</span></span><br><span class="line">        <span class="comment">// 2. If target has no [[Construct]] internal method, a</span></span><br><span class="line">        <span class="comment">//   TypeError exception is thrown.</span></span><br><span class="line">        <span class="comment">// 3. Let boundArgs be the value of F's [[BoundArgs]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 4. Let args be a new list containing the same values as the</span></span><br><span class="line">        <span class="comment">//   list boundArgs in the same order followed by the same</span></span><br><span class="line">        <span class="comment">//   values as the list ExtraArgs in the same order.</span></span><br><span class="line">        <span class="comment">// 5. Return the result of calling the [[Construct]] internal</span></span><br><span class="line">        <span class="comment">//   method of target providing args as the arguments.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = apply.call(target, <span class="keyword">this</span>, array_concat.call(args, array_slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        <span class="keyword">if</span> ($<span class="built_in">Object</span>(result) === result) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 15.3.4.5.1 [[Call]]</span></span><br><span class="line">        <span class="comment">// When the [[Call]] internal method of a function object, F,</span></span><br><span class="line">        <span class="comment">// which was created using the bind function is called with a</span></span><br><span class="line">        <span class="comment">// this value and a list of arguments ExtraArgs, the following</span></span><br><span class="line">        <span class="comment">// steps are taken:</span></span><br><span class="line">        <span class="comment">// 1. Let boundArgs be the value of F's [[BoundArgs]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 2. Let boundThis be the value of F's [[BoundThis]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 3. Let target be the value of F's [[TargetFunction]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 4. Let args be a new list containing the same values as the</span></span><br><span class="line">        <span class="comment">//   list boundArgs in the same order followed by the same</span></span><br><span class="line">        <span class="comment">//   values as the list ExtraArgs in the same order.</span></span><br><span class="line">        <span class="comment">// 5. Return the result of calling the [[Call]] internal method</span></span><br><span class="line">        <span class="comment">//   of target providing boundThis as the this value and</span></span><br><span class="line">        <span class="comment">//   providing args as the arguments.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// equiv: target.call(this, ...boundArgs, ...args)</span></span><br><span class="line">        <span class="keyword">return</span> apply.call(target, that, array_concat.call(args, array_slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 15. If the [[Class]] internal property of Target is "Function", then</span></span><br><span class="line">    <span class="comment">//     a. Let L be the length property of Target minus the length of A.</span></span><br><span class="line">    <span class="comment">//     b. Set the length own property of F to either 0 or L, whichever is</span></span><br><span class="line">    <span class="comment">//       larger.</span></span><br><span class="line">    <span class="comment">// 16. Else set the length own property of F to 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> boundLength = max(<span class="number">0</span>, target.length - args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17. Set the attributes of the length own property of F to the values</span></span><br><span class="line">    <span class="comment">//   specified in 15.3.5.1.</span></span><br><span class="line">    <span class="keyword">var</span> boundArgs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boundLength; i++) &#123;</span><br><span class="line">      array_push.call(boundArgs, <span class="string">'$'</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX Build a dynamic function with desired amount of arguments is the only</span></span><br><span class="line">    <span class="comment">// way to set the length property of a function.</span></span><br><span class="line">    <span class="comment">// In environments where Content Security Policies enabled (Chrome extensions,</span></span><br><span class="line">    <span class="comment">// for ex.) all use of eval or Function costructor throws an exception.</span></span><br><span class="line">    <span class="comment">// However in all of these environments Function.prototype.bind exists</span></span><br><span class="line">    <span class="comment">// and so this code will never be executed.</span></span><br><span class="line">    bound = $<span class="built_in">Function</span>(</span><br><span class="line">      <span class="string">'binder'</span>,</span><br><span class="line">      <span class="string">'return function ('</span> + array_join.call(boundArgs, <span class="string">','</span>) + <span class="string">')&#123; return binder.apply(this, arguments); &#125;'</span></span><br><span class="line">    )(binder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target.prototype) &#123;</span><br><span class="line">      Empty.prototype = target.prototype;</span><br><span class="line">      bound.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line">      <span class="comment">// Clean up dangling references.</span></span><br><span class="line">      Empty.prototype = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 18. Set the [[Extensible]] internal property of F to true.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).</span></span><br><span class="line">    <span class="comment">// 20. Call the [[DefineOwnProperty]] internal method of F with</span></span><br><span class="line">    <span class="comment">//   arguments "caller", PropertyDescriptor &#123;[[Get]]: thrower, [[Set]]:</span></span><br><span class="line">    <span class="comment">//   thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;, and</span></span><br><span class="line">    <span class="comment">//   false.</span></span><br><span class="line">    <span class="comment">// 21. Call the [[DefineOwnProperty]] internal method of F with</span></span><br><span class="line">    <span class="comment">//   arguments "arguments", PropertyDescriptor &#123;[[Get]]: thrower,</span></span><br><span class="line">    <span class="comment">//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;,</span></span><br><span class="line">    <span class="comment">//   and false.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// NOTE Function objects created using Function.prototype.bind do not</span></span><br><span class="line">    <span class="comment">// have a prototype property or the [[Code]], [[FormalParameters]], and</span></span><br><span class="line">    <span class="comment">// [[Scope]] internal properties.</span></span><br><span class="line">    <span class="comment">// XXX can't delete prototype in pure-js.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 22. Return F.</span></span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于这个库是用来兼容 ES5 的，所以没有用 ES6 的 <strong>new.target</strong> 而是用 <strong>instanceOf</strong> 来判断是否是使用 new 来调用的，也没有使用 ES6 的 Object.defineProperty 或者 Object.definePropertyies。可以看到官方源代码中的注释还是很详细清晰的，感兴趣的读者可以自行研究一下，有什么问题也可以在评论区提出来。</p><h2 id="几个疑问"><a href="#几个疑问" class="headerlink" title="几个疑问"></a>几个疑问</h2><h3 id="使用-bind-多次绑定一个函数，后续的绑定能生效吗？"><a href="#使用-bind-多次绑定一个函数，后续的绑定能生效吗？" class="headerlink" title="使用 bind 多次绑定一个函数，后续的绑定能生效吗？"></a>使用 bind 多次绑定一个函数，后续的绑定能生效吗？</h3><p>不能，被绑定后，后续再次使用 bind 绑定没有作用。最后执行函数 fn 时，this 始终时被指向第一次 bind 时的 thisArg。</p><h3 id="使用-bind-绑定函数-this-后，可以使用-call，apply-改变函数的指向吗？"><a href="#使用-bind-绑定函数-this-后，可以使用-call，apply-改变函数的指向吗？" class="headerlink" title="使用 bind 绑定函数 this 后，可以使用 call，apply 改变函数的指向吗？"></a>使用 bind 绑定函数 this 后，可以使用 call，apply 改变函数的指向吗？</h3><p>不能，原因和上面一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boundTest = test.bind(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;);</span><br><span class="line">boundTest(); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br><span class="line"></span><br><span class="line">boundTest = boundTest.bind(&#123; <span class="attr">name</span>: <span class="string">'dongdong'</span> &#125;);</span><br><span class="line">boundTest(); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br><span class="line"></span><br><span class="line">boundTest.call(&#123; <span class="attr">name</span>: <span class="string">'yinyin'</span> &#125;); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br></pre></td></tr></table></figure><p>其实最近看过有些公司前端面试还考了偏函数的知识，其实也用到了 bind。这里我不打算讲偏函数了，偏函数我有空再写一篇文章单独讲。</p><p>参考资料：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wMGRjNGFkOWI4M2Y=" title="https://www.jianshu.com/p/00dc4ad9b83f">JavaScript 中的 call、apply、bind 深入理解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzgxM2FhNWYyNjVkYTJkZDk0Y2Q3YzI=" title="https://juejin.im/post/5c813aa5f265da2dd94cd7c2">彻底弄清 this call apply bind 以及原生实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmVjNDE4M2YyNjVkYTYxNmIxMDQ0ZDc=" title="https://juejin.im/post/5bec4183f265da616b1044d7">面试官问：能否模拟实现 JS 的 bind 方法<i class="fa fa-external-link"></i></span></li></ol><p>如果文章内容有什么错误或者不当之处，欢迎在评论区指出。感谢您的阅读，如果文章对您有所帮助或者启发，不妨点个赞，关注一下呗。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p></div><p style="text-align:center">（完）</p><footer class="post-footer"><div class="post-tags"><a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E9%80%9A%E8%BF%87-koa2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="prev" title="通过 koa2 服务器实践探究浏览器 HTTP 缓存机制"><i class="fa fa-chevron-left"></i> 通过 koa2 服务器实践探究浏览器 HTTP 缓存机制</a></div><div class="post-nav-item"><a href="/%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93-JavaScript-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="next" title="全面总结 JavaScript 类型相关知识点">全面总结 JavaScript 类型相关知识点 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#改变函数中-this-指向的三兄弟"><span class="nav-number">1.</span> <span class="nav-text">改变函数中 this 指向的三兄弟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call"><span class="nav-number">1.1.</span> <span class="nav-text">call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply"><span class="nav-number">1.2.</span> <span class="nav-text">apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">1.3.</span> <span class="nav-text">bind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学以致用"><span class="nav-number">2.</span> <span class="nav-text">学以致用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多参函数转换为单个数组参数调用"><span class="nav-number">2.1.</span> <span class="nav-text">多参函数转换为单个数组参数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将类数组转换为数组"><span class="nav-number">2.2.</span> <span class="nav-text">将类数组转换为数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合继承"><span class="nav-number">2.3.</span> <span class="nav-text">组合继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自己实现-call，apply，bind"><span class="nav-number">3.</span> <span class="nav-text">自己实现 call，apply，bind</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call-1"><span class="nav-number">3.1.</span> <span class="nav-text">call</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方式一"><span class="nav-number">3.1.1.</span> <span class="nav-text">方式一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方式二"><span class="nav-number">3.1.2.</span> <span class="nav-text">方式二</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Function-prototype-toString"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">Function.prototype.toString</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eval"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">eval</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动手实现"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">动手实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-1"><span class="nav-number">3.2.</span> <span class="nav-text">apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-1"><span class="nav-number">3.3.</span> <span class="nav-text">bind</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-的实现原理"><span class="nav-number">3.3.1.</span> <span class="nav-text">new 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区分函数是否是通过-new-调用"><span class="nav-number">3.3.2.</span> <span class="nav-text">区分函数是否是通过 new 调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理原型链"><span class="nav-number">3.3.3.</span> <span class="nav-text">处理原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完善一些细节"><span class="nav-number">3.3.4.</span> <span class="nav-text">完善一些细节</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个疑问"><span class="nav-number">4.</span> <span class="nav-text">几个疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-bind-多次绑定一个函数，后续的绑定能生效吗？"><span class="nav-number">4.1.</span> <span class="nav-text">使用 bind 多次绑定一个函数，后续的绑定能生效吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-bind-绑定函数-this-后，可以使用-call，apply-改变函数的指向吗？"><span class="nav-number">4.2.</span> <span class="nav-text">使用 bind 绑定函数 this 后，可以使用 call，apply 改变函数的指向吗？</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="余腾靖" src="/images/avatar.png"><p class="site-author-name" itemprop="name">余腾靖</p><div class="site-description" itemprop="description">总结和分享我的所学所思</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95dS10ZW5nLWppbmcvYWN0aXZpdGllcw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yu-teng-jing&#x2F;activities"><i class="fa fa-fw fa-bookmark"></i>知乎</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81YWQwZGNhYTZmYjlhMDI4ZDkzNzk0Yjk=" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5ad0dcaa6fb9a028d93794b9"><i class="fa fa-fw fa-book"></i>掘金</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ng==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tjx666"><i class="fa fa-fw fa-github"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOnl0ajI3MTMxNTE3MTNAZ21haWwuY29t" title="E-Mail → mailto:ytj2713151713@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">余腾靖</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script></body></html>