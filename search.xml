<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始配置 react + typescript（三）：webpack</title>
    <url>/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Awebpack/</url>
    <content><![CDATA[<p>本篇为 <code>从零开始配置 react + typescript</code> 系列第三篇，将带大家完成模板项目的 webpack 配置。整个项目的配置我力求达到以下目标：</p><p><strong>灵活：</strong> 我在配置 eslint 是选择使用 js 格式而不是 json，就是为了灵活性，使用 js 文件可以让你使用环境变量动态配置，充分发挥 js 语言的能力。当然了，用 js 作配置文件也是有缺点的，不能使用 json schema 校验。</p><p><strong>新潮：</strong> 我觉得时刻保持对新事物的关注和尝试去使用它是一个优秀的素质。当然，追新很容易碰到坑，但是，没关系，我已经帮你们踩过了，踩不过去我也不会写出来 😂。从我 eslint <code>parserOptions.ecmaVersion</code> 设置为 2020， 还有经常来一发 <code>yarn upgrade --latest</code> 都可以体现出来。</p><p><strong>严格：</strong> 就像我平时判断相等性我大多数情况都是使用严格等 <code>===</code>，而不是非严格等 <code>==</code>，我觉得越严格，分析起来就越清晰，越早能发现问题。例如我么后面会使用一些 webpack 插件来严格检查模块大小写，检查是否有循环依赖。</p><p><strong>安逸：</strong> 项目中会尽量集成当前前端生态界实用的和能提高开发愉悦性的（换个词就是花里胡哨）工具。</p><p><strong>生产 ready</strong>：配置的时候针对不同的打包环境针对性优化，并确保能够投入生产环境使用。</p><p>如果读者是初次看到这篇文章，建议先看下前两篇：</p><ol><li><a href="https://lyreal666.com/从零开始配置-react-typescript（一）：dotfiles/">从零开始配置 react + typescript（一）：dotfiles</a></li><li><a href="https://lyreal666.com/从零开始配置-react-typescript（二）：linters-和-formatter/">从零开始配置 react + typescript（二）：linters 和 formatter</a></li></ol><p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">react-typescript-boilerplate<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="dev-server"><a href="#dev-server" class="headerlink" title="dev server"></a>dev server</h2><p>想当初我刚开始学前端框架的那时候，也是被 webpack 折磨的欲仙欲死，我是先自学的 node 才开始写前端，写 nodejs 很方便，自带的模块化方案 <code>commonjs</code>，写前端项目就要配置打包工具。当时最火的打包工具已经是 webpack 了，其次就是 <code>gulp</code>。配置 webpack 总是记不住 webpack 配置有哪些字段，还要扯到一堆相关的工具像 ES6 编译器 <code>babel</code>，CSS 预处理器 <code>sass</code>/<code>less</code>，CSS 后处理器 <code>postcss</code>，以及各种 webpack 的 loader 和 plugin。然后嫌麻烦就有一段时间都是用官方的脚手架，react 就用 <code>cra</code>，也就是 <code>create-react-app</code>，vue 就用 <code>vue-cli</code>。其实也挺好用的，不过说实话，我个人觉得，<code>cra</code> 没 <code>vue-cli</code> 设计的好，无论是易用性和扩展性都完败，cra 不方便用户修改 webpack 配置，vue-cli 不但易于用户修改 webpack 配置，还能让用户保存模板以及自带插件系统。我感觉 react 官方也意识到了这点，所以官方声称近期将会重点优化相关工具链。现在的话，如果我新建一个前端项目，我会选择自己配，不会去采用官方的 cli，因为我觉得我自己已经相当熟悉前端各种构建工具了，等我上半年忙完毕业和找工作的事情我应该会将一些常用的配置抽成一个 npm 包，现在每次写一个项目都 copy 改太累了，一个项目的构建配置有优化点，其它项目都要手动同步一下，效率太低。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>TypeScript 作为静态类型语言，相对于 js 而言，在类型提示上带来的提升无疑是巨大的。借助 IDE 的类型提示和代码补全，我们需要知道 webpack 配置对象有哪些字段就不用去查官方文档了，而且还不会敲错，很安逸，所以开发语言就选择 <strong>TypeScript</strong>。</p><p>官方文档上有专门一节 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2NvbmZpZ3VyYXRpb24tbGFuZ3VhZ2VzLw==" title="https://webpack.js.org/configuration/configuration-languages/">Configuration Languages<i class="fa fa-external-link"></i></span> 介绍怎么使用 ts 格式的配置文件配置 webpack 命令行工具，我觉得 <code>webpack-dev-server</code> 命令行工具应该是一样的。</p><p>但是我不打算使用官方文档介绍的方式，我压根不打算使用命令行工具，用 node API 才是<strong>最灵活</strong>的配置方式。配置 <code>webpack devServer</code> 总结一下有以下方式：</p><ol><li><code>webpack-dev-server</code>，这是最不灵活的方式，当然使用场景简单的情况下还是很方便的</li><li><code>webpack-dev-server</code> node API，在 node 脚本里面调用 <code>web-dev-server</code> 包提供的 node API 来启动 devServer</li><li><code>express</code> + <code>webpack devServer 相关中间件</code>，实际上 <code>webpack-dev-server</code> 就是使用 <code>express</code> 以及一些 devServer 相关的中间件开发的。在这种方式下， 各种中间件直接暴露出来了，我们可以灵活配置各个中间件的选项。</li><li><code>koa</code> + <code>webpack devServer 相关中间件</code>，我在 github 上还真的搜到了和 webpack devServer 相关的 webpack 中间件。其实 webpack devServer 就是一个 node server 嘛，用什么框架技术实现不重要，能实现我们需要的功能就行。</li></ol><p>我最终采用 <code>express</code> + <code>webpack devServer 相关中间件</code>的方式，为什么不选择用 <code>koa</code> ？因为我觉得官方用的就是 <code>express</code>，用 <code>express</code> 肯定要比 <code>koa</code> 更成熟稳定，坑要少一些。</p><h3 id="实现最基本的打包功能"><a href="#实现最基本的打包功能" class="headerlink" title="实现最基本的打包功能"></a>实现最基本的打包功能</h3><p>从简到繁，我们先来实现最基本的打包功能使其能够打包 <code>tsx</code> 文件，在此基础上一步一步丰富，优化我们的配置。</p><h4 id="配置入口文件"><a href="#配置入口文件" class="headerlink" title="配置入口文件"></a>配置入口文件</h4><p>先安装 TypeScript：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地安装开发依赖 typescript</span></span><br><span class="line">yarn add typescript -D</span><br></pre></td></tr></table></figure><p>每个 TypeScript 项目都需要有一个 <code>tsconfig.json</code> 配置文件，使用下面的命令在 <code>src</code> 目录下新建 <code>tsconfig.json</code> 文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src &amp;&amp; npx tsc --init &amp;&amp; <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>我们暂时调整成这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">/* Basic Options */</span></span><br><span class="line">        <span class="string">"jsx"</span>: <span class="string">"react"</span>,</span><br><span class="line">        <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">        <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictFunctionTypes"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictBindCallApply"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictPropertyInitialization"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">        <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"resolveJsonModule"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Experimental Options */</span></span><br><span class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advanced Options */</span></span><br><span class="line">        <span class="string">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"skipLibCheck"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用 babel 去编译 TypeScript，babel 在编译 TypeScript 代码是直接去掉 TypeScript 的类型，然后当成普通的 javascript 代码使用各种插件进行编译，因此 <code>tsconfig.json</code> 中很多选项例如 <code>target</code> 和 <code>module</code> 是没有用的。</p><blockquote><p>启用 <code>isolatedModules</code> 选项会在 babel 编译代码时提供一些额外的检查，<code>esModuleInterop</code> 这个选项是用来为了让没有 default 属性的模块也可以使用默认导入，举个简单的例子，如果这个选项没开启，那你导入 fs 模块只能像下面这样导入：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>开启了以后，可以直接使用默认导入：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>本质上 ESM 默认导入是导入模块的 default 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> __module__ <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">let</span> fs = __module__.default;</span><br></pre></td></tr></table></figure><p>但是 node 内建模块 fs 是没有 default 属性的，开启 <code>isolatedModules</code> 选项就会在没有 default 属性的情况下自动转换：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs, &#123; resolve &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="comment">// 转换成</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; resolve &#125; = fs;</span><br></pre></td></tr></table></figure></blockquote><p>我们添加一个入口文件 <code>src/index.tsx</code>，内容很简单：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plus <span class="keyword">from</span> <span class="string">'./plus'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(plus(<span class="number">404</span>, <span class="number">404</span>, <span class="number">404</span>, <span class="number">404</span>, <span class="number">404</span>)); <span class="comment">// =&gt; 2020</span></span><br></pre></td></tr></table></figure><p><code>src/plus.ts</code> 内容为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">...nums: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> pre + current, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译-TypeScript"><a href="#编译-TypeScript" class="headerlink" title="编译 TypeScript"></a>编译 TypeScript</h4><p>我们知道 webpack 默认的模块化系统只支持 js 文件，对于其它类型的文件如 jsx, ts, tsx, vue 以及图片字体等文件类型，我们需要安装对应的 loader。对于 ts 文件，目前存在比较流行的方案有三种:</p><ol><li><p>babel + <span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcHJlc2V0LXR5cGVzY3JpcHQ=" title="https://babeljs.io/docs/en/babel-preset-typescript">@babel/preset-typescript<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHMtbG9hZGVy" title="https://github.com/TypeStrong/ts-loader">ts-loader<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3MtcGFuZmVyb3YvYXdlc29tZS10eXBlc2NyaXB0LWxvYWRlcg==" title="https://github.com/s-panferov/awesome-typescript-loader">awesome-typescript-loader<i class="fa fa-external-link"></i></span></p></li></ol><p>awesome-typescript-loader 就算了，作者已经放弃维护了。首先 babel 我们一定要用的，因为 babel 生态有很多实用的插件。虽然 babel 是可以和 ts-loader 一起用，ts-loader 官方给了一个例子 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHMtbG9hZGVyL3RyZWUvbWFzdGVyL2V4YW1wbGVzL3JlYWN0LWJhYmVsLWthcm1hLWd1bHA=" title="https://github.com/TypeStrong/ts-loader/tree/master/examples/react-babel-karma-gulp">react-babel-karma-gulp<i class="fa fa-external-link"></i></span>，但是我觉得既然 babel 已经能够编译 TypeScript 我们就没必要再加一个 ts-loader，所以我选择方案一。需要指出的一点就是就是 babel 默认不会检查 TypeScript 的类型，后面 webpack 插件部分我们会通过配置 <code>fork-ts-checker-webpack-plugin</code> 来解决这个问题。</p><h4 id="添加-webpack-配置"><a href="#添加-webpack-配置" class="headerlink" title="添加 webpack 配置"></a>添加 webpack 配置</h4><p>我们将把所有 node 脚本放到项目根目的 <code>scripts</code> 文件夹，因为 <code>src</code> 文件夹是前端项目，而 <code>scripts</code> 文件夹是 node 项目，我们应该分别配置 <code>tsconfig.json</code>，通过下面的命令在其中生成初始的 <code>tsconfig.json</code> 文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./scripts &amp;&amp; npx tsc --init &amp;&amp; <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>我们调整成酱：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scripts/tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">/* Basic Options */</span></span><br><span class="line">        <span class="string">"target"</span>: <span class="string">"ES2020"</span>,</span><br><span class="line">        <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">        <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictFunctionTypes"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictBindCallApply"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"strictPropertyInitialization"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">        <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"resolveJsonModule"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Experimental Options */</span></span><br><span class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advanced Options */</span></span><br><span class="line">        <span class="string">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"skipLibCheck"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提几个需要注意的地方：</p><ul><li><p><code>&quot;target&quot;: &quot;ES2020&quot;</code>，其实编译级别你调的很低是没问题的，你用高级语法 tsc 就转码呗，缺点就是转码后代码体积会变大，执行效率也会降低，原生语法一般都是被优化过的。我喜欢调高一点，一般来说只要不用那些在代码运行平台还不支持的语法就没问题。自从 TypeScript3.7 支持了可选链，我就开始尝试在 TypeScript 使用它，但是问题来了，我之前编译级别一直都是调成最高，也就是 <code>ESNext</code>，因为可选链在 <code>ESNext</code> 已经是标准了，所以 tsc 对于可选链不会转码的。然后 node 12 还不支持可选链，就会报语法错误，于是我就降到 <code>ES2020</code> 了。</p></li><li><p><code>Strict Type-Checking Options</code>，这部分全开，既然上了 TypeScript 的船，就用最严格的类型检查，拒绝 AnyScript</p></li><li><p>删掉 <code>Additional Checks</code> 部份的配置，这部分 eslint 能做的更多，更好</p></li></ul><p>接着我们新建 <code>scripts/configs</code>文件夹，里面用来存放包括 webpack 的配置文件。在其中新建三个 webpack 的配置文件 <code>webpack.common.ts</code>， <code>webpack.dev.ts</code>和 <code>webapck.prod.ts</code>。<code>webpack.common.ts</code> 保存一些公共的配置文件，<code>webpack.dev.ts</code> 是开发环境用的，会被 devServer 读取，<code>webapck.prod.ts</code> 是我们在构建生产环境的 bundle 时用的。</p><p>我们接着安装 webpack 和 webpack-merge 以及它们的类型声明文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-merge @types/webpack @types/webpack-merge -D</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N1cnZpdmVqcy93ZWJwYWNrLW1lcmdl" title="https://github.com/survivejs/webpack-merge">webpack-merge<i class="fa fa-external-link"></i></span> 是一个为 merge webpack 配置设计的 merge 工具，提供了一些高级的 merge 方式。不过我目前并没有用到那些高级的 merge 方式，就是当成普通的 merge 工具使用，后续可以探索一下这方面的优化。</p><p>为了编译 tsx，我们需要安装 <code>babel-loader</code> 和相关插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader @babel/core @babel/preset-typescript -D</span><br></pre></td></tr></table></figure><p>新建 babel 配置文件 <code>babel.config.js</code>，现在我们只添加一个 TypeScript preset：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">api</span>) </span>&#123;</span><br><span class="line">  api.cache(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> presets = [<span class="string">'@babel/preset-typescript'</span>];</span><br><span class="line">  <span class="keyword">const</span> plugins = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    presets,</span><br><span class="line">    plugins,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加 babel-loader 到 <code>webpack.common.ts</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts`</span></span><br><span class="line"><span class="keyword">import</span> &#123; Configuration &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; projectName, projectRoot, resolvePath &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  context: projectRoot,</span><br><span class="line">  entry: resolvePath(projectRoot, <span class="string">'./src/index.tsx'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    path: resolvePath(projectRoot, <span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name]-[hash].bundle.js'</span>,</span><br><span class="line">    <span class="comment">// 加盐 hash</span></span><br><span class="line">    hashSalt: projectName || <span class="string">'react typescript boilerplate'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 我们导入ts 等模块一般不写后缀名，webpack 会尝试使用这个数组提供的后缀名去导入</span></span><br><span class="line">    extensions: [<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 导入 jsx 的人少喝点</span></span><br><span class="line">        test: <span class="regexp">/\.(tsx?|js)$/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 开启缓存</span></span><br><span class="line">        options: &#123; <span class="attr">cacheDirectory</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我觉得这个 react + ts 项目不应该会出现 jsx 文件，如果导入了 jsx 文件 webpack 就会报错找不到对应的 loader，可以让我们及时处理掉这个有问题的文件。</p><h4 id="使用-express-开发-devServer"><a href="#使用-express-开发-devServer" class="headerlink" title="使用 express 开发 devServer"></a>使用 express 开发 devServer</h4><p>我们先安装 <code>express</code> 以及和 webpack devServer 相关的一些中间件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add express webpack-dev-middleware webpack-hot-middleware @types/express @t</span><br><span class="line">ypes/webpack-dev-middleware @types/webpack-hot-middleware -D</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtbWlkZGxld2FyZQ==" title="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware<i class="fa fa-external-link"></i></span> 这个 <code>express</code> 中间件的主要作用：</p><ol><li>作为一个静态文件服务器，使用内存文件系统托管 webpack 编译出的 bundle</li><li>如果文件被修改了，会延迟服务器的请求直到编译完成</li><li>配合 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93ZWJwYWNrLWhvdC1taWRkbGV3YXJl" title="https://github.com/webpack-contrib/webpack-hot-middleware">webpack-hot-middleware<i class="fa fa-external-link"></i></span> 实现热更新功能</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93ZWJwYWNrLWhvdC1taWRkbGV3YXJl" title="https://github.com/webpack-contrib/webpack-hot-middleware">webpack-hot-middleware<i class="fa fa-external-link"></i></span> 这个 express 中间件会将自己注册为一个 webpack 插件，监听 webpack 的编译事件。 你哪个 chunck 需要实现热更新，就要在那个 chunk 中导入这个插件提供的 <code>webpack-hot-middleware/client.js</code> 客户端补丁。这个前端代码会获取 devServer 的 <span class="exturl" data-url="aHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZXZlbnRzb3VyY2UvYmFzaWNzLw==" title="http://www.html5rocks.com/en/tutorials/eventsource/basics/">Server Sent Events<i class="fa fa-external-link"></i></span> 连接，当有编译事件发生，devServer 会发布通知给这个客户端。客户端接受到通知后，会通过比对 hash 值判断本地代码是不是最新的，如果不是就会向 devServer 拉取更新补丁借助一些其它的工具例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhZWFyb24vcmVhY3QtaG90LWxvYWRlcg==" title="https://github.com/gaearon/react-hot-loader">react-hot-loader<i class="fa fa-external-link"></i></span> 实现热更新。</p><p>下面是我另外一个还在开发的 electron 项目修改了一行代码后， client 补丁发送的两次请求：</p><p><img data-src="https://i.loli.net/2020/02/16/QS1lFJt7fbIYEcG.png" alt="hash"></p><p><img data-src="https://i.loli.net/2020/02/16/PVpnHNC9G7rEtQT.png" alt="update"></p><p>第一次请求返回的那个 h 值动动脚趾头就能猜出来就是 hash 值，发现和本地的 hash 值比对不上后，再次请求更新补丁。</p><p>我们新建文件 <code>scripts/start.ts</code> 用来启动我们的 devServer：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span>;</span><br><span class="line"><span class="keyword">import</span> getPort <span class="keyword">from</span> <span class="string">'get-port'</span>;</span><br><span class="line"><span class="keyword">import</span> logSymbols <span class="keyword">from</span> <span class="string">'log-symbols'</span>;</span><br><span class="line"><span class="keyword">import</span> open <span class="keyword">from</span> <span class="string">'open'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; argv &#125; <span class="keyword">from</span> <span class="string">'yargs'</span>;</span><br><span class="line"><span class="keyword">import</span> express, &#123; Express &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> webpack, &#123; Compiler, Stats &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> historyFallback <span class="keyword">from</span> <span class="string">'connect-history-api-fallback'</span>;</span><br><span class="line"><span class="keyword">import</span> cors <span class="keyword">from</span> <span class="string">'cors'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackDevMiddleware <span class="keyword">from</span> <span class="string">'webpack-dev-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackHotMiddleware <span class="keyword">from</span> <span class="string">'webpack-hot-middleware'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> proxy <span class="keyword">from</span> <span class="string">'./proxy'</span>;</span><br><span class="line"><span class="keyword">import</span> devConfig <span class="keyword">from</span> <span class="string">'./configs/webpack.dev'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; hmrPath &#125; <span class="keyword">from</span> <span class="string">'./env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openBrowser</span>(<span class="params">compiler: Compiler, address: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argv.open) &#123;</span><br><span class="line">        <span class="keyword">let</span> hadOpened = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 编译完成时执行</span></span><br><span class="line">        compiler.hooks.done.tap(<span class="string">'open-browser-plugin'</span>, <span class="keyword">async</span> (stats: Stats) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 没有打开过浏览器并且没有编译错误就打开浏览器</span></span><br><span class="line">            <span class="keyword">if</span> (!hadOpened &amp;&amp; !stats.hasErrors()) &#123;</span><br><span class="line">                <span class="keyword">await</span> open(address);</span><br><span class="line">                hadOpened = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupMiddlewares</span>(<span class="params">compiler: Compiler, server: Express</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> publicPath = devConfig.output!.publicPath!;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置代理</span></span><br><span class="line">    proxy(server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 browserRouter 需要重定向所有 html 页面到首页</span></span><br><span class="line">    server.use(historyFallback());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发 chrome 扩展的时候可能需要开启跨域，参考：https://juejin.im/post/5e2027096fb9a02fe971f6b8</span></span><br><span class="line">    server.use(cors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> devMiddlewareOptions: webpackDevMiddleware.Options = &#123;</span><br><span class="line">        <span class="comment">// 保持和 webpack 中配置一致</span></span><br><span class="line">        publicPath,</span><br><span class="line">        <span class="comment">// 只在发生错误或有新的编译时输出</span></span><br><span class="line">        stats: <span class="string">'minimal'</span>,</span><br><span class="line">        <span class="comment">// 需要输出文件到磁盘可以开启</span></span><br><span class="line">        <span class="comment">// writeToDisk: true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    server.use(webpackDevMiddleware(compiler, devMiddlewareOptions));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hotMiddlewareOptions: webpackHotMiddleware.Options = &#123;</span><br><span class="line">        <span class="comment">// sse 路由</span></span><br><span class="line">        path: hmrPath,</span><br><span class="line">        <span class="comment">// 编译出错会在网页中显示出错信息遮罩</span></span><br><span class="line">        overlay: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// webpack 卡住自动刷新页面</span></span><br><span class="line">        reload: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    server.use(webpackHotMiddleware(compiler, hotMiddlewareOptions));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line">    <span class="comment">// 4个备选端口，都被占用会使用随机端口</span></span><br><span class="line">    <span class="keyword">const</span> PORT = <span class="keyword">await</span> getPort(&#123; <span class="attr">port</span>: [<span class="number">3000</span>, <span class="number">4000</span>, <span class="number">8080</span>, <span class="number">8888</span>] &#125;);</span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">`http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 webpack 配置</span></span><br><span class="line">    <span class="keyword">const</span> compiler = webpack(devConfig);</span><br><span class="line">    openBrowser(compiler, address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> devServer = express();</span><br><span class="line">    setupMiddlewares(compiler, devServer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> httpServer = devServer.listen(PORT, HOST, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// logSymbols.success 在 windows 平台渲染为 √ ，支持的平台会显示 ✔</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">`DevServer is running at <span class="subst">$&#123;chalk.magenta.underline(address)&#125;</span> <span class="subst">$&#123;logSymbols.success&#125;</span>`</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们监听了 node 信号，所以使用 cross-env-shell 而不是 cross-env</span></span><br><span class="line">    process.on(<span class="string">'SIGINT'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 先关闭 devServer</span></span><br><span class="line">        httpServer.close();</span><br><span class="line">        <span class="comment">// 在 ctrl + c 的时候随机输出 'See you again' 和 'Goodbye'</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            chalk.greenBright.bold(<span class="string">`\n<span class="subst">$&#123;<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">'See you again'</span> : <span class="string">'Goodbye'</span>&#125;</span>!`</span>),</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写过 python 的人应该不会陌生这种写法</span></span><br><span class="line"><span class="comment">// require.main === module 判断这个模块是不是被直接运行的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpackHotMiddleware</code> 的 <code>overlay</code> 选项是用于是否开启错误遮罩：</p><p><img data-src="https://i.loli.net/2020/02/20/lLQEXfwgY5khOeM.png" alt="overlay"></p><p>很多细节我都写到注释里面了，安装其中用到的一些工具库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add get-port <span class="built_in">log</span>-symbols open yarg -D</span><br></pre></td></tr></table></figure><p>前三个都是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cw==" title="https://github.com/sindresorhus">sindresorhus<i class="fa fa-external-link"></i></span> 大佬的作品，<code>get-port</code> 用于获取可用端口，<code>log-symbols</code> 提供了下面四个 log 字符，<code>open</code> 用于系统应用打开 <code>uri</code> （<code>uri</code> 包括文件和网址大家应该都知道）, <code>yargs</code> 用于解析命令行参数。</p><p><img data-src="https://github.com/sindresorhus/log-symbols/raw/master/screenshot.png" alt="log-symbols"></p><p><code>webpack-dev-middleware</code> 并不支持 <code>webpack-dev-server</code> 中的 <code>historyFallback</code> 和 <code>proxy</code> 功能，其实无所谓，我们可以通过 <strong>DIY</strong> 我们的 express server 来实现，我们甚至可以使用 <code>express</code> 来集成 <code>mock</code> 功能。安装对应的两个中间件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add connect-history-api-fallback http-proxy-middleware @types/connect-history-api-fallback @types/http-proxy-middleware -D</span><br></pre></td></tr></table></figure><p><code>connect-history-api-fallback</code> 可以直接作为 <code>express</code> 中间件集成到 express server，封装一下 <code>http-proxy-middleware</code>，可以在 <code>proxyTable</code> 中添加自己的代理配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createProxyMiddleware &#125; <span class="keyword">from</span> <span class="string">'http-proxy-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Express &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Options &#125; <span class="keyword">from</span> <span class="string">'http-proxy-middleware/dist/types'</span>;</span><br><span class="line"></span><br><span class="line">interface ProxyTable &#123;</span><br><span class="line">    [path: string]: Options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyTable: ProxyTable = &#123;</span><br><span class="line">    <span class="comment">// 示例配置</span></span><br><span class="line">    <span class="string">'/path_to_be_proxy'</span>: &#123; <span class="attr">target</span>: <span class="string">'http://target.domain.com'</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰链接的辅助函数, 修改颜色并添加下划线</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLink</span>(<span class="params">str: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chalk.magenta.underline(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">server: Express</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.entries(proxyTable).forEach(<span class="function">(<span class="params">[path, options]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = path;</span><br><span class="line">        <span class="keyword">const</span> to = options.target <span class="keyword">as</span> string;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`proxy <span class="subst">$&#123;renderLink(<span class="keyword">from</span>)&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'-&gt;'</span>)&#125;</span> <span class="subst">$&#123;renderLink(to)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-param-reassign</span></span><br><span class="line">        <span class="keyword">if</span> (!options.logLevel) options.logLevel = <span class="string">'warn'</span>;</span><br><span class="line">        server.use(path, createProxyMiddleware(options));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要更灵活的定义方式，请在下面直接使用 server.use(path, proxyMiddleware(options)) 定义</span></span><br><span class="line">    &#125;);</span><br><span class="line">    process.stdout.write(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> proxy;</span><br></pre></td></tr></table></figure><p>为了启动 devServer，我们还需要安装两个命令行工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add ts-node cross-env -D</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHMtbm9kZQ==" title="https://github.com/TypeStrong/ts-node">ts-node<i class="fa fa-external-link"></i></span> 可以让我们直接运行 TypeScript 代码，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbnRjZG9kZHMvY3Jvc3MtZW52Lw==" title="https://github.com/kentcdodds/cross-env/">cross-env<i class="fa fa-external-link"></i></span> 是一个跨操作系统的设置环境变量的工具，添加启动命令到 npm script：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"start"</span>: <span class="string">"cross-env-shell NODE_ENV=development ts-node --files -P ./scripts/tsconfig.json ./scripts/start.ts --open"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbnRjZG9kZHMvY3Jvc3MtZW52LyNjcm9zcy1lbnYtdnMtY3Jvc3MtZW52LXNoZWxs" title="https://github.com/kentcdodds/cross-env/#cross-env-vs-cross-env-shell">cross-env<i class="fa fa-external-link"></i></span> 官方文档提到如果要在 windows 平台处理 node 信号例如 <code>SIGINT</code>，也就是我们 <code>ctrl + c</code> 时触发的信号应该使用 <code>cross-env-shell</code> 命令而不是 <code>cross-env</code> 。</p><p>ts-node 为了提高执行速度，默认不会读取 <code>tsconfig.json</code> 中的 <code>files</code>, <code>include</code> 和 <code>exclude</code> 字段，而是基于模块依赖读取的。这会导致我们后面写的一些全局的 <code>.d.ts</code> 文件不会被读取，为此，我们需要指定 <code>--files</code> 参数，详情可以查看 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHMtbm9kZSNoZWxwLW15LXR5cGVzLWFyZS1taXNzaW5n" title="https://github.com/TypeStrong/ts-node#help-my-types-are-missing">help-my-types-are-missing<i class="fa fa-external-link"></i></span>。我们的 node 代码并不多，而且又不是经常性重启项目，直接让 ts-node 扫描整个 <code>scripts</code> 文件夹没多大影响。</p><p>启动我们的 dev server，通过 ctrl + c 退出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/16/DevliamMEKy1hTt.gif" alt="dev server"></p><h2 id="开发环境优化"><a href="#开发环境优化" class="headerlink" title="开发环境优化"></a>开发环境优化</h2><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>每个 webpack plugin 都是一个包含 apply 方法的 class，在我们调用 <code>compiler.run</code> 或者 <code>compiler.watch</code> 的时候它就会被调用，并且把 compiler 作为参数传它。compiler 对象提供了各个时期的 hooks，我们可以通过这些 hooks 挂载回调函数来实现各种功能，例如压缩，优化统计信息，在在编译完弹个编译成功的通知等。</p><p><img data-src="https://i.loli.net/2020/02/17/kqngMuoNQWj2CyG.png" alt="hooks"></p><h4 id="显示打包进度"><a href="#显示打包进度" class="headerlink" title="显示打包进度"></a>显示打包进度</h4><p><code>webpack-dev-server</code> 在打包时使用 <code>--progress</code> 参数会在控制台实时输出百分比表示当前的打包进度，但是从上面的图中可以看出只是输出了一些统计信息（stats）。想要实时显示打包进度我了解的有三种方式：</p><ol><li><p>webpack 内置的 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvcGx1Z2lucy9wcm9ncmVzcy1wbHVnaW4=" title="https://webpack.docschina.org/plugins/progress-plugin">webpack.ProgressPlugin<i class="fa fa-external-link"></i></span> 插件</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NsZXNzZy9wcm9ncmVzcy1iYXItd2VicGFjay1wbHVnaW4=" title="https://github.com/clessg/progress-bar-webpack-plugin">progress-bar-webpack-plugin<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL251eHQvd2VicGFja2Jhcg==" title="https://github.com/nuxt/webpackbar">webpackbar<i class="fa fa-external-link"></i></span></p></li></ol><p>内置的 <code>ProgressPlugig</code> 非常的原始，你可以在回调函数获取当前进度，然后按照自己喜欢的格式去打印：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">percentage, message, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// e.g. Output each progress message directly to the console:</span></span><br><span class="line">  <span class="built_in">console</span>.info(percentage, message, ...args);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> webpack.ProgressPlugin(handler);</span><br></pre></td></tr></table></figure><p><code>progress-bar-webpack-plugin</code> 这个插件不是显示百分比，而是显示一个用字符画出来的进度条：</p><p><img data-src="https://camo.githubusercontent.com/cb9c82719765ad966a2771f084175c9ec935124e/687474703a2f2f692e696d6775722e636f6d2f4f495031676e6a2e676966" alt="progress-bar-webpack-plugin"></p><p>这个插件其实还是挺简洁实用的，但是有个 bug ，如果在打印进度条的时候输出了其它语句，进度条就会错位，我们的 devServer 会在启动后会输出地址：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`DevServer is running at <span class="subst">$&#123;chalk.magenta.underline(address)&#125;</span> <span class="subst">$&#123;logSymbols.success&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>使用这个进度条插件就会出问题下面的问题，遂放弃。</p><p><img data-src="https://i.loli.net/2020/02/16/MvEgi4sw7WkjbnT.png" alt="progress-bar-webpack-plugin"></p><p><code>webpackbar</code> 是 nuxt 项目下的库，背靠 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL251eHQ=" title="https://github.com/nuxt">nuxt<i class="fa fa-external-link"></i></span>，质量绝对有保证。我之前有段时间用的是 <code>progress-bar-webpack-plugin</code>，因为我在 npm 官网搜索 <code>webpack progress</code>，综合看下来就它比较靠谱，<code>webpackbar</code> 都没搜出来。 看了下 <code>webpackbar</code> 的 <code>package.json</code>，果然 <code>keywords</code> 都是空的。<code>webpackBar</code> 还是我在研究 <code>ant design</code> 的 webpack 配置看到它用了这个插件，才发现了这个宝藏：</p><p><img data-src="https://i.loli.net/2020/02/19/MGDZLJBcK2yToN6.png" alt="webpackbar"></p><p>安装 <code>webpackbar</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpackbar @types/webpackbar -D</span><br></pre></td></tr></table></figure><p>添加配置到 <code>webpack.common.ts</code> 的 plugins 数组，颜色我们使用 react 蓝：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Configuration &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> WebpackBar(&#123;</span><br><span class="line">      name: <span class="string">'react-typescript-boilerplate'</span>,</span><br><span class="line">      <span class="comment">// react 蓝</span></span><br><span class="line">      color: <span class="string">'#61dafb'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h4><p>这个直接用 webpack 内置的 <code>BannerPlugin</code> 即可:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BannerPlugin, Configuration &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BannerPlugin(&#123;</span><br><span class="line">      raw: <span class="literal">true</span>,</span><br><span class="line">      banner: <span class="string">`/** @preserve Powered by react-typescript-boilerplate (https://github.com/tjx666/react-typescript-boilerplate) */`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/20/DusmAYnTV2JL4Xv.png" alt="copyright"></p><p>需要注意的是我们在版权声明的注释中加了 <code>@preserve</code> 标记，我们后面会使用 <code>terser</code> 在生产环境构建时压缩代码，压缩代码时会去掉所有注释，除了一些包含特殊标记的注释，例如我们添加的 <code>@preserve</code>。</p><h4 id="优化控制台输出"><a href="#优化控制台输出" class="headerlink" title="优化控制台输出"></a>优化控制台输出</h4><p>我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlb3dhcmluL2ZyaWVuZGx5LWVycm9ycy13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/geowarin/friendly-errors-webpack-plugin">friendly-errors-webpack-plugin<i class="fa fa-external-link"></i></span> 插件让控制台的输出更加友好，下面使用了之后编译成功时的效果：</p><p><img data-src="https://i.loli.net/2020/02/19/bj9hRKeUBMG1Hmv.png" alt="build successful"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add friendly-errors-webpack-plugin @types/friendly-errors-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> FriendlyErrorsPlugin <span class="keyword">from</span> <span class="string">'friendly-errors-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> FriendlyErrorsPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构建通知"><a href="#构建通知" class="headerlink" title="构建通知"></a>构建通知</h4><p><img data-src="https://i.loli.net/2020/02/19/wsWuPkh3x9GlL4a.png" alt="build notification"></p><p>在我大四实习之前，我就没完整写过 vue 项目的，在上家公司实习的那段时间主要就是写 vue，当时我对 vue-cli 那个频繁的错误通知很反感，我和同事说我想去掉这个通知，没曾想同事都是比较喜欢那个通知，既然有人需要，那我们这个项目也配一下。</p><p>我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY2NvQy93ZWJwYWNrLWJ1aWxkLW5vdGlmaWVy" title="https://github.com/RoccoC/webpack-build-notifier">webpack-build-notifier<i class="fa fa-external-link"></i></span> 来支持错误通知，这个插件是 TypeScript 写的，不需要安装 types：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack-build-notifier -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> WebpackBuildNotifierPlugin <span class="keyword">from</span> <span class="string">'webpack-build-notifier'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// suppressSuccess: true 设置只在第一次编译成功时输出成功的通知, rebuild 成功的时候不通知</span></span><br><span class="line">    <span class="keyword">new</span> WebpackBuildNotifierPlugin(&#123; <span class="attr">suppressSuccess</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为我不喜欢弹通知，所以模板项目中的我注释掉了这个插件，有需要的自己打开就行了。</p></blockquote><h4 id="严格检查路径大小写"><a href="#严格检查路径大小写" class="headerlink" title="严格检查路径大小写"></a>严格检查路径大小写</h4><p>下面的测试表明 webpack 默认对路径的大小写不敏感：</p><p><img data-src="https://i.loli.net/2020/02/16/czN2UDhGiXb3TJ5.png" alt="path case"></p><p>我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VydGhlbi9jYXNlLXNlbnNpdGl2ZS1wYXRocy13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/Urthen/case-sensitive-paths-webpack-plugin">case-sensitive-paths-webpack-plugin<i class="fa fa-external-link"></i></span> 对路径进行严格的大小写检查：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add <span class="keyword">case</span>-sensitive-paths-webpack-plugin @types/<span class="keyword">case</span>-sensitive-paths-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> CaseSensitivePathsPlugin <span class="keyword">from</span> <span class="string">'case-sensitive-paths-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> CaseSensitivePathsPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/16/FWdazBElvG8Mq4U.png" alt="path-case-check"></p><h4 id="循环依赖检查"><a href="#循环依赖检查" class="headerlink" title="循环依赖检查"></a>循环依赖检查</h4><p><img data-src="https://i.loli.net/2020/02/16/bHQEPLK1WiCXlBA.png" alt="circle-dependencies"></p><p>webpack 默认不会对循环依赖报错，通过 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FhY2tlcm1hbi9jaXJjdWxhci1kZXBlbmRlbmN5LXBsdWdpbg==" title="https://github.com/aackerman/circular-dependency-plugin">circular-dependency-plugin <i class="fa fa-external-link"></i></span>这个 webpack 插件可以帮我们及时发现循环依赖的问题：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add circular-dependency-plugin @types/circular-dependency-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> CircularDependencyPlugin <span class="keyword">from</span> <span class="string">'circular-dependency-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; projectRoot, resolvePath &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CircularDependencyPlugin(&#123;</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      failOnError: <span class="literal">true</span>,</span><br><span class="line">      allowAsyncCycles: <span class="literal">false</span>,</span><br><span class="line">      cwd: projectRoot,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/16/VOxjym6zZFftkhr.png" alt="circle dependencies error"></p><p>这里顺便提一下 <code>cwd</code> 也就是工作路径的问题，官方文档直接用 <code>process.cwd()</code>，这是一种不好的做法，项目路径和工作路径是不同的两个概念。在 node 中表示项目路径永远不要用 <code>preocess.cwd()</code>，因为总会有些沙雕用户不去项目根目录启动。<code>process.cwd()</code> 也就是工作路径返回的是你运行 node 时所在的路径，假设说项目在 <code>/code/projectRoot</code>，有些用户直接在系统根目录打开 terminal，来一句 <code>node ./code/projectRoot/index.js</code>，这时 <code>index.js</code> 中 <code>process.cwd()</code> 返回的是就是系统根路径 <code>/</code>，不是有些人认为的还是 <code>/code/projectRoot</code>。</p><p>获取项目路径应该使用 <code>path.resolve</code>：</p><p><img data-src="https://i.loli.net/2020/02/19/4wW75dVszApkQGe.png" alt="project root"></p><h4 id="清理上次打包的-bundle"><a href="#清理上次打包的-bundle" class="headerlink" title="清理上次打包的 bundle"></a>清理上次打包的 bundle</h4><p>前面介绍了一些花里胡哨的插件，也介绍了一些让我们项目保持健康的插件，现在我们开始介绍一些打包用的插件。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvaG5hZ2FuL2NsZWFuLXdlYnBhY2stcGx1Z2lu" title="https://github.com/johnagan/clean-webpack-plugin">clean-webpack-plugin<i class="fa fa-external-link"></i></span> 它会在第一次编译的时候删除 <code>dist</code> 目录中所有的文件，不过会保留 <code>dist</code> 文件夹，并且再每次 <code>rebuild</code> 的时候会删除所有不再被使用的文件。</p><p>这个项目也是 TypeScript 写的，总感觉 TypeScript 写的项目有种莫名的踏实感：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; CleanWebpackPlugin &#125; <span class="keyword">from</span> <span class="string">'clean-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> CleanWebpackPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="自动生成-index-html"><a href="#自动生成-index-html" class="headerlink" title="自动生成 index.html"></a>自动生成 index.html</h4><p>众所周知，腾讯的前端面试很喜欢考计算机网络，我曾多次被问到过如何更新强缓存的问题。解决强缓存立即更新的问题我们一般就是采取在文件名中插入文件内容的 hash 值，然后首页不使用强缓存。这样只要你更新了某个被强缓存的资源文件，由于更新后内容的 hash 值会变化，生成的文件名也会变化，这样你请求首页的时候由于访问的是一个新的资源路径，就会向服务器请求最新的资源。关于浏览器 HTTP 缓存可以看我另一篇文章：<a href="https://lyreal666.com/通过-koa2-服务器实践探究浏览器HTTP缓存机制/">通过-koa2-服务器实践探究浏览器 HTTP 缓存机制</a>。</p><p>我们后续优化生产环境构建的时候会对将 CSS 拆分成单独的文件，如果 index.html 中插入的引入外部样式的 <code>link</code> 标签的 <code>href</code> 是我们手动设置的，那每次修改样式文件，都会生成一个新的 hash 值，我们都要手动去修改这个路径，太麻烦了，更不要说在开发环境下文件是保存在内存文件系统的，你都看不到文件名。</p><p><img data-src="https://i.loli.net/2020/02/19/8OnBuWedj5z2CFP.png" alt="build hash"></p><p>使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phbnRpbW9uL2h0bWwtd2VicGFjay1wbHVnaW4=" title="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin<i class="fa fa-external-link"></i></span> 可以自动生成 index.html，并且插入引用到的 bundle 和被拆分的 CSS 等资源路径。</p><p>参考 <code>creat-react-app</code> 的模板，我们新建 <code>public</code> 文件夹，并在其中加入 <code>index.html</code>，<code>favico.ico</code>，<code>manifest.json</code> 等文件。<code>public</code> 文件夹用于存放一些将被打包到 <code>dist</code> 文件夹一同发布的文件。</p><p>安装并配置 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phbnRpbW9uL2h0bWwtd2VicGFjay1wbHVnaW4=" title="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin<i class="fa fa-external-link"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin @types/html-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HtmlWebpackPlugin <span class="keyword">from</span> <span class="string">'html-webpack-plugin'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; __DEV__, projectName, resolvePath, projectRoot, hmrPath &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlMinifyOptions: HtmlMinifierOptions = &#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">    collapseInlineTagWhitespace: <span class="literal">true</span>,</span><br><span class="line">    removeComments: <span class="literal">true</span>,</span><br><span class="line">    removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">    removeScriptTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">    removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">    minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    minifyJS: <span class="literal">true</span>,</span><br><span class="line">    minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// HtmlWebpackPlugin 会调用 HtmlMinifier 对 HTMl 文件进行压缩</span></span><br><span class="line">            <span class="comment">// 只在生产环境压缩</span></span><br><span class="line">            minify: __DEV__ ? <span class="literal">false</span> : htmlMinifyOptions,</span><br><span class="line">            <span class="comment">// 指定 html 模板路径</span></span><br><span class="line">            template: resolvePath(projectRoot, <span class="string">'./public/index.html'</span>),</span><br><span class="line">            <span class="comment">// 类型不好定义，any 一时爽...</span></span><br><span class="line">            <span class="comment">// 定义一些可以在模板中访问的模板参数</span></span><br><span class="line">            templateParameters: <span class="function">(<span class="params">...args: any[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> [compilation, assets, assetTags, options] = args;</span><br><span class="line">                <span class="keyword">const</span> rawPublicPath = commonConfig.output!.publicPath!;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    compilation,</span><br><span class="line">                    webpackConfig: compilation.options,</span><br><span class="line">                    htmlWebpackPlugin: &#123;</span><br><span class="line">                        tags: assetTags,</span><br><span class="line">                        files: assets,</span><br><span class="line">                        options,</span><br><span class="line">                    &#125;,</span><br><span class="line">        			<span class="comment">// 除掉 publicPath 的反斜杠，让用户在模板中拼接路径更自然</span></span><br><span class="line">                    PUBLIC_PATH: rawPublicPath.endsWith(<span class="string">'/'</span>)</span><br><span class="line">                        ? rawPublicPath.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">                        : rawPublicPath,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让用户可以像 <code>create-react-app</code> 一样在 <code>index.html</code> 里面通过 <code>PUBLIC_PATH</code> 访问发布路径，需要配置 <code>templateParameters</code> 选项添加 <code>PUBLIC_PATH</code> 变量到模板参数，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phbnRpbW9uL2h0bWwtd2VicGFjay1wbHVnaW4=" title="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin<i class="fa fa-external-link"></i></span> 默认支持部分 ejs 语法，我们可以通过下面的方式动态设置 <code>favicon.ico</code> , <code>mainfest.json</code> 等资源路径：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= `$&#123;PUBLIC_PATH&#125;/favicon.ico` %&gt;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= `$&#123;PUBLIC_PATH&#125;/logo192.png` %&gt;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"&lt;%= `$&#123;PUBLIC_PATH&#125;/manifest.json` %&gt;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="拷贝文件到-dist"><a href="#拷贝文件到-dist" class="headerlink" title="拷贝文件到 dist"></a>拷贝文件到 dist</h4><p><code>public</code> 文件夹中有一些文件例如 <code>favico.icon</code> 和 <code>mainfest.json</code> 需要被拷贝到 <code>dist</code> 文件夹，我们可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9jb3B5LXdlYnBhY2stcGx1Z2lu" title="https://github.com/webpack-contrib/copy-webpack-plugin">copy-webpack-plugin<i class="fa fa-external-link"></i></span> 在使用 devServer 的情况下将文件拷贝到内存文件系统，在生产环境构建的时拷贝到磁盘：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add copy-webpack-plugin @types/copy-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> CopyPlugin <span class="keyword">from</span> <span class="string">'copy-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyPlugin(</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 所有一级文件</span></span><br><span class="line">          <span class="keyword">from</span>: <span class="string">'*'</span>,</span><br><span class="line">          to: resolvePath(projectRoot, <span class="string">'./dist'</span>),</span><br><span class="line">          <span class="comment">// 目标类型是文件夹</span></span><br><span class="line">          toType: <span class="string">'dir'</span>,</span><br><span class="line">          <span class="comment">// index.html 会通过 html-webpack-plugin 自动生成，所以需要被忽略掉</span></span><br><span class="line">          ignore: [<span class="string">'index.html'</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      &#123; <span class="attr">context</span>: resolvePath(projectRoot, <span class="string">'./public'</span>) &#125;</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="检查-TypeScript-类型"><a href="#检查-TypeScript-类型" class="headerlink" title="检查 TypeScript 类型"></a>检查 TypeScript 类型</h4><p>babel 为了提高编译速度只支持 TypeScript 语法编译而不支持类型检查，为了在 webpack 打包的同时支持 ts 类型检查，我们会使用 webpack 插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvZm9yay10cy1jaGVja2VyLXdlYnBhY2stcGx1Z2lu" title="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin">fork-ts-checker-webpack-plugin<i class="fa fa-external-link"></i></span>，这个 webpack 插件会在一个单独的进程并行的进行 TypeScript 的类型检查，这个项目也是 TypeScript 写的，我们不需要安装 types。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add fork-ts-checker-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>添加到 <code>webpack.dev.ts</code>，限制使用的内存为 1G：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ForkTsCheckerWebpackPlugin <span class="keyword">from</span> <span class="string">'fork-ts-checker-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class="line">      memoryLimit: <span class="number">1024</span>,</span><br><span class="line">      <span class="comment">// babel 转换的是我们前端代码，所以是指向前端代码的 tsconfig.json</span></span><br><span class="line">      tsconfig: resolvePath(projectRoot, <span class="string">'./src/tsconfig.json'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时修改 <code>webpack.prod.ts</code>，因为我们生产环境构建并不会长时间的占用内存，所以可以调大点，我们就默认限制生产环境的构建使用的内存为 2G：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.ts</span></span><br><span class="line"><span class="keyword">const</span> prodConfig = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class="line">      memoryLimit: <span class="number">1024</span> * <span class="number">2</span>,</span><br><span class="line">      tsconfig: resolvePath(projectRoot, <span class="string">'./src/tsconfig.json'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="缓存神器"><a href="#缓存神器" class="headerlink" title="缓存神器"></a>缓存神器</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL216Z29kZGFyZC9oYXJkLXNvdXJjZS13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/mzgoddard/hard-source-webpack-plugin">hard-source-webpack-plugin<i class="fa fa-external-link"></i></span> 是一个给 <code>modules</code> 提供中间缓存步骤的 webpack 插件，为了看到效果我们可能需要运行两次，第一次就是正常的编译速度，第二次可能会快上很多倍，拿我开发的一个 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni92aWV3LWdpdGh1Yi1yZXBvc2l0b3J5" title="https://github.com/tjx666/view-github-repository">VSCode 插件 <i class="fa fa-external-link"></i></span>来测试一下：</p><p>我先把 <code>node_modules/.cache/hard-source</code> 缓存文件夹删掉，看看没有缓存的时候编译速度：</p><p><img data-src="https://i.loli.net/2020/02/17/ZucCU1dEev372bS.png" alt="no cache"></p><p>耗时 3.075 秒，重新编译：</p><p><img data-src="https://i.loli.net/2020/02/17/q5B6kUFSm3TyiLl.png" alt="cache"></p><p>哇 🚀，直接快了 3.6 倍多…</p><p>牛逼归牛逼，但是在我的实际使用时发现它会偶尔会出 bug ，不过概率不是很高，本来有 bug 倒没什么，只要作者还在维护就行，但是这个插件的作者貌似维护不是很积极了，最后一次提交代码是 18 年 12 月份，也就是说一年多没维护了。</p><p>不过呢，出 bug 一般把缓存删掉就能解决了，虽然有点小毛病，我们这个项目还是配一下，禁不住太香了 😆：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hard-source-webpack-plugin @types/hard-source-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HardSourceWebpackPlugin <span class="keyword">from</span> <span class="string">'hard-source-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> HardSourceWebpackPlugin(&#123; <span class="attr">info</span>: &#123; <span class="attr">mode</span>: <span class="string">'none'</span>, <span class="attr">level</span>: <span class="string">'warn'</span> &#125; &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好了，插件部分介绍完了，接下来开始配置 loaders ！</p><h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>webpack 默认只支持导入 js，处理不了其它文件，需要配置对应的 loader，像 <code>excel-loader</code> 就可以解析 excel 为一个对象，<code>file-loader</code> 可以解析 png 图片为最终的发布路径。loader 是作用于一类文件的，plugin 是作用于 webpack 编译的各个时期。</p><p>前面我们只配置了 <code>babel-loader</code>， 使得 webpack 能够处理 TypeScript 文件，实际的开发中我们还需要支持导入样式文件，图片文件，字体文件等。</p><h4 id="处理样式文件"><a href="#处理样式文件" class="headerlink" title="处理样式文件"></a>处理样式文件</h4><p>我们最终要达到的目标是支持 css/less/sass 三种语法，以及通过 <code>postcss</code> 和 <code>autoprefixer</code> 插件实现自动补齐浏览器头等功能。</p><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>处理 css 文件我们需要安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXI=" title="https://github.com/webpack-contrib/style-loader">style-loader<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9jc3MtbG9hZGVy" title="https://github.com/webpack-contrib/css-loader">css-loader<i class="fa fa-external-link"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add css-loader style-loader -D</span><br></pre></td></tr></table></figure><p><code>css-loader</code> 作用是处理 CSS 文件中的 <code>@import</code> 和 <code>url()</code> 返回一个合并后的 CSS 字符串，而 <code>style-loader</code> 负责将返回的 CSS 字符串用 <code>style</code> 标签插到 DOM 中，并且还实现了 webpack 的热更新接口。</p><p><code>style-loader</code> 官方示例配置是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// i 后缀忽略大小写</span></span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到匹配正则用了 <code>i</code> 后缀，我觉得这样不好，不应该提高一些无意义的容错率，用<code>.CSS</code> 做后缀就不应该让 webpack 编译通过。我们知道 webpack 的 loaders 加载顺序是从右到左的，所以需要先执行的 <code>css-loader</code> 应该在后执行的 <code>style-loader</code> 后面：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// CSS modules 比较耗性能，默认就是禁用的</span></span><br><span class="line">              modules: <span class="literal">false</span>,</span><br><span class="line">              <span class="comment">// 开启 sourcemap</span></span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">              <span class="comment">// 指定在 CSS loader 处理前使用的 laoder 数量</span></span><br><span class="line">              importLoaders: <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><p><code>less-loader</code> 依赖 <code>less</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less less-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">false</span>,</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">              <span class="comment">// 需要先被 less-loader 处理，所以这里设置为 1</span></span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 先让 less-loader 将 less 文件转换成 css 文件</span></span><br><span class="line">            <span class="comment">// 再交给 css-loader 处理</span></span><br><span class="line">            loader: <span class="string">'less-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h5><p>其实我本人从来不用 <code>less</code> 和 <code>stylus</code>，我一直用的是 <code>sass</code>。<code>sass</code> 有两种语法格式，通过后缀名区分。<code>.sass</code> 后缀名是类似 <code>yml</code> 的缩进写法，<code>.scss</code> 是类似于 CSS 的花括号写法，不过支持嵌套和变量等特性。鉴于我基本上没看过哪个项目用 <code>yml</code> 格式的写法，用的人太少了，我们模板就只支持 <code>scss</code> 后缀好了。<code>sass-loader</code> 同样依赖 <code>node-sass</code>，<code>node-sass</code> 真是个碧池，没有代理还安装不了，所以我在系列第一篇就在 <code>.npmrc</code> 就配置了 <code>node-sass</code> 的镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add node-sass sass-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">false</span>,</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 中间每个 loader 都要开启 sourcemap，才能生成正确的 soucemap</span></span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h5><p><img data-src="https://i.loli.net/2020/02/20/Mxsl8rQdU1tNiYm.png" alt="browser prefix"></p><p>记得我在大一上网页设计课学到 CSS3 的时候，很多属性都要加浏览器头处理兼容性，当时就对 CSS 兴趣大减，太麻烦了。自从 node 的出现，前端工程化开始飞速发展，以前前端老被叫做切图仔，现在前端工程师也可以用 node 做伪全栈开发了。</p><p><strong>postcss</strong> 是 CSS 后处理器工具，因为先有 CSS，<code>postcss</code> 后去处理它，所以叫后处理器。</p><p><strong>less/sass</strong> 被称之为 CSS 预处理器，因为它们需要被 <code>less</code> 或 <code>node-sass</code> 预先编译代码到 CSS 嘛。</p><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3Qtc2NyaXB0cy9jb25maWcvd2VicGFjay5jb25maWcuanMjTDk2" title="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/config/webpack.config.js#L96">create-react-app 对 postcss 的配置<i class="fa fa-external-link"></i></span>，安装以下插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add postcss-loader postcss-flexbugs-fixes postcss-preset-env autoprefixer postcss-normalize -D</span><br></pre></td></tr></table></figure><p>添加 <code>postcss.config.js</code> 用于配置 <code>postcss</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 修复一些和 flex 布局相关的 bug</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</span><br><span class="line">    <span class="comment">// 参考 browserslist 的浏览器兼容表自动对那些还不支持的现代 CSS 特性做转换</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)(&#123;</span><br><span class="line">      <span class="comment">// 自动添加浏览器头</span></span><br><span class="line">      autoprefixer: &#123;</span><br><span class="line">        <span class="comment">// will add prefixes only for final and IE versions of specification</span></span><br><span class="line">        flexbox: <span class="string">'no-2009'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      stage: <span class="number">3</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 根据 browserslist 自动导入需要的 normalize.css 内容</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-normalize'</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们还需要添加 <code>browserslist</code> 配置到 <code>package.json</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"browserslist"</span>: [</span><br><span class="line">        <span class="string">"last 2 versions"</span>,</span><br><span class="line">        <span class="comment">// ESR（Extended Support Release） 长期支持版本</span></span><br><span class="line">        <span class="string">"Firefox ESR"</span>,</span><br><span class="line">        <span class="string">"&gt; 1%"</span>,</span><br><span class="line">        <span class="string">"ie &gt;= 11"</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾 CSS， less，sass 的配置可以看到有大量的重复，我们重构并修改 <code>importLoaders</code> 选项：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCssLoaders</span>(<span class="params">importLoaders: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'style-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">false</span>,</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">        importLoaders,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123; <span class="attr">sourceMap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: getCssLoaders(<span class="number">1</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// postcss-loader + less-loader 两个 loader，所以 importLoaders 应该设置为 2</span></span><br><span class="line">          ...getCssLoaders(<span class="number">2</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'less-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          ...getCssLoaders(<span class="number">2</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123; <span class="attr">sourceMap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="处理图片和字体"><a href="#处理图片和字体" class="headerlink" title="处理图片和字体"></a>处理图片和字体</h4><p>一般来说我们的项目在开发的时候会使用一些图片来测试效果，正式上线再替换成 CDN 而不是使用 webpack 打包的本地图片。处理文件的常用 loader 有俩，<code>file-loader</code> 和 <code>url-loader</code>，<code>file-loader</code> 用于解析导入的文件为发布时的 url， 并将文件输出到指定的位置，而后者是对前者的封装，提供了将低于阈值体积(下面就设置为 8192 个字节）的图片转换成 base64。我忽然想起以前腾讯的一个面试官问过这么个问题：使用 base64 有什么坏处吗？其实我觉得 base64 好处就是不用二次请求，坏处就是图片转 base64 体积反而会变大，变成原来的三分之四倍。</p><p><img data-src="https://i.loli.net/2020/02/20/IouO1Kvt5wFAWVl.png" alt="base64"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add url-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: [<span class="regexp">/\.bmp$/</span>, /\.gif$/, /\.jpe?g$/, /\.png$/],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 图片低于 10k 会被转换成 base64 格式的 dataUrl</span></span><br><span class="line">              limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">              <span class="comment">// [hash] 占位符和 [contenthash] 是相同的含义</span></span><br><span class="line">              <span class="comment">// 都是表示文件内容的 hash 值，默认是使用 md5 hash 算法</span></span><br><span class="line">              name: <span class="string">'[name].[contenthash].[ext]'</span>,</span><br><span class="line">              <span class="comment">// 保存到 images 文件夹下面</span></span><br><span class="line">              outputPath: <span class="string">'images'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(ttf|woff|woff2|eot|otf)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'[name]-[contenthash].[ext]'</span>,</span><br><span class="line">              outputPath: <span class="string">'fonts'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到我这里文件名中都插入了文件内容 hash 值，这样就可以解决<strong>强缓存需要立即更新</strong>的问题。</p><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><table><thead><tr><th>devtool</th><th>构建速度</th><th>重新构建速度</th><th>生产环境</th><th>品质(quality)</th></tr></thead><tbody><tr><td>(none)</td><td>+++</td><td>+++</td><td>yes</td><td>打包后的代码</td></tr><tr><td>eval</td><td>+++</td><td>+++</td><td>no</td><td>生成后的代码</td></tr><tr><td>cheap-eval-source-map</td><td>+</td><td>++</td><td>no</td><td>转换过的代码（仅限行）</td></tr><tr><td>cheap-module-eval-source-map</td><td>o</td><td>++</td><td>no</td><td>原始源代码（仅限行）</td></tr><tr><td>eval-source-map</td><td>–</td><td>+</td><td>no</td><td>原始源代码</td></tr><tr><td>cheap-source-map</td><td>+</td><td>o</td><td>yes</td><td>转换过的代码（仅限行）</td></tr><tr><td>cheap-module-source-map</td><td>o</td><td>-</td><td>yes</td><td>原始源代码（仅限行）</td></tr><tr><td>inline-cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>转换过的代码（仅限行）</td></tr><tr><td>inline-cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>原始源代码（仅限行）</td></tr><tr><td>source-map</td><td>–</td><td>–</td><td>yes</td><td>原始源代码</td></tr><tr><td>inline-source-map</td><td>–</td><td>–</td><td>no</td><td>原始源代码</td></tr><tr><td>hidden-source-map</td><td>–</td><td>–</td><td>yes</td><td>原始源代码</td></tr><tr><td>nosources-source-map</td><td>–</td><td>–</td><td>yes</td><td>无源代码内容</td></tr></tbody></table><blockquote><p><code>+++</code> 非常快速, <code>++</code> 快速, <code>+</code> 比较快, <code>o</code> 中等, <code>-</code> 比较慢, <code>--</code> 慢</p></blockquote><p>sourcemap 是现在前端界很多工具必不可缺的一个功能，webpack，TypeScript，babel，powser-assert 等转换代码的工具都要提供 sourcemap 功能，源代码被压缩，混淆，polyfill，没有 sourcemap，根本没办法调试定位问题。</p><p>考虑到编译速度，调式友好性，我选择 <code>eval-source-map</code>，如果用户在打包时觉得慢，而且能够忍受没有列号，可以考虑调成 <code>cheap-eval-source-map</code>。</p><p>我们修改 <code>webpack.dev.ts</code> 的 devtool 为 <code>eval-source-map</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.ts</span></span><br><span class="line"><span class="keyword">import</span> commonConfig <span class="keyword">from</span> <span class="string">'./webpack.common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = merge(commonConfig, &#123;</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里顺便提一下 webpack 插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Ntb290aC1jb2RlL2Vycm9yLW92ZXJsYXktd2VicGFjay1wbHVnaW4=" title="https://github.com/smooth-code/error-overlay-webpack-plugin">error-overlay-webpack-plugin<i class="fa fa-external-link"></i></span>，它提供了和 create-react-app 一样的错误遮罩：</p><p><img data-src="https://raw.githubusercontent.com/smooth-code/error-overlay-webpack-plugin/master/docs/example.png" alt="error overlay"></p><p>但是它有一个限制就是不能使用任何一种基于 <code>eval</code> 的 sourcemap，感兴趣的读者可以尝试以下。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>我们前面给 devServer 添加了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93ZWJwYWNrLWhvdC1taWRkbGV3YXJl" title="https://github.com/webpack-contrib/webpack-hot-middleware">webpack-hot-middleware<i class="fa fa-external-link"></i></span> 中间件，参考它的文档我们需要先添加 webapck 插件<code>webpack.HotModuleReplacementPlugin</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; HotModuleReplacementPlugin, NamedModulesPlugin &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = merge(commonConfig, &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> HotModuleReplacementPlugin(), <span class="keyword">new</span> NamedModulesPlugin()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>NamedModulesPlugin</code> 这个插件可以在 <code>rebuild</code> 的时候显示哪些模块被修改了。</p><p>还要添加 <code>&#39;webpack-hot-middleware/client&#39;</code> 热更新补丁到我们的 bundle，加入 entry 数组即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; __DEV__, hmrPath &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">    entry: [resolvePath(projectRoot, <span class="string">'./src/index.tsx'</span>)],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    (commonConfig.entry <span class="keyword">as</span> string[]).unshift(<span class="string">`webpack-hot-middleware/client?path=<span class="subst">$&#123;hmrPath&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 entry 后面加 <code>queryString</code> 的方式可以让我们配置一些选项，它是怎么实现的呢？查看 <code>&#39;webpack-hot-middleware/client&#39;</code> 源码可以看到，webpack 会将 <code>queryString</code> 作为全局变量注入这个文件：</p><p><img data-src="https://i.loli.net/2020/02/18/h1njS2olHADUV8R.png" alt="entry query"></p><p>其实到这我们也就支持了 CSS 的热更新（style-loader 实现了热更新接口），如果要支持 react 组件的热更新我们还需要配置 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhZWFyb24vcmVhY3QtaG90LWxvYWRlcg==" title="https://github.com/gaearon/react-hot-loader">react-hot-loader<i class="fa fa-external-link"></i></span> ，配置它之前我们先来优化我们的 babel 配置。</p><h3 id="babel-配置优化"><a href="#babel-配置优化" class="headerlink" title="babel 配置优化"></a>babel 配置优化</h3><p>前面我们在前面只配置了一个 <code>@babel/preset-typescript</code> 插件用于编译 TypeScript，其实还有很多可以优化的点。</p><h4 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h4><p>在 babel 中，<strong>preset 表示 plugin 的集合</strong>，<code>@babel/preset-env</code> 可以让 babel 根据我们配置的 browserslist 只添加需要转换的语法和 polyfill。</p><p>安装 <code>@babel/preset-env</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-env -D</span><br></pre></td></tr></table></figure><h4 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h4><p>我们知道默认情况下， babel 在编译每一个模块的时候在需要的时候会插入一些辅助函数例如 <code>_extend</code>，每一个需要的模块都会生成这个辅助函数会造成没必要的代码膨胀，<code>@babel/plugin-transform-runtime</code> 这个插件会将所有的辅助函数都从 <code>@babel/runtime</code> 导入，来减少代码体积。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><h4 id="babel-preset-react"><a href="#babel-preset-react" class="headerlink" title="@babel/preset-react"></a>@babel/preset-react</h4><p>虽然 <code>@babel/preset-typescript</code> 就能转换 tsx 成 js 代码，但是 <code>@babel/preset-react</code> 还集成了一些针对 react 项目的实用的插件。</p><p><code>@babel/preset-react</code> 默认会开启下面这些插件:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXN5bnRheC1qc3g=" title="https://babeljs.io/docs/en/babel-plugin-syntax-jsx">@babel/plugin-syntax-jsx<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3g=" title="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx">@babel/plugin-transform-react-jsx<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1kaXNwbGF5LW5hbWU=" title="https://babeljs.io/docs/en/babel-plugin-transform-react-display-name">@babel/plugin-transform-react-display-name<i class="fa fa-external-link"></i></span></li></ul><p>如果设置了 <code>development: true</code> 还会开启:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gtc2VsZg==" title="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self">@babel/plugin-transform-react-jsx-self<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gtc291cmNl" title="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source">@babel/plugin-transform-react-jsx-source<i class="fa fa-external-link"></i></span></li></ul><p>安装依赖 <code>@babel/preset-react</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-react -D</span><br></pre></td></tr></table></figure><h4 id="react-hot-loader"><a href="#react-hot-loader" class="headerlink" title="react-hot-loader"></a>react-hot-loader</h4><p>为了实现组件的局部刷新，我们需要安装 <code>react-hot-loader</code> 这个 babel 插件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-hot-loader</span><br></pre></td></tr></table></figure><p>这个插件不需要安装成 <code>devDependencies</code>，它在生产环境下不会被执行并且会确保它占用的体积最小。其实官方正在开发下一代的 react 热更新插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjYwNA==" title="https://github.com/facebook/react/issues/16604">React Fast Refresh<i class="fa fa-external-link"></i></span>，不过目前还不支持 webpack。</p><p>为了看到测试效果，我们安装 react 全家桶并且调整一下 <code>src</code> 文件夹下的默认内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom react-router-dom</span><br><span class="line">yarn add @types/react @types/react-dom @types/react-router-dom -D</span><br></pre></td></tr></table></figure><p><code>react</code> 是框架核心接口，<code>react-dom</code> 负责挂载我们的 react 组件到真实的 DOM 上， <code>react-dom-router</code> 是实现了 <code>react-router</code> 接口的 web 平台的路由库。</p><p>让 <code>react-hot-loader</code> 接管我们的 react 根组件，其实这个 hot 函数就是一个 <strong>hoc</strong> 嘛：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.ts</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; hot &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader/root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">      &lt;h2 className=<span class="string">"title"</span>&gt;react typescript boilerplate&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hot(App);</span><br></pre></td></tr></table></figure><p>在 webpack entry 加入热更新补丁：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> commonConfig: Configuration = &#123;</span><br><span class="line">  entry: [<span class="string">'react-hot-loader/patch'</span>, resolvePath(projectRoot, <span class="string">'./src/index.tsx'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方文档提到如果需要支持 <code>react hooks</code> 的热更新，我们还需要安装 <code>@hot-loader/react-dom</code>，使用它来替换默认的 <code>react-dom</code> 来添加一些额外的热更新特性，为了替换 <code>react-dom</code> 我们需要配置 webpack alias：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.ts</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react-dom'</span>: <span class="string">'@hot-loader/react-dom'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合前面提到 babel 插件，最终修改 <code>babel.config.js</code> 成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> envPreset = [</span><br><span class="line">  <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 只导入需要的 polyfill</span></span><br><span class="line">    useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">    <span class="comment">// 指定 corjs 版本</span></span><br><span class="line">    corejs: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 禁用模块化方案转换</span></span><br><span class="line">    modules: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">api</span>) </span>&#123;</span><br><span class="line">  api.cache(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-typescript'</span>, envPreset],</span><br><span class="line">    plugins: [<span class="string">'@babel/plugin-transform-runtime'</span>],</span><br><span class="line">    env: &#123;</span><br><span class="line">      <span class="comment">// 开发环境配置</span></span><br><span class="line">      development: &#123;</span><br><span class="line">        presets: [[<span class="string">'@babel/preset-react'</span>, &#123; <span class="attr">development</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">        plugins: [<span class="string">'react-hot-loader/babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 生产环境配置</span></span><br><span class="line">      production: &#123;</span><br><span class="line">        presets: [<span class="string">'@babel/preset-react'</span>],</span><br><span class="line">        plugins: [<span class="string">'@babel/plugin-transform-react-constant-elements'</span>, <span class="string">'@babel/plugin-transform-react-inline-elements'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到我们生产环境下还安装了两个插件进行生产环境的优化：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-react-constant-elements @babel/plugin-transform-react-inline-elements -D</span><br></pre></td></tr></table></figure><p><code>@babel/plugin-transform-react-constant-elements</code> 的作用是像下面样将函数组件中的变量提升到函数外来避免每次重新调用函数组件重复声明和没必要的垃圾回收：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Hr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">className</span>=<span class="string">"hr"</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _ref = <span class="xml"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">className</span>=<span class="string">"hr"</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hr = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>@babel/plugin-transform-react-inline-elements</code> 的作用读者可以参考 react 的这个 issue：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjI4" title="https://github.com/facebook/react/issues/3228">Optimizing Compiler: Inline ReactElements<i class="fa fa-external-link"></i></span>。</p><h2 id="生产环境优化"><a href="#生产环境优化" class="headerlink" title="生产环境优化"></a>生产环境优化</h2><h3 id="CSS-拆分"><a href="#CSS-拆分" class="headerlink" title="CSS 拆分"></a>CSS 拆分</h3><p>如果 CSS 是包含在我们打包的 JS bundle 中那会导致最后体积很大，严重情况下访问首页会造成短暂的白屏。拆分 CSS 我们直接使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9taW5pLWNzcy1leHRyYWN0LXBsdWdpbg==" title="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin<i class="fa fa-external-link"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>修改生产环境配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.ts</span></span><br><span class="line"><span class="keyword">import</span> MiniCssExtractPlugin <span class="keyword">from</span> <span class="string">'mini-css-extract-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 文件名中插入文件内容的 hash 值</span></span><br><span class="line">      filename: <span class="string">'css/[name].[contenthash].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'css/[id].[contenthash].css'</span>,</span><br><span class="line">      ignoreOrder: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9taW5pLWNzcy1leHRyYWN0LXBsdWdpbg==" title="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin<i class="fa fa-external-link"></i></span> 还提供了 <code>mini-css-extract-plugin.loader</code>，它不能和 <code>style-loader</code> 共存，所以我们修改 <code>webpack.common.ts</code> 的配置使得开发环境下使用 <code>style-loader</code> 生产环境下使用 <code>mini-css-extract-plugin.loader</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loader <span class="keyword">as</span> MiniCssExtractLoader &#125; <span class="keyword">from</span> <span class="string">'mini-css-extract-plugin'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; __DEV__ &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCssLoaders</span>(<span class="params">importLoaders: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    __DEV__ ? <span class="string">'style-loader'</span> : MiniCssExtractLoader,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">false</span>,</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">        importLoaders,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123; <span class="attr">sourceMap</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><h4 id="JavaScript-压缩"><a href="#JavaScript-压缩" class="headerlink" title="JavaScript 压缩"></a>JavaScript 压缩</h4><p>网上很多教程在讲 webpack 压缩代码的时候都是使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi91Z2xpZnlqcy13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin<i class="fa fa-external-link"></i></span>，其实这个仓库早就放弃维护了，而且它不支持 ES6 语法，webpack 的核心开发者 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V2aWxlYm90dG5hd2k=" title="https://github.com/evilebottnawi">evilebottnawi<i class="fa fa-external-link"></i></span> 都转向维护 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi90ZXJzZXItd2VicGFjay1wbHVnaW4=" title="https://github.com/webpack-contrib/terser-webpack-plugin">terser-webpack-plugin<i class="fa fa-external-link"></i></span> 了。我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi90ZXJzZXItd2VicGFjay1wbHVnaW4=" title="https://github.com/webpack-contrib/terser-webpack-plugin">terser-webpack-plugin<i class="fa fa-external-link"></i></span> 在生产环境对代码进行压缩，并且我们可以利用 webpack4 新增的 <span class="exturl" data-url="aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9ndWlkZXMvdHJlZS1zaGFraW5nLw==" title="https://www.webpackjs.com/guides/tree-shaking/">tree-shaking<i class="fa fa-external-link"></i></span> 去除代码中的死代码，进一步减小 bundle 体积：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add terser-webpack-plugin @types/terser-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>treeshake 需要在 <code>package.json</code> 中配置 <code>sideEffects</code> 字段，详情可以阅读官方文档：<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvdHJlZS1zaGFraW5nLw==" title="https://webpack.js.org/guides/tree-shaking/">Tree Shaking<i class="fa fa-external-link"></i></span>。</p><h4 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h4><p>压缩 CSS 使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05NRlIvb3B0aW1pemUtY3NzLWFzc2V0cy13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/NMFR/optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin<i class="fa fa-external-link"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add optimize-css-assets-webpack-plugin @types/optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>修改 <code>webpack.prod.ts</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TerserPlugin <span class="keyword">from</span> <span class="string">'terser-webpack-plugin'</span>;</span><br><span class="line"><span class="keyword">import</span> OptimizeCSSAssetsPlugin <span class="keyword">from</span> <span class="string">'optimize-css-assets-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// 使用 minimizer 而不是默认的 uglifyJS</span></span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 两个 minimizer：TerserPlugin 和 OptimizeCSSAssetsPlugin</span></span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(&#123; <span class="attr">extractComments</span>: <span class="literal">false</span> &#125;), <span class="keyword">new</span> OptimizeCSSAssetsPlugin()],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="构建分析"><a href="#构建分析" class="headerlink" title="构建分析"></a>构建分析</h3><p>我们添加一些 webpack 插件用来进行构建分析</p><h4 id="时间统计"><a href="#时间统计" class="headerlink" title="时间统计"></a>时间统计</h4><p><img data-src="https://i.loli.net/2020/02/19/c1vdoqsT34WCSHX.png" alt="speed measure"></p><p>我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXBoZW5jb29rZGV2L3NwZWVkLW1lYXN1cmUtd2VicGFjay1wbHVnaW4=" title="https://github.com/stephencookdev/speed-measure-webpack-plugin">speed-measure-webpack-plugin<i class="fa fa-external-link"></i></span> 对打包时间进行统计：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add speed-measure-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>项目进行到这，我们终于碰到第一个没有 TypeScript 类型声明文件的库了，新建 <code>scripts/typings/index.d.ts</code> 文件，因为需要编写的类型很少，<code>index.d.ts</code> 就作为一个全局声明文件，在其中添加 <code>speed-measure-webpack-plugin</code> 的外部模块声明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scripts/typings/index.d.ts</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'speed-measure-webpack-plugin'</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; Configuration, Plugin &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看官方文档，需要哪些选项就声明哪些选项就行</span></span><br><span class="line">  	<span class="comment">// 可以看出 TypeScript 是非常灵活的</span></span><br><span class="line">    interface SpeedMeasurePluginOptions &#123;</span><br><span class="line">        disable: boolean;</span><br><span class="line">        outputFormat: <span class="string">'json'</span> | <span class="string">'human'</span> | <span class="string">'humanVerbose'</span> | <span class="function">(<span class="params">(outputObj: object</span>) =&gt;</span> <span class="keyword">void</span>);</span><br><span class="line">        outputTarget: string | <span class="function">(<span class="params">(outputObj: string</span>) =&gt;</span> <span class="keyword">void</span>);</span><br><span class="line">        pluginNames: object;</span><br><span class="line">        granularLoaderData: boolean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承 Plugin 类, Plugin 类都有 apply 方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SpeedMeasurePlugin</span> <span class="keyword">extends</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(options?: Partial&lt;SpeedMeasurePluginOptions&gt;);</span><br><span class="line">        wrap(webpackConfig: Configuration): Configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export = SpeedMeasurePlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>webpack.prod.ts</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SpeedMeasurePlugin <span class="keyword">from</span> <span class="string">'speed-measure-webpack-plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergedConfig = merge(commonConfig, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin();</span><br><span class="line"><span class="keyword">const</span> prodConfig = smp.wrap(mergedConfig);</span><br></pre></td></tr></table></figure><h4 id="bundle-分析"><a href="#bundle-分析" class="headerlink" title="bundle 分析"></a>bundle 分析</h4><p><img data-src="https://i.loli.net/2020/02/19/Plifd7e9b2WOxsF.png" alt="bundle analyze"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add BundleAnalyzerPlugin @types/BundleAnalyzerPlugin -D</span><br></pre></td></tr></table></figure><p>我们添加一个 npm script 用于带 bundle 分析的构建，因为有些时候我们并不想打开一个浏览器去分析各个模块的大小和占比：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env-shell NODE_ENV=production ts-node --files -P scripts/tsconfig.json scripts/build"</span>,</span><br><span class="line">    <span class="string">"build-analyze"</span>: <span class="string">"cross-env-shell NODE_ENV=production ts-node --files -P scripts/tsconfig.json scripts/build --analyze"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>修改 <code>webpack.prod.ts</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">import</span> &#123; isAnalyze &#125; <span class="keyword">from</span> <span class="string">'../env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isAnalyze) &#123;</span><br><span class="line">    mergedConfig.plugins!.push(<span class="keyword">new</span> BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们想看各个模块在 bundle 中的大小和占比的时候可以运行 <code>npm run build-analyze</code>，将会自动在浏览器中打开上图中的页面。</p><h4 id="准备-gzip-压缩版本"><a href="#准备-gzip-压缩版本" class="headerlink" title="准备 gzip 压缩版本"></a>准备 gzip 压缩版本</h4><p>我们使用官方维护的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9jb21wcmVzc2lvbi13ZWJwYWNrLXBsdWdpbg==" title="https://github.com/webpack-contrib/compression-webpack-plugin">compression-webpack-plugin<i class="fa fa-external-link"></i></span> 来为打包出来的各个文件准备 gzip 压缩版：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add compression-webpack-plugin @types/compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><h4 id="跟踪-gzip-后的资源大小"><a href="#跟踪-gzip-后的资源大小" class="headerlink" title="跟踪 gzip 后的资源大小"></a>跟踪 gzip 后的资源大小</h4><p><img data-src="https://i.loli.net/2020/02/19/Oteqp9js3DPFrCS.png" alt="trace size"></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvc2l6ZS1wbHVnaW4=" title="https://github.com/GoogleChromeLabs/size-plugin">size-plugin<i class="fa fa-external-link"></i></span> 是谷歌出品的一个显示 webpack 各个 chunk gzip 压缩后的体积大小以及相比于上一次的大小变化，上图中红框中的部分显示了我加了一句 log 之后 gizip 体积增加了 11B。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add size-plugin -D</span><br></pre></td></tr></table></figure><p>这个库有没有官方的 types 文件，我们添加 <code>size-plugin</code> 的外部模块声明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scripts/typings/index.d.ts</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'size-plugin'</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; Plugin &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line">    interface SizePluginOptions &#123;</span><br><span class="line">        pattern: string;</span><br><span class="line">        exclude: string;</span><br><span class="line">        filename: string;</span><br><span class="line">        publish: boolean;</span><br><span class="line">        writeFile: boolean;</span><br><span class="line">        stripHash: <span class="built_in">Function</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SizePlugin</span> <span class="keyword">extends</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(options?: Partial&lt;SizePluginOptions&gt;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export = SizePlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.ts</span></span><br><span class="line"><span class="keyword">const</span> mergedConfig = merge(commonConfig, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 不输出文件大小到磁盘</span></span><br><span class="line">    <span class="keyword">new</span> SizePlugin(&#123; <span class="attr">writeFile</span>: <span class="literal">false</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近刚学会一个词 <code>TL; DR</code>，其实就是：</p><blockquote><p>Too long; didn’t read.</p></blockquote><p>其实我自己也是经常这样，哈哈。到这里已经有 1 万多字了，我估计应该没几个人会看到这。整个流程走下来我觉得是还是非常自然的，从开发环境到生产环境，从基本的配置到优化控制台显示，准备 gzip 压缩版本这些锦上添花的步骤。写这篇文章其实大部分的时间都花费在了查阅资料上，每一个插件我都尽量描述好它们的作用，如果有值得注意的地方我也会在代码注释中或者文字描述中提出来。我知道可能这篇文章对于一些基础比较差或者没怎么手动配置过 webpack 的同学压力比较大，很可能看不下去，这是正常的，我以前也是这样，不过我觉得你如果能够咬咬牙坚持读完，尽管很多地方看不懂，你总是会从中学到一些对你有用的东西，或者你也可以收藏下来当自字典来查。这篇文章很多配置并不是和 react+typescript 强耦合的，你加一个 vue-loader 不就可以正常使用 vue 来开发了吗？<strong>更重要的是我希望一些读者可以从中学到探索精神，可怕不代表不可能，实践探索才能掌握真知。</strong></p><p>最后我们加上我们的构建脚本 <code>build.ts</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scripts/build.ts</span></span><br><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> prodConfig <span class="keyword">from</span> <span class="string">'./configs/webpack.prod'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isAnalyze &#125; <span class="keyword">from</span> <span class="string">'./env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(prodConfig);</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function">(<span class="params">error, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prodStatsOpts = &#123;</span><br><span class="line">    preset: <span class="string">'normal'</span>,</span><br><span class="line">    modules: isAnalyze,</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(stats.toString(prodStatsOpts));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/19/ecaJjBtpHIEQoxC.gif" alt="effect"></p><p>我最近一直在忙毕业和找工作的事情，下一篇可能要在一个月后左右了。如果读者对文章中有哪些不理解的地方建议先去看下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">源代码<i class="fa fa-external-link"></i></span>，还有问题的话可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRlL2lzc3Vlcw==" title="https://github.com/tjx666/react-typescript-boilerplate/issues">github issues<i class="fa fa-external-link"></i></span> 或者发布平台的评论区向我提问，如果觉得本文对你有用，不妨赏颗 star 😁。</p><p>下一篇应该会讲述如何集成 <code>ant design</code>，<code>lodash</code> 等流行库并对它们的打包进行优化…</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29tLw==" title="http://www.lyreal666.com/">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
        <tag>webpack</tag>
        <tag>express</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始配置 react + typescript（二）：linters 和 formatter</title>
    <url>/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Alinters-%E5%92%8C-formatter/</url>
    <content><![CDATA[<p>继 <a href="https://lyreal666.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/">从零开始配置 react + typescript（一）：dotfiles</a> 介绍了一些最先配置的 dotfiles，本篇将继续介绍 lint 工具 eslint，stylelint，代码格式化工具 prettier，用 husky + lint-staged 来实现每次 commit 时只 lint 修改过的代码，以及使用 commitlint 来规范化 commit message。</p><p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">react-typescript-boilerplate<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><blockquote><p>Find and fix problems in your JavaScript code</p></blockquote><p><img data-src="https://i.loli.net/2020/02/03/aWBruH69SoGDET5.png" alt="eslint-react-hooks.png"></p><p>其实社区有很多的 lint 工具，例如 eslint, stylelint, tslint, htmllint, markdownlint 等。lint 工具一方面可以帮助维护团队成员保持统一良好的代码风格，而且可以定制自己团队的规则集合，另一面可以帮助我们检测出代码的坏味道，降低 bug 的产生的可能性，提高代码质量。需要指出的是：<strong>lint 工具有一定的格式化能力，但是主要功能不是负责格式化代码，格式化代码应该交给专门的格式化工具。</strong> 我们这个项目就将准备使用 prettier 进行代码格式化。</p><p>因为是打算使用 TypeScript 来编写 react，所以要选择一款支持 TypeScript 的 lint 工具，最流行的支持 TypeScript 的 lint 工具有俩，tslint 和 eslint。去年 2019 年 2 月份 tslint 团队就宣布了废弃 tslint，转而将维护一系列将 TypeScript 集成到 ESLint 的工具。具体可以看这个 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhbGFudGlyL3RzbGludC9pc3N1ZXMvNDUzNA==" title="https://github.com/palantir/tslint/issues/4534">issue<i class="fa fa-external-link"></i></span> 和这篇博客：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3BhbGFudGlyL3RzbGludC1pbi0yMDE5LTFhMTQ0YzIzMTdhOQ==" title="https://medium.com/palantir/tslint-in-2019-1a144c2317a9">TSLint in 2019<i class="fa fa-external-link"></i></span>。</p><p>2020 年我觉得新项目没有任何理由还去选择 tslint，eslint 的 TypeScript 插件已经算是比较成熟了，虽然还是有挺多的 bug，后面会提到一些。</p><p>其实前端绝大多数构建工具都是用 node 编写模块来提供 API，有些也会提供命令行工具，本质上就是解析用户输入调用 node API，然后可以通过配置文件来配置选项和集成插件。</p><p>eslint 也不例外，配置 eslint 建议使用 eslint 命令行工具提供的交互式配置生成器。很多包既可以全局安装，也可以本地安装，我们选择本地安装，因为你没办法确保别人开发这个项目的时候也全局安装了，而且这样还可以保证都是使用同一版本。</p><p>安装 eslint：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -D 参数表示开发依赖</span></span><br><span class="line">yarn add eslint -D</span><br></pre></td></tr></table></figure><p>调用 eslint 自带的配置生成器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure><p>npx 是 npm 5.2 自带的一个命令，<code>x</code> 就是和文件类型描述符的那个 <code>x</code> 一样表示 <code>execute</code> 执行嘛。如果本地安装了就会用本地的 eslint，没安装就去找全局的，全局再没有就在临时目录下载 eslint，用完就删。用起来比 npm scripts 还方便，传参数不用像 npm scripts 一样要在参数前加 <code>--</code>。执行上面的 eslint 初始化命令后会询问你一系列的问题，关于每一个问题的详细说明建议看一下这篇文章 <span class="exturl" data-url="aHR0cHM6Ly9kZXYudG8vZGV2ZGFtbWFrL3NldHRpbmctdXAtZXNsaW50LWluLXlvdXItamF2YXNjcmlwdC1wcm9qZWN0LXdpdGgtdnMtY29kZS0yYW1m" title="https://dev.to/devdammak/setting-up-eslint-in-your-javascript-project-with-vs-code-2amf">Setting up ESLINT in your JavaScript Project with VS Code<i class="fa fa-external-link"></i></span>，这篇文章说的很细。</p><ul><li><p>How would you like to use ESLint?</p><p>我们选择第三条，选择其它几条就不会问我们是否选择 Google，Airbnb 还是 Standard 风格了</p></li><li><p>What type of modules does your project use?</p><p>我们选择 <code>JavaScript modules (import/export)</code>，包括 webpack 配置等 node 脚本我们都将使用 ts 来编写，所以选择 esm</p></li><li><p>Which framework does your project use?</p><p>显然选择 react</p></li><li><p>Does your project use TypeScript?</p><p>这一步一定要选 Y，只有告诉初始化器我们使用 TypeScript，它才会帮助我们配置好 TypeScript 的 ESLint parser，相关的 plugins， 以及其它配置</p></li><li><p>Where does your code run?</p><p>这里我们 browser 和 node 两个都选上，因为我们还要编写一些 node 代码</p></li><li><p>How would you like to define a style for your project?</p><p>我们选第一个 <code>Use a popular style guide</code></p></li><li><p>Which style guide do you want to follow?</p><p>选择 Airbnb（爱彼迎）的代码风格</p></li><li><p>What format do you want your config file to be in?</p><p>我们选择最灵活的配置方式：javascript</p></li><li><p>Would you like to install them now with npm?</p><p>选择 Y，立即安装依赖。虽然我们用的是 yarn，不应该使用 npm 安装依赖，用 npm 安装依赖还会生成对我们没有用 <code>package-lock.json</code>。<code>package.lock.json</code> 和 <code>yarn.lock</code> 一样都是用来锁定依赖版本的。之所以这里选择立即安装依赖是因为你如果不立即安装依赖，后面你想再用 yarn 安装依赖的时还要去查一下安装哪几个依赖，我觉得很麻烦。</p></li></ul><p>安装完之后，把 <code>node_modules</code>, <code>package-lock.json</code>, <code>yarn.lock</code> 都删掉，使用 yarn 重新安装依赖，再升级到最新版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yarn</span><br><span class="line"><span class="comment"># 升级到最新版本</span></span><br><span class="line">yarn upgrade --latest</span><br></pre></td></tr></table></figure><p>通过 eslint 自带的配置生成器我们生成了 <code>.eslintrc.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化后的 .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'plugin:react/recommended'</span>, <span class="string">'airbnb'</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">'readonly'</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">'readonly'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="string">'react'</span>, <span class="string">'@typescript-eslint'</span>],</span><br><span class="line">  rules: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到相对于非 TypeScript 项目，使用 <code>@typescript-eslint/parser</code> 替换掉了默认的 parser，并添加了 <code>@typescript-eslint</code> 插件。</p><p>我们先做以下修改：</p><ul><li><p>查看 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50LWNvbmZpZy1haXJibmI=" title="https://www.npmjs.com/package/eslint-config-airbnb">eslint-config-airbnb<i class="fa fa-external-link"></i></span> 的说明，里面提到，如果要开启 react hooks 检查，需要添加 <code>&quot;extends&quot;: &quot;airbnb/hooks&quot;</code> 到 <code>.eslintrc.js</code></p></li><li><p>修改 <code>parserOptions.ecmaVersion</code> 为 2020，争做新时代的弄潮儿 😂</p></li><li><p>查看 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHR5cGVzY3JpcHQtZXNsaW50L2VzbGludC1wbHVnaW4=" title="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin">@typescript-eslint/eslint-plugin<i class="fa fa-external-link"></i></span> 文档，里面提到我们可以通过添加 <code>extends: &#39;plugin:@typescript-eslint/recommended&#39;</code>来开启它推荐的一些 rules，修改 <code>extends</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line">&#123;</span><br><span class="line">    extends: [<span class="string">'plugin:react/recommended'</span>, <span class="string">'airbnb'</span>, <span class="string">'airbnb/hooks'</span>,<span class="string">'plugin:@typescript-eslint/recommended'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了让 <code>eslint-plugin-import</code> 能够正确解析 <code>ts</code>, <code>tsx</code>, <code>json</code> 后缀名，我们还需指定允许的后缀名，添加 <code>setttings</code> 字段，加入以下配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line">&#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">        <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">            node: &#123;</span><br><span class="line">                <span class="comment">// 指定 eslint-plugin-import 解析的后缀名</span></span><br><span class="line">                extensions: [<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了让 <code>eslint-plugin-import</code> 能够正确解析 <code>tsconfig.json</code> 中的 <code>paths</code> 映射，我们需要安装 <code>eslint-import-resolver-typescript</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add eslint-import-resolver-typescript -D</span><br></pre></td></tr></table></figure><p>修改 <code>settings</code> 字段：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line">&#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">        <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">            typescript: &#123;</span><br><span class="line">                <span class="comment">// 配置 eslint-import-resolver-typescript 读取 tsconfig.json 的路径</span></span><br><span class="line">                <span class="comment">// 目前用不着，先注释掉</span></span><br><span class="line">                <span class="comment">// directory: [resolve('./src/tsconfig.json'), resolve('./scripts/tsconfig.json')],</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在我的使用中我发现，目前 <code>eslint-plugin-import</code> 和 <code>TypeScript</code> 搭配还是存在很多的 bug，其中的一个不能忍的 bug 就是<code>import/extensions</code> 这个规则不能正确处理文件后缀名：</p><p><img data-src="https://i.loli.net/2020/02/02/iRsYKELCtXvyz9k.png" alt="import-extension.png"></p><p>去 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jlbm1vc2hlci9lc2xpbnQtcGx1Z2luLWltcG9ydC9pc3N1ZXM/dXRmOD0lRTIlOUMlOTMmcT1pcyUzQWlzc3VlK2lzJTNBb3BlbitpbXBvcnQlMkZleHRlbnNpb25zK3R5cGVzY3JpcHQ=" title="https://github.com/benmosher/eslint-plugin-import/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+import%2Fextensions+typescript">eslint-plugin-import<i class="fa fa-external-link"></i></span> github issue 搜索关键字 <code>import/extensions typescript</code> 可以搜到很多相关的 issues。目前我采用的解决方案是修改 <code>import/extension</code> 的规则配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'import/extensions'</span>: [</span><br><span class="line">    <span class="string">'2,</span></span><br><span class="line"><span class="string">    '</span>ignorePackages<span class="string">',</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        ts: '</span>never<span class="string">',</span></span><br><span class="line"><span class="string">        tsx: '</span>never<span class="string">',</span></span><br><span class="line"><span class="string">        json: '</span>never<span class="string">',</span></span><br><span class="line"><span class="string">        js: '</span>never<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">],</span></span><br></pre></td></tr></table></figure><p>另外一个要提的 bug 就是这个 issue： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGVzY3JpcHQtZXNsaW50L3R5cGVzY3JpcHQtZXNsaW50L2lzc3Vlcy80MjA=" title="https://github.com/typescript-eslint/typescript-eslint/issues/420">no-useless-constructor: Cannot read property ‘body’ of null<i class="fa fa-external-link"></i></span>，简单来说就是目前在 eslint 搭配 typescript 相关插件时，如果 <code>.d.ts</code> 声明文件中如果使用了 <code>constructor</code> 就会报这个错。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'size-plugin'</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; Plugin &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line">    interface SizePluginOptions &#123;</span><br><span class="line">        writeFile?: boolean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SizePlugin</span> <span class="keyword">extends</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用了 constructor 就报错：no-useless-constructor: Cannot read property 'body' of null</span></span><br><span class="line">        <span class="keyword">constructor</span>(options?: SizePluginOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export = SizePlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前我采用的解决办法时是添加下面两个规则：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">    <span class="string">'no-useless-constructor'</span>: <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">'@typescript-eslint/no-useless-constructor'</span>: <span class="string">'error'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>针对 <code>.d.ts</code> 文件我们还需要要禁用一些规则，我们后续会在 <code>script</code> 文件夹中实现和 webpack 相关的 node 脚本，针对这个文件夹也调整一些规则：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line">&#123;</span><br><span class="line">  overrides: [</span><br><span class="line">        &#123;</span><br><span class="line">            files: [<span class="string">'**/*.d.ts'</span>],</span><br><span class="line">            rules: &#123;</span><br><span class="line">                <span class="string">'import/no-duplicates'</span>: OFF,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            files: [<span class="string">'scripts/**/*.ts'</span>],</span><br><span class="line">            rules: &#123;</span><br><span class="line">                <span class="string">'import/no-extraneous-dependencies'</span>: OFF,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它一些个人习惯的规则调整我就不提了，读者可以直接去看最终的配置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRlL2Jsb2IvbWFzdGVyLy5lc2xpbnRyYy5qcw==" title="https://github.com/tjx666/react-typescript-boilerplate/blob/master/.eslintrc.js">.eslintrc.js<i class="fa fa-external-link"></i></span>。</p><p>目前这个配置还存在一些问题，例如很多 rules 会和 <code>prettier</code> 冲突，后面我们会一一解决这些问题。</p><h2 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h2><blockquote><p>A mighty, modern linter that helps you avoid errors and enforce conventions in your styles</p></blockquote><p><img data-src="https://i.loli.net/2020/02/20/1X387zS5GgclEVo.png" alt="stylelint"></p><p>对于 stylelint，我一般都是直接参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9ibG9iL21hc3Rlci8uc3R5bGVsaW50cmMuanNvbg==" title="https://github.com/ant-design/ant-design/blob/master/.stylelintrc.json">ant design 的 stylint 配置<i class="fa fa-external-link"></i></span>。添加 <code>.stylelintrc.json</code> 到项目根路径，copy 过来简单修改一下，：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .stylelintrc.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"extends"</span>: [<span class="string">"stylelint-config-standard"</span>, <span class="string">"stylelint-config-rational-order"</span>],</span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"stylelint-order"</span>, <span class="string">"stylelint-declaration-block-no-ignored-properties"</span>],</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"comment-empty-line-before"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"declaration-empty-line-before"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"function-name-case"</span>: <span class="string">"lower"</span>,</span><br><span class="line">        <span class="string">"no-descending-specificity"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"no-invalid-double-slash-comments"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ignoreFiles"</span>: [<span class="string">"node_modules/**/*"</span>, <span class="string">"src/assets/**/*"</span>, <span class="string">"dist/**/*"</span>, <span class="string">"**/typings/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我去掉了 <code>stylelint-config-prettier</code> 插件（后面会加上），修改了 <code>function-name-case</code> 规则，最后将 <code>ignoreFiles</code> 选项修改为 <code>[&quot;node_modules/**/*&quot;, &quot;src/assets/**/*&quot;, &quot;dist/**/*&quot;, &quot;**/typings/**/*&quot;]</code>。</p><p><code>src/assets</code> 文件夹准备用来保存一些资源文件，例如第三方的 css 库，并不需要 lint。VSCode 的 stylelint 插件目前有个 bug，默认居然会 lint <code>.d.ts</code> 文件然后报错，所以我也添加了 <code>&quot;**/typings/**/*&quot;</code> 来忽略 <code>.d.ts</code> 文件：</p><p><img data-src="https://i.loli.net/2020/02/20/H1g5SiBMrslOI7Q.png" alt="vscode stylint bug"></p><p>根据上面的配置文件，我们需要安装对应的 npm 包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-declaration-block-no-ignored-properties -D</span><br></pre></td></tr></table></figure><p>和 eslint 一样，会与 prettier 存在冲突。</p><h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><blockquote><p>An opinionated code formatter</p></blockquote><p><code>opinionated</code> 可以理解为 <code>独断专行</code>，<code>自以为是</code>，其实就是说这个格式化器（formatter）不给用户做选择，就按照一套社区共识，最佳实践，最好看的的代码风格来格式化。具体表现就是提供的选项很少，我数了一下总共刚好 20 个选项。</p><p>首先我们得安装 <code>prettier</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add prettier -D</span><br></pre></td></tr></table></figure><p>添加 .<code>prettierrc</code> 到项目根路径：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"trailingComma"</span>: <span class="string">"all"</span>,</span><br><span class="line">    <span class="string">"tabWidth"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"semi"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"endOfLine"</span>: <span class="string">"auto"</span>,</span><br><span class="line">    <span class="string">"printWidth"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"overrides"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"files"</span>: <span class="string">"*.md"</span>,</span><br><span class="line">            <span class="string">"options"</span>: &#123;</span><br><span class="line">                <span class="string">"tabWidth"</span>: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说明下一些选项这样配置的原因：</p><ul><li><p><code>&quot;trailingComma&quot;: &quot;all&quot;</code>，支持在函数参数中也插入逗号</p><p><img data-src="https://i.loli.net/2020/02/03/EXeHDFAjzxTS1mi.png" alt="prettier-trailing-comma.png"></p></li><li><p><code>&quot;semi&quot;: true</code>，个人习惯</p></li><li><p><code>&quot;singleQuote&quot;: true,</code>，个人习惯，少敲一下 shift 难道不好吗？</p></li><li><p><code>&quot;endOfLine&quot;: &quot;auto&quot;</code>，和 <code>editorconfig</code> 一样，按照操作系统默认的换行符来就行了</p></li><li><p><code>&quot;printWidth&quot;: 100</code>，我觉得默认的最大行宽 80 太短了，浪费编辑器空间</p></li><li><p>之所以设置 markdown 文件格式化 <code>&quot;tabWidth&quot;: 2</code>，是目前 prettier 在格式化 markdown 文件时，会在无序列表中插入多余的空格</p><p>正常的无序列表应该格式化成：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>1</span><br><span class="line"><span class="bullet">- </span>2</span><br><span class="line"><span class="bullet">- </span>3</span><br></pre></td></tr></table></figure><p>但是不配置 tabWidth 的话， prettier 会格式化成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   1</span><br><span class="line">-   2</span><br><span class="line">-   3</span><br></pre></td></tr></table></figure><p>巨丑 😤</p></li></ul><h2 id="linters-和-prettier-的冲突"><a href="#linters-和-prettier-的冲突" class="headerlink" title="linters 和 prettier 的冲突"></a>linters 和 prettier 的冲突</h2><p>这部分内容强烈建议先阅读 <code>prettier</code> 官方文档 <span class="exturl" data-url="aHR0cHM6Ly9wcmV0dGllci5pby9kb2NzL2VuL2ludGVncmF0aW5nLXdpdGgtbGludGVycy5odG1s" title="https://prettier.io/docs/en/integrating-with-linters.html">Integrating with Linters<i class="fa fa-external-link"></i></span> 部分，官方文档往往是更新最及时，也是最权威的。</p><p>我们知道 lint 工具是用来检查代码风格的， prettier 是用来格式化代码的。想想看，如果 prettier 设置缩进为 4 个空格，而我们配置的 eslint 是要求缩进为 2 个空格，这肯定会导致我们格式化代码之后，eslint 会报缩进错误。</p><p><img data-src="https://i.loli.net/2020/02/20/Tx3Z1CXS4BLHqmF.png" alt="conflict"></p><p>这部分内容就是为了解决 linters 规则和 prettier 的冲突问题，其实，原理很简单，就是禁用掉掉那些会和 prettier 格式化起冲突的规则。</p><p>安装 eslint 插件 <code>eslint-config-prettier</code>，这个插件会禁用所有会和 prettier 起冲突的规则。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add eslint-config-prettier -D</span><br></pre></td></tr></table></figure><p>添加 <code>&#39;prettier&#39;</code>，<code>&#39;prettier/react&#39;</code>，<code>&#39;prettier/@typescript-eslint&#39;</code> 到<code>extends</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line">&#123;</span><br><span class="line">    extends: [</span><br><span class="line">        <span class="string">'airbnb'</span>,</span><br><span class="line">        <span class="string">'airbnb/hooks'</span>,</span><br><span class="line">        <span class="string">'plugin:eslint-comments/recommended'</span>,</span><br><span class="line">        <span class="string">'plugin:import/typescript'</span>,</span><br><span class="line">        <span class="string">'plugin:react/recommended'</span>,</span><br><span class="line">        <span class="string">'plugin:@typescript-eslint/recommended'</span>,</span><br><span class="line">        <span class="string">'prettier'</span>,</span><br><span class="line">        <span class="comment">// 专门支持了 eslint-plugin-react</span></span><br><span class="line">        <span class="string">'prettier/react'</span>,</span><br><span class="line">        <span class="comment">// 专门支持了 @typescript-eslint/eslint-plugin</span></span><br><span class="line">        <span class="string">'prettier/@typescript-eslint'</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意要把 <code>prettier</code> 放最后面，因为这样才能让 <code>prettier</code> 有机会禁用前面所有的 <code>extends</code> 中配置的会起冲突的规则。</p><p>stylelint 也是一样，先安装插件 <code>stylelint-config-prettier</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add stylelint-config-prettier -D</span><br></pre></td></tr></table></figure><p>再将 <code>&quot;stylelint-config-prettier&quot;</code> 添加到 <code>extends</code> 数组最后面：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .stylelintrc.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"extends"</span>: [<span class="string">"stylelint-config-standard"</span>, <span class="string">"stylelint-config-rational-order"</span>, <span class="string">"stylelint-config-prettier"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><blockquote><p>Run linters on git staged files</p></blockquote><p><img data-src="https://i.loli.net/2020/02/03/XKgBvifDF8Wch7R.png" alt="git-stage.png"></p><p>我们每次提交代码都要对代码先进行 lint 和格式化，确保团队的代码风格统一。为了达到每次 lint 和格式化时只处理我们修改了的代码，也就是保存在 git stage 区（暂存区）的代码。社区比较流行的方案有俩：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F6ei9wcmV0dHktcXVpY2s=" title="https://github.com/azz/pretty-quick">pretty-quick<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29rb25ldC9saW50LXN0YWdlZA==" title="https://github.com/okonet/lint-staged">lint-staged<i class="fa fa-external-link"></i></span></li></ol><p>我们选择使用 <code>lint-staged</code>，因为前者功能单一，只是提供了 prettier 格式化 stage 区代码的功能，没法配 eslint 和 stylelint，只提供了一些命令行参数，不能通过配置文件来配置。lint-satged 配置更灵活，通过它我们可以同时配置 <code>eslint</code>，<code>stylelint</code>，<code>prettier</code>。</p><p>为了达到在我们每次 commit 的时候，都自动 lint 和格式化，我们需要给 git commit 挂个钩子，使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2h1c2t5" title="https://github.com/typicode/husky">husky<i class="fa fa-external-link"></i></span> 可以很轻松的给 git 配置钩子。</p><p>先安装 husky 和 lint-staged：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add husky lint-staged -D</span><br></pre></td></tr></table></figure><p>在 package.json 配置 git commit 时的钩子操作:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"husky"</span>: &#123;</span><br><span class="line">        <span class="string">"hooks"</span>: &#123;</span><br><span class="line">            <span class="comment">// 在执行 git commit 调用 lint-staged 命令，lint-staged 会读取 package.json 中 lint-staged 的配置</span></span><br><span class="line">            <span class="string">"pre-commit"</span>: <span class="string">"lint-staged"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在 package.json 中 <code>&quot;ling-staged&quot;</code> 字段配置 lint-staged：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">        <span class="comment">// 对于 ts,tsx,js 文件调用 eslint</span></span><br><span class="line">        <span class="string">"*.&#123;ts,tsx,js&#125;"</span>: [</span><br><span class="line">            <span class="string">"eslint -c .eslintrc.js"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 对于 scss 文件调用 stylelint</span></span><br><span class="line">        <span class="string">"*.scss"</span>: [</span><br><span class="line">            <span class="string">"stylelint --config .stylelintrc.json"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// prettier 支持很多类型文件的格式化</span></span><br><span class="line">        <span class="string">"*.&#123;ts,tsx,js,json,scss,md&#125;"</span>: [</span><br><span class="line">            <span class="string">"prettier --write"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prettier 的 –write 参数是干嘛用的呢？举个 🌰 来说，命令行调用 <code>prettier a.js</code> 默认只会输出格式化后的内容到控制台，不会修改原文件，加上 <code>--write</code> 才会直接格式化 <code>a.js</code>。需要注意的一点是，可能你们看别人的教程或者一些项目中他们配置 <code>lint-staged</code> 还加了一个 <code>git add</code> 步骤，然后控制台会有警告：</p><blockquote><p>⚠ Some of your tasks use <code>git add</code> command.</p></blockquote><p>原因很简单：<strong>lint-staged 从 V10 版本开始，任何被修改了的原 staged 区的文件都会被自动 git add</strong>，所以我们不需要自己添加 git add 。</p><h2 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h2><blockquote><p><code>commitlint</code> helps your team adhering to a commit convention. By supporting npm-installed configurations it makes sharing of commit conventions easy.</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jb21taXRsaW50LmpzLm9yZy8=" title="https://commitlint.js.org/">commitlint<i class="fa fa-external-link"></i></span> 是一个用来 lint c<strong>ommit message</strong> 的工具。看官网的例子：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/3/1700a62c2b0044e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="commitlint"></p><p>我知道有些人提交代码喜欢直接来三个点 <code>...</code>，这是很不好的习惯，到时候你想版本回退的话就傻眼了，只能看提交的时间了和 diff 了，很不利于项目管理。规范化的编写 commit message 有很多好处，可以方便我们检索提交历史，配合 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbnZlbnRpb25hbC1jaGFuZ2Vsb2cvY29udmVudGlvbmFsLWNoYW5nZWxvZw==" title="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog<i class="fa fa-external-link"></i></span> 直接生成 changelog，关联 github issue 等。</p><p>我们可以通过 <code>husky</code> + <code>commlint</code> 实现在 commit 的时候先检查 commit message 的规范性，如果不符合规范直接终止 commit。</p><p>安装需要的依赖：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @commitlint/cli @commitlint/config-conventional -D</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGNvbW1pdGxpbnQvY29uZmlnLWNvbnZlbnRpb25hbA==" title="https://www.npmjs.com/package/@commitlint/config-conventional">@commitlint/config-conventional<i class="fa fa-external-link"></i></span> 是 commitlint 官方推荐的一个 angular 风格的 commitlint 配置，提供了少量的 lint 规则，类似于 eslint 的 extend。</p><p>它默认支持的提交类型为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="string">"build"</span>, <span class="string">"ci"</span>, <span class="string">"chore"</span>, <span class="string">"docs"</span>, <span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"perf"</span>, <span class="string">"refactor"</span>, <span class="string">"revert"</span>, <span class="string">"style"</span>, <span class="string">"test"</span>]</span><br></pre></td></tr></table></figure><p>添加 commlint 的配置到项目根目录的 <code>.commitlintrc.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .commitlintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      <span class="comment">// 比默认值多了个 deps，表示依赖升级，降级，新增等</span></span><br><span class="line">      [<span class="string">'build'</span>, <span class="string">'ci'</span>, <span class="string">'chore'</span>, <span class="string">'deps'</span>, <span class="string">'docs'</span>, <span class="string">'feat'</span>, <span class="string">'fix'</span>, <span class="string">'perf'</span>, <span class="string">'refactor'</span>, <span class="string">'revert'</span>, <span class="string">'style'</span>, <span class="string">'test'</span>],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加 git <code>commit-msg</code> 钩子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"husky"</span>: &#123;</span><br><span class="line">        <span class="string">"hooks"</span>: &#123;</span><br><span class="line">            <span class="string">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">            <span class="string">"commit-msg"</span>: <span class="string">"commitlint -c .commitlintrc.js -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>commit-msg</code> 钩子的时候，环境变量 <code>HUSKY_GIT_PARAMS</code> 会被临时设置为保存 commit messsge 的文件的路径，然后 <code>commitlint</code> 就会去 lint 这个文件中的 commit message。</p><p>如果你想在命令行中交互式的编辑 commit message，可以了解一下 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbW1pdGl6ZW4vY3otY2xp" title="https://github.com/commitizen/cz-cli">commitizen<i class="fa fa-external-link"></i></span> ，我们这个项目就不配了，主要还是觉得要配置的话就要根据具体的业务去配，我们这个通用目的的模板项目就算了。我看了一下 <code>angular</code> 和 <code>vue-next</code> lint commit message 的做法，它们 commitlint 和 commitizen 俩都没配，只是在 git <code>commit-msg</code> 时调用了下 node 脚本校验 commit message 。</p><p>我们接着再配置自动生成 changelog，本地安装 <code>conventional-changelog-cli</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add conventional-changelog-cli -D</span><br></pre></td></tr></table></figure><p>添加一个 npm script：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过 <code>npm run changelog</code> 生成 angular 风格的 changelog 了，<code>conventional-changelog</code> 会读取提交历史中 fix, feat 等 type 的 commit message 自动生成 changelog。</p><p>我们接着讨论一个使用了 commilint 后如何插入 emoji 的问题，我们知道 commit message 的格式是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整行叫 header</span></span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br><span class="line"></span><br><span class="line">// 举个例子某次提交的 commit message 是：feat(component): add component Navbar</span><br><span class="line">// feat 是 type</span><br><span class="line">// component 是 scope</span><br><span class="line">// 'add component Navbar' 是 subject</span><br><span class="line">// 这里没有 body 和 footer</span><br></pre></td></tr></table></figure><p>我们知道 git emoji 的格式是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:emoji_string:</span><br></pre></td></tr></table></figure><p>如果你使用下面的带 emoji 的 commit message 提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">':bug: fix: xxx'</span></span><br></pre></td></tr></table></figure><p>commitlint 等工具在解析的时候应该是将第一个冒号之前的内容解析为 type，也就是说会把 emoji 左边冒号之前的内容解析为 type，那这样解析的话 type 就是空字符串了，所以使用上面的 commit message 提交会报错说你没有填写 type。</p><p>如果不修改 commilint 的 type 配置是无法通过 commitlint 的，解决办法之一是添加一个 type <code>:bug: fix</code>，但是这样的话 <code>conventional-changelog-cli</code> 不会将 commit mesage 提取到 changelog，它只认 <code>fix: xxx</code> 不认 <code>:bug: fix: xxx</code>。因此，在当前配置下，我们如果要插入 emoji，建议使用下图的方式，虽然我觉得这样不好看，但目前来说是比较折中的方案。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"chore: :memo: improve docs and config json"</span></span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/14/OcsuXR5CMaxlo41.png" alt="commitlint git emoji"></p><h2 id="second-commit"><a href="#second-commit" class="headerlink" title="second commit"></a>second commit</h2><p>添加几个常用用于 lint 的 npm scripts：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"lint"</span>: <span class="string">"yarn run lint-eslint &amp;&amp; yarn run lint-stylelint"</span>,</span><br><span class="line">        <span class="string">"lint-eslint"</span>: <span class="string">"eslint -c .eslintrc.js --ext .ts,.tsx,.js &#123;src,scripts&#125;/**/*.&#123;ts,tsx,js&#125;"</span>,</span><br><span class="line">        <span class="string">"lint-stylelint"</span>: <span class="string">"stylelint --config .stylelintrc.json src/**/*.scss --syntax scss"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我配置 eslint 和 stylelint 的 script 是用 <code>前缀-参数</code> 的形式，有些项目配置带参数的 script 名是用 <code>前缀:参数</code> 的形式，也就是用冒号做分隔符。我觉得那样不好，因为有些工具支持 <code>yarn:scriptName</code> 的形式来执行 npm scripts，例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpbW1vYnJ1bmZlbGR0L2NvbmN1cnJlbnRseQ==" title="https://github.com/kimmobrunfeldt/concurrently">concurrently<i class="fa fa-external-link"></i></span>。</p><p>假设你有多个 npm scripts，分别是：<code>yarn:watch-node</code>，<code>yarn:watch-node</code>，<code>yarn:watch-css</code>，这个工具支持一条命令来并行执行它们：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">concurrently yarn:watch-node yarn:watch-js yarn:watch-css</span><br></pre></td></tr></table></figure><p>那你说如果用冒号来做分隔符，那要写就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concurrently yarn:watch:node yarn:watch:js yarn:watch:css</span><br></pre></td></tr></table></figure><p>看起来就很迷，不了解的人可能还以为后面的冒号也是 <code>concurrently</code> 的参数呢，<strong>所以表示带参数的 npm script 不要用冒号做分隔符</strong>。</p><p>最后再来一发 <code>yarn upgarde --latest</code>，养成每天升级依赖的好习惯，避免以后同时升级很多依赖出了都搞不清楚是哪个依赖升级导致的。不过公司的项目千万别这样搞，容易导致出 bug 连续加班。</p><p>到这里，<strong>从零开始配置 react + typescript</strong> 系列第二篇算是差不多了，再一次提交代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">'build: integrate eslint, stylelint, prettier, lint-staged, commi</span></span><br><span class="line"><span class="string">tlint'</span></span><br><span class="line"><span class="comment"># 上次 push 的时候使用 -u 参数关联了 master 分支和 github 远程仓库，这里就可以直接 push</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>第二篇到此结束，<a href="https://lyreal666.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Awebpack/">第三篇</a>关于 webpack 配置的文章将是四篇中干货最多，估计也是最长的一篇。将介绍使用 <code>TypeScript</code> 来编写 <code>express + webpack devServer 中间件</code> 作为 devServer，集成一些实用和酷炫的 webpack 插件，优化 babel 配置，生产环境打包优化等内容，敬请期待…</p><p>要想了解更多细节，建议直接看源码，项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">react-typescript-boilerplate<i class="fa fa-external-link"></i></span>。如果觉得本文对你有用，不妨赏颗 star 😁。对本文内容有疑问或者有什么改进的地方欢迎通过评论和邮件交流。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29tLw==" title="http://www.lyreal666.com/">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>eslint</tag>
        <tag>stylelint</tag>
        <tag>lint-staged</tag>
        <tag>commitlint</tag>
        <tag>prettier</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始配置 react + typescript（一）：dotfiles</title>
    <url>/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/</url>
    <content><![CDATA[<p>之前我写过一篇文章 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2Q1OTZkNDUxODgyNTY4ODk3ZDg5Yzg=" title="https://juejin.im/post/5cd596d451882568897d89c8">搭建 react + typescript + ant design 开发环境<i class="fa fa-external-link"></i></span>，现在看来很多内容都已经过时了。但是我看到前不久还有读者给我这篇文章点赞，不更新的话总感觉坑了它们，有点过意不去。但是，如果现在让我再去配置那套环境，我肯定不会再像那篇文章那样配置了，毕竟过了这么长一段时间，很多工具都在发展，我的想法也在改变，那么干脆我就再整一篇新的文章，这是我创作这篇文章的动机之一。</p><p>最近一段时间，我写过不少类型的项目，有 <code>chrome 扩展</code>，<code>VSCode 扩展</code>， <code>electron</code> 等，配置开发环境都是裸写的，并没有使用一些 cli 工具或者第三方的项目模板。因此，我踩过不少坑，也总结了不少的经验。所以另一个创作动机就想总结和分享一下我配置开发环境的最佳实践。</p><p>我使用的开发机和编辑器分别是 <code>win10pro-1909</code> 和 <code>VSCode</code>，使用的所有依赖都是最新的，并且文章会不定时更新，确保具有时效性。</p><p>文章将按照开发一个模板项目的时间顺序预计分成四篇来写：</p><ol><li>dotfiles</li><li>linters 和 formatter</li><li>webpack</li><li>第三方库集成和优化</li></ol><p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">react-typescript-boilerplate<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>搭建项目的第一步就是新建项目文件夹，然后初始化为 git 仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建项目文件夹</span></span><br><span class="line">mkdir react-typescript-boilerplate</span><br><span class="line"><span class="comment"># 切换工作路径到项目文件夹</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$_</span></span><br><span class="line"><span class="comment"># 初始化 git 仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>你可以将 <code>react-typescript-boilerplate</code> 替换成任意你需要的项目名，<code>$_</code> 表示上一条命令最后的参数，这里就表示项目文件夹。</p><p>对于<code>dotfiles</code> 这个词， 我的理解是指那些以点 <code>.</code> 开头的配置文件。在我刚开始学习前端框架的时候，看到脚手架生成的一堆 <code>dotfiles</code> 我也是很懵逼，头皮发麻，心想怎么写个项目要这么多配置文件，写个前端项目也太麻烦了。其实<strong>存在即合理</strong>，当我了解了它们的用途之后，就能够理解它们的必要性了，而且配置文件很多从某种程度上也反应了前端构建工具生态的活跃不是。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>建议初始化 git 仓库后第一步就是添加 <code>.gitignore</code>。如果你不添加，那么 VSCode 的版本控制会监控你项目中的所有文件包括 <code>node_modules</code>下的一堆文件，导致 CPU 和内存占用过高等问题，所以最好一开始就配置好 <code>gitignore</code>。配置 <code>gitignore</code> 建议使用 VSCode 的 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWNvZGV6b21iaWVjaC5naXRpZ25vcmU=" title="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore">gitignore<i class="fa fa-external-link"></i></span> 扩展。使用方式很简单：<code>ctrl+shift+p</code> 唤出命令面板，调用 <code>Add gitignore</code> 命令，然后选择不同类型项目的 <code>ignore</code> 配置，可以多次追加。</p><p><img data-src="https://i.loli.net/2020/02/01/hl1P65K79jLcUMb.gif" alt="gitignore.gif"></p><p>我一般添加的项目类型包括：<code>Node</code>, <code>VisualStudioCode</code>, <code>JetBrains</code>, <code>Windows</code>, <code>Linux</code>, <code>macOS</code>，你可以根据自己的需要添加其它的项目类型例如 <code>SublimeText</code>，<code>Vim</code>。虽然我是用 VSCode 做开发，但是考虑到别人开发这个项目的时候可能用的就是 <code>WebStorm</code> 了，所以就添加了和 <code>JetBrains</code> IDE 相关的 <code>ignore</code> 配置。这个扩展的原理是通过拉取开源项目 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=" title="https://github.com/github/gitignore">gitignore<i class="fa fa-external-link"></i></span> 的 <code>gitignore</code> 配置，<strong>需要注意的是我们要删除其中两个配置项 <code>typings/</code> 和 <code>Icon</code></strong>。这两个配置项明显是需要添加到 git 版本控制的，<code>typings</code> 文件夹我们会用来保存 ts 的类型定义文件，<code>icon</code> 文件夹我们一般用来保存图标。</p><h2 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h2><p>通过配置 <code>editorconfig</code>，我们可以让多个开发人员，使用不同的编辑器时，代码格式化风格仍然保持一致。有些 IDE 例如 IDEA 是直接内置了 <code>editorconfig</code> 规范，有些编辑器如 VSCode 则需要安装<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPUVkaXRvckNvbmZpZy5FZGl0b3JDb25maWc=" title="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">对应的插件<i class="fa fa-external-link"></i></span>去支持。</p><p>我们拿 VSCode 和 IDEA 来做个测试，下面这张图是左边是测试文件 <code>index.js</code>，右边是 <code>editorcofig</code> 配置，注意到<strong>我刻意把缩进设置成了 3 个空格</strong>。VSCode 是可以设置它格式化代码时使用的 formatter 的，如果你不设置，那就是用内置的 formatter，也就是：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"[javascript]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "vscode.typescript-language-features"</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/02/01/y4Q9Xmqzv3K7kjs.png" alt="editorconfig-vscode.png"></p><p>在我 <code>alt + shift + f</code> 格式化之后可以看到，VSCode 遵循了 <code>editorconfig</code> 的配置将代码的缩进格式化成了 3 个空格。</p><p>我继续在 IDEA 中打开这个项目后通过 <code>ctrl + alt + l</code> 格式化，意料之中也是格式化成了三个空格，我就不贴图了，和上面一样。</p><p>有人可能会想，<code>prettier</code> 也是格式化工具，为什么同一个项目配置俩格式化工具（后面我们还要配置 <code>prettier</code>）？事实上，可以看到有些著名的开源项目如 react, VSCode 就是两个都用了。其实想想看：到最后代码格式化功能肯定是要交给 <code>prettier</code> 去干的，一般都是用 <code>lint-staged</code>，每次只把修改过的代码格式化。那是否就是说， <code>editorconfig</code> 是没有用的配置呢？</p><p>当然是有用的，本质上 <code>editorconfig</code> 和 <code>prettier</code> 的区别在于：<code>editorconfig</code> 是主动作用于编辑器的，你添加了 <code>.editoronfig</code> 文件，调用 VSCode 的格式化，格式化结果就是 <code>.editorconfig</code> 配置的风格。而 <code>prettier</code> 只是一个命令行工具，需要我们去调用它，它才会格式化代码，它本身是被动的。如果你不配置 <code>editorconfig</code>，那当用户修改了一个文件，调用 VSCode 快捷键手动格式化代码，提交时又被 <code>prettier</code> 格式化一遍，因为 VScode 内置的 formatter 和 <code>prettier</code> 风格不一样，导致我明明手动格式化了，怎么提交后还被修改了。配置 <code>editorconfig</code> ，并且使其和 <code>prettier</code> 的风格保持一致，就可以解决前面提到的多次格式化结果不一样的问题。事实上， react 就是这样干的。</p><p>其实，当用户配置了 <code>prettier</code> 作为 VSCode 的 <code>javascript</code> formatter， <code>editorconfig</code> 配置就没什么用了。</p><p><img data-src="https://i.loli.net/2020/02/01/lrV5nzXkGugMxfj.png" alt="edittorconfig-prettier.png"></p><p>说了那么多，其实配置起来非常简单，建议安装 VSCode 扩展 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPUVkaXRvckNvbmZpZy5FZGl0b3JDb25maWc=" title="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig for VS Code<i class="fa fa-external-link"></i></span>，安装之后可以通过命令 <code>Generate .editorcofig</code> 生成默认的配置，个人建议最后加上一行 <code>end_of_line = unset</code>，让行尾换行符直接遵守操作系统的换行符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 4</span><br><span class="line">charset = utf-8</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br><span class="line">insert_final_newline = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 加上这一行</span></span><br><span class="line">end_of_line = <span class="built_in">unset</span></span><br></pre></td></tr></table></figure><h2 id="nvmrc"><a href="#nvmrc" class="headerlink" title=".nvmrc"></a>.nvmrc</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=" title="https://github.com/nvm-sh/nvm">nvm<i class="fa fa-external-link"></i></span> (node version manager) 是 node 的版本管理工具，在 windows 上使用 nvm 要安装另一个工具 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz" title="https://github.com/coreybutler/nvm-windows">nvm-windows<i class="fa fa-external-link"></i></span>。</p><p><code>.nvmrc</code> 是 nvm 的配置文件，很多工具在判断项目的 node 版本的时候会读取这个配置，例如 travis CI。如果项目根路径有 <code>.nvmrc</code> 的话就不用在 <code>.travis.yml</code> 中指定 node 的版本了。建议平时开发使用最新的 LTS 版本，新版本不但支持的 ES 特性更多，性能一般也有提升，bug 一般也更少。不建议开发项目时选择最新的非 LTS 版，有些包例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbGVrdGl2L25vZGUuYmNyeXB0Lmpz" title="https://github.com/kelektiv/node.bcrypt.js">bcrypt<i class="fa fa-external-link"></i></span> 在最新的非 LTS 版根本就不支持。之前我一个朋友就碰到安装 bcrypt 安装不了的问题，研究到最后发现是因为 bcrypt 只是在 LTS 版本的 node 上测试，并不保证支持非 LTS 版本。</p><p>通过下面的 shell 命令生成 <code>.nvmrc</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version &gt; ./.nvmrc</span><br></pre></td></tr></table></figure><h2 id="npmrc"><a href="#npmrc" class="headerlink" title=".npmrc"></a>.npmrc</h2><p>众所周知，由于不可抗之力，国内无论是访问 github 还是下载 npm 包都是蜗速。对于国内用户而言，首先我们要做的一件事就是将 npm 源设置淘宝源。配置 npm 源建议使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BhbmEvbnJt" title="https://github.com/Pana/nrm">nrm<i class="fa fa-external-link"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装 nrm，</span></span><br><span class="line">yarn global add nrm</span><br><span class="line"><span class="comment"># 或者使用 npm 安装，install 可以简写成 i</span></span><br><span class="line">npm i -g nrm</span><br><span class="line"><span class="comment"># 设置使用淘宝源</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><p>通过 <code>nrm ls</code> 我们还可以看到其它的一些源:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line"></span><br><span class="line">  npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">* taobao ----- https://registry.npm.taobao.org/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure><p>测试一下其中几个常见的源的丢包率，淘宝源一骑绝尘啊：</p><p><img data-src="https://i.loli.net/2020/02/01/bCpAYTVKENDqBmW.png" alt="taobao-cnpm-registry.png"></p><p><code>.npmrc</code> 是给 npm 用的配置文件，当然你如果使用 yarn，yarn 也会遵守 <code>.npmrc</code> 配置，虽然 yarn 有专门的配置文件 <code>.yarnrc</code>。</p><p>我们知道有些 npm 包在安装时是需要下载一些二进制依赖文件，其中有几个坑货像 <code>node-sass</code>，<code>electron</code>，<code>bcrypt</code> 还需要配置代理才能下载。为了让让别人合作开发项目的时候能顺利安装它们，我们可以在 <code>.npmrc</code> 中直接设置它们的镜像地址，添加 node-sass 的镜像地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .npmrc</span></span><br><span class="line">SASS_BINARY_SITE=http://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure><h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><p><img data-src="https://i.loli.net/2020/02/05/Fb7OUkWmYfIiHyX.png" alt="open source license"></p><p>根据你的项目性质，去网站 <span class="exturl" data-url="aHR0cDovL2Nob29zZWFsaWNlbnNlLm9ubGluZS8=" title="http://choosealicense.online/">choose a license<i class="fa fa-external-link"></i></span> 选择一个合适的 license， 复制后粘贴到项目根路径的 <code>LICENSE</code> 或 <code>LICENSE.txt</code> 文件里面，修改一些配置即可。这里我选择宽松的 MIT 协议，修改其中的年份和作者名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) [2020] [YuTengjing]</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>生成 package.json 的时候需要考虑一个问题，你是打算使用 yarn，npm，还是 cnpm？</p><p>最近貌似还发布了 yarn2 ，不过我肯定不会考虑 yarn2 的，先不说有很多 bug ，还不够成熟，社区的接受度还是一个问题，yarn2 和 yarn1 差别很大。</p><p>讲真我觉得 npm 是真的设计的很屎，不知道最开始为什么会设计成安装包默认不会添加到 <code>dependencies</code>，使用缓存这么容易想到的设计还是 yarn 首创的，锁定版本也是抄 yarn 的。</p><p>yarn 用起来舒服多了。但是 yarn 在 windows 经常有 hash 值对不上然后安装不了的 bug，搞得我很烦，看了一下 github 仓库，将近 2000 个 issues。</p><p>最近我重新试用了一下 cnpm，让我意外的是下载速度是真的快，同样的使用淘宝源，cnpm 比 yarn 还要快很多。但是我觉得 cnpm 安装之后，node_modules 看起来很乱，多了很多乱七八槽的依赖。</p><p>因为我有点洁癖，所以 yarn 和 cnpm 我站 yarn。</p><p>package.json 是用来管理 npm 包的配置文件，生成 package.json 最简单的方式就是来一句 <code>yarn init -y</code>，直接就生成一个默认的 package.json。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"react-typescript-boilerplate"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"YuTengjing &lt;ytj2713151713@gmail.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来修改下这个默认的配置：</p><p>因为我们这个项目不打算发布到 npm，所以 private 设置为 true。</p><p>这个 main 入口对于我们这个模板项目来说没什么意义，直接删了。</p><p>修改一下 author 和 repository 的格式就是下面这样了：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"react-typescript-boilerplate"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A boilerplate for react + typescript development"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"author"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"YuTengjing"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/tjx666"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"ytj2713151713@gmail.com"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git@github.com:tjx666/react-typescript-boilerplate.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h2><p>如果你使用的是 VSCode，那么可以添加 VSCode 的项目配置文件 <code>.vscode/settings.json</code>。新建 <code>.vscode</code> 文件夹并在其中创建 <code>settings.json</code>文件。<code>settings.json</code> 虽然后缀名是 <code>.json</code>，其实是 <code>jsonc</code> 格式的文件，<code>jsonc</code> 和 <code>json</code> 文件的区别就在于 <code>jsonc</code> 允许添加注释，<code>jsonc</code> 的这个<code>c</code> 就是 <code>comment</code>（注释）的意思嘛。暂时添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用本地安装的 TypeScript 替代 VSCode 内置的来提供智能提示</span></span><br><span class="line">    <span class="string">"typescript.tsdk"</span>: <span class="string">"./node_modules/typescript/lib"</span>,</span><br><span class="line">    <span class="comment">// 指定哪些文件不参与搜索</span></span><br><span class="line">    <span class="string">"search.exclude"</span>: &#123;</span><br><span class="line">        <span class="string">"**/node_modules"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"dist"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"yarn.lock"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 指定哪些文件不被 VSCode 监听，预防启动 VSCode 时扫描的文件太多，导致 CPU 占用过高</span></span><br><span class="line">    <span class="string">"files.watcherExclude"</span>: &#123;</span><br><span class="line">        <span class="string">"**/.git/objects/**"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"**/.git/subtree-cache/**"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"**/node_modules/*/**"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"dist"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"yarn.lock"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置 VScode 使用 prettier 的 formatter</span></span><br><span class="line">    <span class="string">"[javascript]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[javascriptreact]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[typescript]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[typescriptreact]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[json]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[jsonc]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[html]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[css]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[less]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[scss]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"[markdown]"</span>: &#123;</span><br><span class="line">        <span class="string">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h2><p>我选择使用最流行的开源 CI 工具 travis CI，在 github 上新建完仓库后就可以去 travis CI 官网，先同步 github 账号信息，然后搜索激活新建的仓库。</p><p><img data-src="https://i.loli.net/2020/02/02/iGjOa4fZo2Dpu3q.png" alt="travis-ci.png"></p><p>在项目根目录新建 <code>.travis.yml</code> 文件，加入以下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>非常简单的配置，只是负责自动化测试。因为目前没有测试，我们添加一个 <code>echo</code> 语句到 npm scripts 里面：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo 'skip test...'"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h2><p>README.md 就是项目的说明书，每个文件夹中的 README.md 在 github 上都会被渲染到页面上。我们在项目根目录添加的 README.md 自然就会被渲染到仓库的首页。</p><p>我们添加一些实用的 badges（徽章），例如 travis CI 的 build 状态，dependencies 版本是否过期等 。badge 本质上就是一个链接，只不过文字部分换成了 svg 渲染的图片，我们可以在网站 <span class="exturl" data-url="aHR0cHM6Ly9zaGllbGRzLmlvLw==" title="https://shields.io/">shields.io<i class="fa fa-external-link"></i></span> 上找到各种各样的 badge，平时逛 github 项目的时候看到喜欢的 badge 可用注意收藏一下。</p><p><img data-src="https://i.loli.net/2020/02/02/yw7oPEIR59zC2hr.png" alt="badge-format.png"></p><p>添加以下内容：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># react-typescript-boilerplate</span></span><br><span class="line"></span><br><span class="line">[<span class="string">![Build Status</span>](<span class="link">https://travis-ci.org/tjx666/react-typescript-boilerplate.svg?branch=master</span>)](<span class="link">https://travis-ci.org/tjx666/react-typescript-boilerplate</span>) [<span class="string">![dependencies Status</span>](<span class="link">https://david-dm.org/tjx666/react-typescript-boilerplate/status.svg</span>)](<span class="link">https://david-dm.org/tjx666/react-typescript-boilerplate</span>) [<span class="string">![devDependencies Status</span>](<span class="link">https://david-dm.org/tjx666/react-typescript-boilerplate/dev-status.svg</span>)](<span class="link">https://david-dm.org/tjx666/react-typescript-boilerplate?type=dev</span>) [<span class="string">![Known Vulnerabilities</span>](<span class="link">https://snyk.io/test/github/tjx666/react-typescript-boilerplate/badge.svg?targetFile=package.json</span>)](<span class="link">https://snyk.io/test/github/tjx666/react-typescript-boilerplate?targetFile=package.json</span>) [<span class="string">![Percentage of issues still open</span>](<span class="link">https://isitmaintained.com/badge/open/tjx666/react-typescript-boilerplate.svg</span>)](<span class="link">http://isitmaintained.com/project/tjx666/react-typescript-boilerplate'</span>)</span><br><span class="line"></span><br><span class="line">A boilerplate for react + typescript development</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用 div 的 align 属性将标题，徽章和描述居中。</p><h2 id="first-commit"><a href="#first-commit" class="headerlink" title="first commit"></a>first commit</h2><p>到这感觉就可以做第一次提交了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加远程仓库地址</span></span><br><span class="line">git remote add github git@github.com:tjx666/react-typescript-boilerplate.git</span><br><span class="line"><span class="comment"># 添加所有修改到暂存区</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="comment"># 提交，使用 :tada: emoji</span></span><br><span class="line">git commit -m <span class="string">":tada: first commit, add some dotfiles"</span></span><br><span class="line"><span class="comment"># 推送到 github，关联 github 远程仓库和 master 分支，下次还是 master 分支就可以直接 git push 了</span></span><br><span class="line">git push github -u master</span><br></pre></td></tr></table></figure><p>推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmxvc2N1ZXN0YS9naXRtb2ppLWNsaQ==" title="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli<i class="fa fa-external-link"></i></span> 或者直接使用 VSCode 扩展 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWJlbmphbWluYWRrLmVtb2ppczRnaXQ=" title="https://marketplace.visualstudio.com/items?itemName=benjaminadk.emojis4git">Gitmoji Commit<i class="fa fa-external-link"></i></span> 生成 git emoji。</p><p><a href="https://lyreal666.com/从零开始配置-react-typescript（二）：linters-和-formatter/">下一篇</a> 将继续介绍 linters 和 formatter 的配置。</p><p>要想了解更多细节，建议直接看源码，项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9yZWFjdC10eXBlc2NyaXB0LWJvaWxlcnBsYXRl" title="https://github.com/tjx666/react-typescript-boilerplate">react-typescript-boilerplate<i class="fa fa-external-link"></i></span>。如果觉得本文对你有用，不妨赏颗 star 😁。对本文内容有疑问或者有什么改进的地方欢迎通过 github issues 和发布平台的评论区交流。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29tLw==" title="http://www.lyreal666.com/">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
        <tag>dotfile</tag>
      </tags>
  </entry>
  <entry>
    <title>讲清楚 JavaScript 原型</title>
    <url>/%E8%AE%B2%E6%B8%85%E6%A5%9A-JavaScript-%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>记得以前知乎上看到过一个问题：<a href="https://www.zhihu.com/question/60165921" target="_blank" rel="noopener">面试一个 5 年的前端，却连<strong>原型链</strong>也搞不清楚，满口都是 Vue，React 之类的实现，这样的人该用吗？</a> 。写文章的时候又回去看了下这个问题，300 多个回答，有很多大佬都回答了这个问题，说明这个问题还是挺受关注的。最近几年，随着 ES6 ，TypeScript 及类似的中间语言的流行，我们平时做业务开发很少能接触到原型，基本上都是用 ES6 class 来去更简单的，更直观的实现以前构造器加原型做的事情。</p><p>其实在我看来，我觉得原型链是一个非常重要的基础知识。如果一个人说他 C 语言很精通，但是他汇编不熟，你信吗？我觉得 winter 说的挺简洁到位的：</p><blockquote><p>这又涉及到我之前讲过的面试官技巧，面试，是对一个人的能力系统性评价，搞清楚一个人擅长什么不会什么，所以问知识性问题，为了避免误判，一定要大量问、系统化地问。</p><p>不会原型很能说明问题，至少他在库的设计方面会有极大劣势，而且可能学习习惯上是有问题的，也有可能他根本就不太会 JS 语言，但是这不意味着凭借一个问题就可以判定这个人不能用。</p></blockquote><p>本文包括以下内容：</p><ol><li>JavaScript 原型</li><li>构造器和 <code>prototype</code></li><li>原型链</li><li>原型的用途</li><li>ES6 class 和构造器的关系</li><li>原型继承</li><li>JavaScript 和原型相关语法特性</li><li>原型污染</li></ol><a id="more"></a><h2 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h2><p>原型的英文应该叫做 <code>prototype</code>，任何一个对象都有原型，我们可以通过非标准属性 <code>__proto__</code> 来访问一个对象的原型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纯对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> Student(<span class="string">'xiaoMing'</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// Student 类型实例的原型，默认也是一个空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.__proto__); <span class="comment">// =&gt; Student &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code> 是非标准属性，如果要访问一个对象的原型，建议使用 ES6 新增的 <code>Object.getPrototypeOf()</code> 方法。非标准属性意味着未来可能直接会修改或者移除该属性，说不定以后出了个新标准用 <code>Symbol.proto</code> 作为 key 来访问对象的原型，那这个非标准属性可能就要被移除了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>我们可以直接修改对象的原型，不过被设置的值的类型只能是对象或者 null，其它类型不起作用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'xiaoMing'</span> &#125;;</span><br><span class="line"><span class="comment">// 原型为空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 非对象和 null 不生效</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 设置为 null 返回 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置原型为对象</span></span><br><span class="line">obj.__proto__ = &#123; <span class="attr">constructor</span>: <span class="string">'Function Student'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// =&gt; &#123; constructor: 'Function Student' &#125;</span></span><br></pre></td></tr></table></figure><p>如果被设置的值是不可扩展的，将抛出 TypeError：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> frozenObj = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// Object.isExtensible(obj) 可以判断 obj 是不是可扩展的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(frozenObj)); <span class="comment">// =&gt; false</span></span><br><span class="line">frozenObj.__proto__ = <span class="literal">null</span>; <span class="comment">// =&gt; TypeError: #&lt;Object&gt; is not extensible</span></span><br></pre></td></tr></table></figure><p>原型上的属性都是不可枚举的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.xxx = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure><p>其实 <code>__proto__</code> 是个访问器属性（getter 和 setter 都有），通过 <code>__proto__</code> 访问器我们可以访问对象的<code>[[Prototype]]</code>， 也就是原型。简单实现一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype = &#123;</span><br><span class="line">  <span class="keyword">get</span> __proto__() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> __proto__(newPrototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.isExtensible(newPrototype)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;newPrototype&#125;</span> is not extensible`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newPrototype === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>] = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newPrototype === <span class="string">'object'</span> || <span class="keyword">typeof</span> newPrototype === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">'[[prototype]]'</span>] = newPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其它属性如 toString，hasOwnProperty 等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构造器和-prototype"><a href="#构造器和-prototype" class="headerlink" title="构造器和 prototype"></a>构造器和 prototype</h2><p>构造器的英文就是 <code>constructor</code>，在 JavaScript 中，<strong>函数都可以用作构造器</strong>。构造器我们也可以称之为类，Student 构造器不就可以称之为 Student 类嘛。我们可以通过 new 构造器来构造一个实例。习惯上我们对用作构造器的函数使用大驼峰命名：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> Apple();</span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> Apple); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><strong>任何构造器都有一个 prototype 属性，默认是一个空的纯对象，所有由构造器构造的实例的原型都是指向它。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例的原型即 apple1.__proto__</span></span><br><span class="line"><span class="built_in">console</span>.log(apple1.__proto__ === Apple.prototype); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(apple2.__proto__ === Apple.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>下面的测试结果可以证明构造器的 prototype 属性默认是个空对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Apple.prototype); <span class="comment">// =&gt; Apple &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Apple.prototype)); <span class="comment">// =&gt; []</span></span><br><span class="line"><span class="built_in">console</span>.log(Apple.prototype.__proto__ === &#123;&#125;.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>构造器的 prototype 有一个 constructor 属性，指向构造器本身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Apple.prototype.constructor === Apple); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code> ，<code>prototype</code>，<code>constructor</code>，<code>Apple</code>函数，实例 <code>apple</code> 和原型对象 <code>[[prototype]]</code> 之间的关系：</p><p><img data-src="https://i.loli.net/2020/01/28/Ax7FsXQne84PNkg.png" alt="relationship.png"></p><p>有些人可能会把 <code>__proto__</code> 和 <code>prototype</code> 搞混淆。从翻译的角度来说，它们都可以叫原型，但是其实是完全不同的两个东西。</p><p><code>__proto__</code> 存在于所有的对象上，<code>prototype</code> 存在于所有的函数上，他俩的关系就是：函数的 <code>prototype</code> 是所有使用 new 这个函数构造的实例的 <code>__proto__</code>。函数也是对象，所以函数同时有 <code>__proto__</code> 和<code>prototype</code>。</p><p><strong>注意</strong>：如果我文章中提到了构造器的原型，指的是构造器的 <code>__proto__</code>，而不是构造器的 prototype 属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那么<strong>对象的原型</strong>有什么特点呢？</p><blockquote><p>当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 <code>obj.__proto__</code> 上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 <code>obj.__proto__.__proto__</code>去找，重复以上步骤。一直到访问<strong>纯对象</strong>的原型的原型<code>{}.__proto.__proto__</code>，也就是 null，直接返回 undefined。</p></blockquote><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(stu.notExists); <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure><p>访问 <code>stu.notExists</code> 的整个过程是：</p><ol><li>先看 <code>stu</code> 上是否存在 <code>notExists</code>，不存在，所以看 <code>stu.__proto__</code></li><li><code>stu.__proto__</code> 上也不存在 <code>notExists</code> 属性，再看 <code>stu.__proto__.__proto__</code>，其实就是<strong>纯对象</strong>的原型：<code>{}.__proto__</code></li><li><strong>纯对象</strong>的原型上也不存在 <code>notExists</code> 属性，再往上，到 <code>stu.__proto__.__proto__.__proto__</code> 上去找，其实就是 null</li><li>null 不存在 <code>notExists</code> 属性，返回 undefined</li></ol><p>可能有读者看了上面会有疑问，对象的原型一直查找最后会找到<strong>纯对象</strong>的原型？测试一下就知道了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stu.__proto__.__proto__ === &#123;&#125;.__proto__); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p><strong>纯对象</strong>的原型的原型是 null：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>().__proto__.__proto__); <span class="comment">// =&gt; null</span></span><br></pre></td></tr></table></figure><blockquote><p>各个原型之间构成的链，我们称之为原型链。</p></blockquote><p><img data-src="https://i.loli.net/2020/01/28/pdbT1nxw57lDijS.png" alt="prototypeChain1.png"></p><p>想想看，函数 <code>Student</code> 的原型链应该是怎样的？</p><p><img data-src="https://i.loli.net/2020/01/28/hNn4dPgkiAI2pML.png" alt="functionPrototypeChain.png"></p><h2 id="原型的用途"><a href="#原型的用途" class="headerlink" title="原型的用途"></a>原型的用途</h2><p>在使用构造器定义一个类型的时候，我们一般会将类的方法定义在原型上，和 this 的指向特性简直是绝配。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">workingYears</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.workingYears = workingYears;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能使用箭头函数，箭头函数的 this 在声明的时候就根据上下文确定了</span></span><br><span class="line">Engineer.prototype.built = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我已经工作 <span class="subst">$&#123;<span class="keyword">this</span>.workingYears&#125;</span> 年了, 我的工作是拧螺丝...`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> Engineer(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// this 会正确指向实例，所以 this.workingYears 是 5</span></span><br><span class="line">engineer.built(); <span class="comment">// =&gt; 我已经工作 5 年了, 我的工作是拧螺丝...</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(engineer)); <span class="comment">// =&gt; [ 'workingYears' ]</span></span><br></pre></td></tr></table></figure><p>通过这种方式，所有的实例都可以访问到这个方法，并且这个方法只需要占用一份内存，节省内存，this 的指向还能正确指向类的实例。</p><p>不过这种方式定义的方法都是不可枚举的，毕竟不是自身的属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  func() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// =&gt; [ 'func' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Func.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 空数组，说明 func 不可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(<span class="keyword">new</span> Func())); <span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure><p>如果你就是要定义实例属性的话还是只能通过 <code>this.xxx = xxx</code> 的方式定义实例方法了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">workingYears</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.workingYears = workingYears;</span><br><span class="line">  <span class="keyword">this</span>.built = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我已经工作 <span class="subst">$&#123;<span class="keyword">this</span>.workingYears&#125;</span> 年了, 我的工作是拧螺丝...`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> Engineer(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(engineer)); <span class="comment">// =&gt; [ 'workingYears', 'built' ]</span></span><br></pre></td></tr></table></figure><p>其实 JavaScript 中很多方法都定义在构造器的原型上，例如 Array.prototype.slice，Object.prototype.toString 等。</p><h2 id="ES6-class-和构造器的关系"><a href="#ES6-class-和构造器的关系" class="headerlink" title="ES6 class 和构造器的关系"></a>ES6 class 和构造器的关系</h2><p>很多语言都有拥有面向对象编程范式，例如 java, c#, python 等。ES6 class 让从它们转到 JavaScript 的开发者更容易进行面向对象编程。</p><h3 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h3><p>其实，<strong>ES6 class 就是构造器的语法糖</strong>。 我们来看一下 babel 将 ES6 class 编译成了啥：</p><p>原代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, r) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`画个坐标为 (<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)，半径为 <span class="subst">$&#123;<span class="keyword">this</span>.r&#125;</span> 的圆`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babel + babel-preset-es2015-loose</code> 编译出的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle class 可以理解为就是一个构造器函数</span></span><br><span class="line"><span class="keyword">var</span> Circle = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">x, y, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _proto = Circle.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// class 方法定义在 prototype 上</span></span><br><span class="line">  _proto.draw = <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">'\u753B\u4E2A\u5750\u6807\u4E3A ('</span> +</span><br><span class="line">        <span class="keyword">this</span>.x +</span><br><span class="line">        <span class="string">', '</span> +</span><br><span class="line">        <span class="keyword">this</span>.y +</span><br><span class="line">        <span class="string">')\uFF0C\u534A\u5F84\u4E3A '</span> +</span><br><span class="line">        <span class="keyword">this</span>.r +</span><br><span class="line">        <span class="string">' \u7684\u5706'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一看就明白了， ES6 的 class 就是构造器，class 上的方法定义在构造器的 prototype 上，因此你也可以理解为什么 class 的方法是不可枚举的。</p><h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h3><p>我们再来看一下使用 <code>extends</code> 继承时是怎样转换的。</p><p>原代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, r) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`画个坐标为 (<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)，半径为 <span class="subst">$&#123;<span class="keyword">this</span>.r&#125;</span> 的圆`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babel + babel-preset-es2015-loose</code> 编译出的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inheritsLoose</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass.prototype);</span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line">  subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Circle = (<span class="function"><span class="keyword">function</span>(<span class="params">_Shape</span>) </span>&#123;</span><br><span class="line">  _inheritsLoose(Circle, _Shape);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">x, y, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合继承</span></span><br><span class="line">    _this = _Shape.call(<span class="keyword">this</span>, x, y) || <span class="keyword">this</span>;</span><br><span class="line">    _this.r = r;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _proto = Circle.prototype;</span><br><span class="line"></span><br><span class="line">  _proto.draw = <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">'\u753B\u4E2A\u5750\u6807\u4E3A ('</span> +</span><br><span class="line">        <span class="keyword">this</span>.x +</span><br><span class="line">        <span class="string">', '</span> +</span><br><span class="line">        <span class="keyword">this</span>.y +</span><br><span class="line">        <span class="string">')\uFF0C\u534A\u5F84\u4E3A '</span> +</span><br><span class="line">        <span class="keyword">this</span>.r +</span><br><span class="line">        <span class="string">' \u7684\u5706'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;)(Shape);</span><br></pre></td></tr></table></figure><p>整个 ES6 的 extends 实现的是原型继承 + 组合继承。</p><p>子类构造器中调用了父类构造器并将 this 指向子类实例达到<strong>将父类的实例属性组合到子类实例上</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line">_this = _Shape.call(<span class="keyword">this</span>, x, y) || <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p><code>_inheritsLoose</code> 这个函数就是实现了下一节要讲的原型继承。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>在讲<code>原型继承</code> 之前我们先讲讲<code>继承</code>这个词。我觉得，通俗意义上的<code>继承</code>是说：<strong>如果类 A 继承自类 B，那么 A 的实例继承了 B 的实例属性</strong>。</p><p><code>原型继承</code>的这个<code>继承</code>和通俗意义上的<code>继承</code>还不太一样，它是要：<strong>A 的实例能够继承 B 的原型上的属性</strong>。</p><p>给原型继承下个定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于类 A 和类 B，如果满足 A.prototype.__proto__ === B.prototype，那么 A 原型继承 B</span><br></pre></td></tr></table></figure><p><img data-src="https://i.loli.net/2020/01/28/QitjOq1NJWzYcVl.png" alt="prototypeExtends.png"></p><p>如何实现原型继承呢？最简单的方式就是直接设置 <code>A.prototype === new B()</code>，让 A 的 prototype 是 B 的实例即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.xxx = <span class="string">'污染 A 的原型'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>但是这种方式会导致 B 的实例属性污染 A 的原型。解决办法就是通过一个空的函数桥接一下，空的函数总不会有实例属性污染原型链喽：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.xxx = <span class="string">'污染原型'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Empty</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Empty.prototype = B.prototype;</span><br><span class="line">A.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line"><span class="comment">// 修正 constructor 指向</span></span><br><span class="line">A.prototype.constructor = A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足原型继承的定义</span></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a 也是 B 的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> B); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__ === B.prototype); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>用 Windows 自带的画图软件画的原型链_〆(´Д ｀ )：</p><p><img data-src="https://i.loli.net/2020/01/28/A6YISmxrLuVNfyP.png" alt="prototypeChain.png"></p><p>利用 <code>Object.create</code>，我们可以更简单的实现原型继承，也就是上面的 babel 用到的工具函数 <code>_inheritsLoose</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inheritsLoose</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object.create(prototype) 返回一个以 prototype 为原型的对象</span></span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass.prototype);</span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 我们上面实现的原型继承没有设置这个，但是 class 的继承会设置子类的原型为父类</span></span><br><span class="line">  subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript-和原型相关语法特性"><a href="#JavaScript-和原型相关语法特性" class="headerlink" title="JavaScript 和原型相关语法特性"></a>JavaScript 和原型相关语法特性</h2><p>其实由很多语法特性是和原型有关系的，讲到原型那么我们就再继续讲讲 JavaScrip 语法特性中涉及到原型的一些知识点。</p><h3 id="new-运算符原理"><a href="#new-运算符原理" class="headerlink" title="new 运算符原理"></a>new 运算符原理</h3><p>当我们对函数使用 new 的时候发生了什么。</p><p>使用代码来描述就是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">return</span> value !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * constructor 表示 new 的构造器</span></span><br><span class="line"><span class="comment"> * args 表示传给构造器的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// new 的对象不是函数就抛 TypeError</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">constructor</span> !== 'function') throw new TypeError(`$&#123;<span class="keyword">constructor</span>&#125; is not a <span class="keyword">constructor</span>`);</span><br><span class="line"></span><br><span class="line">  // 创建一个原型为构造器的 prototype 的空对象 target</span><br><span class="line">  const target = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">  // 将构造器的 this 指向上一步创建的空对象，并执行，为了给 this 添加实例属性</span><br><span class="line">  const result = <span class="keyword">constructor</span>.apply(target, args);</span><br><span class="line"></span><br><span class="line">  // 上一步的返回如果是对象就直接返回，否则返回 target</span><br><span class="line">  return isObject(result) ? result : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Computer</span>(<span class="params">brand</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = New(Computer, <span class="string">'Apple'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; Computer &#123; brand: 'Apple' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-运算符原理"><a href="#instanceof-运算符原理" class="headerlink" title="instanceof 运算符原理"></a>instanceof 运算符原理</h3><p>instanceof 用于判断对象是否是某个类的实例，如果 obj instance A，我们就说 obj 是 A 的实例。</p><p>它的原理很简单，一句话概括就是：<strong>obj instanceof 构造器 A，等同于判断 A 的 prototype 是不是 obj 的原型（也可能是二级原型）</strong>。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">obj, constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(<span class="keyword">constructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not an object`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">constructor</span> !== 'function') &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not callable`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要就这一句</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">constructor</span>.prototype.isPrototypeOf(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceOf(a, A)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="原型污染"><a href="#原型污染" class="headerlink" title="原型污染"></a>原型污染</h2><p>在去年 2019 年秋天我还在国内某大厂实习的时候，lodash 爆出了一个严重的安全漏洞：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdGZacTJQWnlsR2ZNak9wOGg4ZWVUdw==" title="https://mp.weixin.qq.com/s/tfZq2PZylGfMjOp8h8eeTw">Lodash 库爆出严重安全漏洞，波及 400 万+项目<i class="fa fa-external-link"></i></span>。这个安全漏洞就是由于<strong>原型污染</strong>导致的。</p><p>原型污染指的是：</p><blockquote><p>攻击者通过某种手段修改 JavaScript 对象的原型</p></blockquote><p>虽然说任何一个原型被污染了都有可能导致问题，但是我们一般提原型污染说的就是 <code>Object.prototype</code> 被污染。</p><h3 id="原型污染的危害"><a href="#原型污染的危害" class="headerlink" title="原型污染的危害"></a>原型污染的危害</h3><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>举个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.hack = <span class="string">'污染原型的属性'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'xiaoHong'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">xiaoHong</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>原型被污染会增加遍历的次数，每次访问对象自身不存在的属性时也要访问下原型上被污染的属性。</p><h4 id="导致意外的逻辑-bug"><a href="#导致意外的逻辑-bug" class="headerlink" title="导致意外的逻辑 bug"></a>导致意外的逻辑 bug</h4><p>看一个具体的 node 安全漏洞案例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;</span><br><span class="line">      merge(a[attr], b[attr]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> admin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, express.static(path.join(__dirname, <span class="string">'views'</span>)));</span><br><span class="line">app.post(<span class="string">'/signup'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.body));</span><br><span class="line">  <span class="keyword">var</span> copybody = clone(body);</span><br><span class="line">  <span class="keyword">if</span> (copybody.name) &#123;</span><br><span class="line">    res.cookie(<span class="string">'name'</span>, copybody.name).json(&#123;</span><br><span class="line">      done: <span class="string">'cookie set'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      error: <span class="string">'cookie not set'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/getFlag'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> аdmin = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.cookies));</span><br><span class="line">  <span class="keyword">if</span> (admin.аdmin == <span class="number">1</span>) &#123;</span><br><span class="line">    res.send(<span class="string">'hackim19&#123;&#125;'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'You are not authorized'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这段代码的漏洞就在于 merge 函数上，我们可以这样攻击：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -vv --header <span class="string">'Content-type: application/json'</span> -d <span class="string">'&#123;"__proto__": &#123;"admin": 1&#125;&#125;'</span> <span class="string">'http://127.0.0.1:4000/signup'</span>;</span><br><span class="line"></span><br><span class="line">curl -vv <span class="string">'http://127.0.0.1/getFlag'</span></span><br></pre></td></tr></table></figure><p>首先请求 <code>/signup</code> 接口，在 NodeJS 服务中，我们调用了有漏洞的 <code>merge</code> 方法，并通过 <code>__proto__</code> 为 <code>Object.prototype</code>（因为 <code>{}.__proto__ === Object.prototype</code>） 添加上一个新的属性 <code>admin</code>，且值为 1。</p><p>再次请求 <code>getFlag</code> 接口，访问了 Object 原型上的<code>admin</code>，条件语句 <code>admin.аdmin == 1</code> 为 <code>true</code>，服务被攻击。</p><h3 id="预防原型污染"><a href="#预防原型污染" class="headerlink" title="预防原型污染"></a>预防原型污染</h3><p>其实原型污染大多发生在调用会修改或者扩展对象属性的函数时，例如 lodash 的 defaults，jquery 的 extend。预防原型污染最主要还是要有防患意识，养成良好的编码习惯。</p><h4 id="Object-create-null"><a href="#Object-create-null" class="headerlink" title="Object.create(null)"></a>Object.create(null)</h4><p>笔者看过一些类库的源码时，经常能看到这种操作，例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ByaW11cy9ldmVudGVtaXR0ZXIzL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyMw==" title="https://github.com/primus/eventemitter3/blob/master/index.js#L23">EventEmitter3<i class="fa fa-external-link"></i></span>。通过 Object.create(null) 创建没有原型的对象，即便你对它设置<code>__proto__</code> 也没有用，因为它的原型一开始就是 null，没有 <code>__proro__</code> 的 <code>setter</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">obj.__proto__ = &#123; <span class="attr">hack</span>: <span class="string">'污染原型的属性'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.__proto__); <span class="comment">// =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h4><p>可以通过 Object.freeze(obj) 冻结对象 obj，被冻结的对象不能被修改属性，成为不可扩展对象。前面也说过不能修改不可扩展对象的原型，会抛 TypeError：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.freeze(&#123; <span class="attr">name</span>: <span class="string">'xiaoHong'</span> &#125;);</span><br><span class="line">obj.xxx = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// =&gt; &#123; name: 'xiaoHong' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">// =&gt; false</span></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>; <span class="comment">// =&gt; TypeError: #&lt;Object&gt; is not extensible</span></span><br></pre></td></tr></table></figure><p>距离我从之前实习的公司离职也有将近三个月了，我记得那时候每次 <code>npm install</code> 都显示检查出几十个依赖漏洞。肯定是好久都没升级才会积累那么多漏洞，反正我是不敢随便升级，之前一个 bug 查了好半天结果是因为 axios 的升级导致的。也不知道到现在有没有升级过 😄。</p><p>参考资料：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDI3MTMzMmYyNjVkYTFiOTM0ZTJkNDg=" title="https://juejin.im/post/5d271332f265da1b934e2d48">最新：Lodash 严重安全漏洞背后你不得不知道的 JavaScript 知识<i class="fa fa-external-link"></i></span></li></ol><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 webpack 构建 chrome 扩展的热更新问题</title>
    <url>/%E4%BD%BF%E7%94%A8-webpack-%E6%9E%84%E5%BB%BA-chrome-%E6%89%A9%E5%B1%95%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前不久我写了一个 chrome 扩展，作为一个前端弄潮儿，我当然想用上各种前端界最 fashion 的开发工具。于是乎，折腾到最后使用了 webpack + TypeScript + react 这么一套技术栈。在 github 上研究了几个模板项目之后，发现大多数都太初级了，功能太简单，而且有一个我觉应当提供的很基础的功能始终没发现有哪个项目支持，也就是当修改了 content script 之后自动 reload 扩展和刷新注入了 content script 的页面这个问题。这个问题如果解决了，你就不需要每次修改了扩展代码还去 chrome 扩展列表页面点下刷新按钮刷新扩展。最后在研究了 webpack 的热更新机制和查阅了 webpack 和 chome 扩展官方文档之后解决了这个问题。在开发完我那个扩展之后，我便将其提取成了一个模板项目 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9hd2Vzb21lLWNocm9tZS1leHRlbnNpb24tYm9pbGVycGxhdGU=" title="https://github.com/tjx666/awesome-chrome-extension-boilerplate">awesome-chrome-extension-boilerplate<i class="fa fa-external-link"></i></span>。</p><p>其实我在使用 webpack + TypeScript + react 这套技术栈开发 chrome 扩展时碰到的问题真不少，如果全拿出来讲没个两万字我估计是写不完。这篇文章主要聊聊 webpack 开发 chrome 扩展的热更新问题，并重点讲解我是如何实现修改了 content script 之后自动 reload 扩展和刷新注入了 content script 的页面的，这也是我那个模板的最大特色，也算是给它的 README 做个补充。</p><p>在阅读文章之前，希望读者对 webpack 和 chrome 扩展开发有基本的了解。本文的主要内容分为：</p><ol><li>我对 chrome 扩展的理解</li><li>各种页面的热更新问题分析</li><li>如何实现修改了 content script 之后自动 reload 扩展和刷新注入了 content script 的页面</li></ol><a id="more"></a><h2 id="我对-chrome-扩展的理解"><a href="#我对-chrome-扩展的理解" class="headerlink" title="我对 chrome 扩展的理解"></a>我对 chrome 扩展的理解</h2><blockquote><p>chrome 扩展其实本质就是一个包含了 manifest.json 文件的文件夹。</p></blockquote><p>其实就像 npm 包一样，包含 package.json 文件的文件夹我们就可以将其视为一个 npm 包。这是从静态的角度也就从文件的角度来说的。</p><p>从扩展运行时来看，chrome 扩展是一个被 chrome 以 <code>chrome://</code> 协议托管的一个静态服务器。当我们访问了 chrome 扩展种的各种资源，其实就是向这个服务器请求了以 <code>chrome://</code> 协议头开始的某个 URL 。例如请求 background 页面其实就是访问了下图中 URL 对应的 HTML 文件：</p><p><img data-src="https://i.loli.net/2020/01/16/yZc17nGaDwLsKqU.png" alt="background"></p><p>扩展中有各种各样的页面，最常见的例如 background 页面，也就是上面这张图中的页面，options 页面也就是选项页面，popup 页面也就是点击图标后的弹窗页面，其实还有很多其它的如书签页面，浏览历史页面，新标签页面等这些页面本质上就是 chrome 扩展中的一个 HTML 文件，当然有些页面你不指定一个自定义的 HTML 文件，chrome 扩展会为你自动生成。既然它们都是由 HTML 文件渲染的，那我们其实可以直接用开发 SPA 的方式来渲染它们。</p><p>SPA 也就是 Single Page Application 单页面应用，现在的前端三大框架其实都是主要用于开发 SPA。通过前端路由，我们可以在一个 HTML 文件上就能像 App 一样访问不同的页面，借助于组件化和框架的能力实现切换不同的页面，并且只会局部刷新，不像以前 jsp，asp 的时候切个页面整个网页都刷新一遍，从性能和体验上都是进步。而熟悉前端路由的人都知道，前端路由也有好多种，最常用也就是 BrowserRouter 和 HashRouter。而 BrowserRouter 它是需要服务器配合的，将所有的 HTML URL 重定向到一个 HTML 文件。我们使用 webpack 开发的时候访问的是 webpack-dev-server，如果你需要使用 BrowserRouter，那么就要修改 webpack 配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，chrome 扩展这个静态服务器我们没法给它设置重定向啊，chrome 本身我们是没法编程的。好在我们还有其它的 Router 方案，使用 HashRouter 就刚刚好，既不会因为 URL 带 hash 值比较丑（因为看不到），又实现了前端路由的功能。</p><p>具体在使用 webpack 将 background，options，popup 页面当作 SPA 开发的时候还会有一些小问题。我们在以开发者模式加载测试的扩展时是要加载磁盘上的文件，所以我们需要配置 webpack devServer 将 bundle 写到磁盘上。除此之外，我们还要配置 CORS 跨域，因为我们访问的 chrome 扩展页面协议时是： <code>chrome://</code> 和我们 devServer <code>HTTP</code> 协议不同，会有跨域问题：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Express &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Compiler &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackDevMiddleware <span class="keyword">from</span> <span class="string">'webpack-dev-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackHotMiddleware <span class="keyword">from</span> <span class="string">'webpack-hot-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> devConfig <span class="keyword">from</span> <span class="string">'../configs/webpack.dev'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (app: Express, compiler: Compiler): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> devMiddlewareOptions: webpackDevMiddleware.Options = &#123;</span><br><span class="line">    publicPath: devConfig!.output!.publicPath!,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="comment">// 配置 cors 跨域</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    lazy: <span class="literal">false</span>,</span><br><span class="line">    stats: <span class="string">'minimal'</span>,</span><br><span class="line">    <span class="comment">// 将 bundle 写到磁盘而不是内存</span></span><br><span class="line">    writeToDisk: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  app.use(webpackDevMiddleware(compiler, devMiddlewareOptions));</span><br><span class="line">  app.use(webpackHotMiddleware(compiler, &#123; path: <span class="string">'/__webpack_HMR__'</span> &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我模板项目中使用到的 devServer 中间件配置，配置 webpack devServer 我总结有四种方式：</p><ol><li>webpack-dev-server 命令行工具</li><li>webpack-dev-server node API</li><li>express + webpack devServer 中间件</li><li>koa + webpack devServer 中间件</li></ol><p>我最终采用的是第三种，不选前两者是因为灵活度不够，因为我需要配置 content scripts 的 webpack entry 不加载 hot reload 脚本以及修改默认拉取热更新补丁的 path，只有通过 webpack devServer 中间件才能配置。又因为 koa 配置 devServer 资料不多，感觉不如 express 成熟稳定，所以不选择第四种。至于为什么需要配置 content scripts 的 webpack entry 不加载 hot reload 脚本以及修改默认拉取热更新补丁的 path，后面会提到。</p><h2 id="各种页面的热更新问题分析"><a href="#各种页面的热更新问题分析" class="headerlink" title="各种页面的热更新问题分析"></a>各种页面的热更新问题分析</h2><p>我们从<code>非content scripts</code> 和 <code>content scripts</code> 这两类脚本来讨论。</p><h3 id="非-content-scripts-的热更新问题"><a href="#非-content-scripts-的热更新问题" class="headerlink" title="非 content scripts 的热更新问题"></a>非 content scripts 的热更新问题</h3><p>前面一部分内容我就讲了，bacngound, options, popup 等页面其实我们可以直接当作普通的 SPA 页面来开发，也就是说可以直接使用 webpack devServer 自身提供的热更新能力。因此我们还可以配置 react 的 hot reload 等。从配置 webpack 的角度来说，相对与普通的前端项目的区别就是配置多入口，跨域，devServer bundle 写到磁盘等，有一定的复杂度。不喜欢折腾的可以考虑直接用我那个模板，而且我那个模板项目还做了各方面的优化。</p><p>前面提到需要修改默认拉取热更新补丁的 path，这是因为：默认情况下，在向 webpack devServer 拉取热更新补丁的 path 是 <code>/__webpack_hmr</code>。</p><p><img data-src="https://i.loli.net/2020/01/16/TCtFHdwlDZ8Uz46.png" alt="webpack-hot-middleware.png"></p><p>如果你不设置 path 为你的 devServser 地址就会出现下面的问题，也就是直接向 chrome 扩展请求热更新数据了：</p><p><img data-src="https://i.loli.net/2020/01/16/MnwvBASWHskTY76.png" alt="webpack-hmr.png"></p><p>所以还是要使用 node API 配置 devServer 的 <code>webpack-hot-middleware</code> 中间件才行：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 部分 webpack entry 配置</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> serverConfig <span class="keyword">from</span> <span class="string">'../configs/server.config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isProd &#125; <span class="keyword">from</span> <span class="string">'./env'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> src = resolve(__dirname, <span class="string">'../../src'</span>);</span><br><span class="line"><span class="keyword">const</span> HMRSSEPath = <span class="built_in">encodeURIComponent</span>(<span class="string">`http://<span class="subst">$&#123;serverConfig.HOST&#125;</span>:<span class="subst">$&#123;serverConfig.PORT&#125;</span>/__webpack_HMR__`</span>);</span><br><span class="line"><span class="comment">// 指定 path 为我们的 devServer 的地址</span></span><br><span class="line"><span class="keyword">const</span> HMRClientScript = <span class="string">`webpack-hot-middleware/client?path=<span class="subst">$&#123;HMRSSEPath&#125;</span>&amp;reload=true`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devEntry: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>[]&gt; = &#123;</span><br><span class="line">  background: [HMRClientScript, resolve(src, <span class="string">'./background/index.ts'</span>)],</span><br><span class="line">  options: [HMRClientScript, <span class="string">'react-hot-loader/patch'</span>, resolve(src, <span class="string">'./options/index.tsx'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="content-scripts-的热更新问题"><a href="#content-scripts-的热更新问题" class="headerlink" title="content scripts 的热更新问题"></a>content scripts 的热更新问题</h3><p>首先我下个结论：<strong>使用 webpack devServer 自带的热更新机制是不可能对 content scripts 起作用的。</strong></p><p>根本原因是因为：由于 chrome 限制了 content script 内无法访问其它 content script，inject script，以及网页本身的 js 脚本内的变量。又因为 webpack devServer 热更新是以 jsonp 的方式来拉取更新补丁的，注入网页的 content scrpit 中包含的实现热更新机制的代码会调用 jsonp 插入页面的热更新补丁中的更新函数，但是由于 chrome 限制，无法调用，也就无法应用热更新补丁。</p><p>查看 wbpack 源码，可以看到 webpack devServer 用的就是 jsonp 进行热更新的：</p><p><img data-src="https://i.loli.net/2020/01/16/argztvoCY7bBTNh.png" alt="webpack-json.png"></p><h2 id="如何实现修改了-content-script-之后自动-reload-扩展和刷新注入了-content-script-的页面"><a href="#如何实现修改了-content-script-之后自动-reload-扩展和刷新注入了-content-script-的页面" class="headerlink" title="如何实现修改了 content script 之后自动 reload 扩展和刷新注入了 content script 的页面"></a>如何实现修改了 content script 之后自动 reload 扩展和刷新注入了 content script 的页面</h2><p>这是本文的重点，其实思路还是很清晰的：</p><ol><li>监听 webpack 修改 content script 事件</li><li>devServer 通过 SSE 主动推送事件给 background</li><li>background 监听推送事件</li><li>调用扩展 API reload 扩展，并发送消息给所有注入了 content script 的页面让它们刷新页面</li></ol><p>下面我们来一步一步实现;</p><h3 id="监听-webpack-修改-content-script-事件"><a href="#监听-webpack-修改-content-script-事件" class="headerlink" title="监听 webpack 修改 content script 事件"></a>监听 webpack 修改 content script 事件</h3><p>查阅 webpack 官方文档发现在使用 node API 的时候可以通过 compiler.hooks.done 这个钩子在 webpack 每次编译结束时执行一些操作。本质上 webpack 插件也是通过给 webpack 各种事件挂钩子来实现各种功能。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugin 包含我们的处理编译完成这一事件的逻辑</span></span><br><span class="line">compiler.hooks.done.tap(<span class="string">'extension-auto-reload-plugin'</span>, plugin);</span><br></pre></td></tr></table></figure><p>监听到编译成功还不够，我们还需要判断是否编译成功，以及通过此次编译的统计信息 stats 拿到此次编译涉及到的 chunks 来判断是否修改了 content scripts 的 chunks：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> contentScriptsChunks = fs.readdirSync(resolve(__dirname, <span class="string">'../../src/contents'</span>));</span><br><span class="line"><span class="keyword">const</span> plugin = <span class="function">(<span class="params">stats: Stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; modules &#125; = stats.toJson(&#123; all: <span class="literal">false</span>, modules: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> shouldReload =</span><br><span class="line">    !stats.hasErrors() &amp;&amp;</span><br><span class="line">    modules &amp;&amp;</span><br><span class="line">    modules.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">    contentScriptsChunks.includes(modules[<span class="number">0</span>].chunks[<span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldReload) &#123;</span><br><span class="line">    <span class="comment">// 发送消息给 background</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-通过-SSE-主动推送事件给-background"><a href="#devServer-通过-SSE-主动推送事件给-background" class="headerlink" title="devServer 通过 SSE 主动推送事件给 background"></a>devServer 通过 SSE 主动推送事件给 background</h3><p>服务器端实时主动推送现在最常用应该是 WebSocket 协议了。不过既然我们已经有了一个 express 服务器，就没必要再启动一个 WebSocket 服务器，利用 SSE（Server Side Event) 的话只需要给 express 加个路由即可。整合上一节内容，我们可以实现一个 express 中间件在监听到修改了 content script 时推送 <code>compiled-successfully</code> 事件给 background：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RequestHandler &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Compiler, Stats &#125; <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> SSEStream <span class="keyword">from</span> <span class="string">'ssestream'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">compiler: Compiler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> extAutoReload: RequestHandler = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'Received a SSE client connection!'</span>));</span><br><span class="line"></span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">const</span> sseStream = <span class="keyword">new</span> SSEStream(req);</span><br><span class="line">    sseStream.pipe(res);</span><br><span class="line">    <span class="keyword">let</span> closed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> contentScriptsModules = fs.readdirSync(resolve(__dirname, <span class="string">'../../src/contents'</span>));</span><br><span class="line">    <span class="keyword">const</span> compileDoneHook = debounce(<span class="function">(<span class="params">stats: Stats</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; modules &#125; = stats.toJson(&#123; all: <span class="literal">false</span>, modules: <span class="literal">true</span> &#125;);</span><br><span class="line">      <span class="keyword">const</span> shouldReload =</span><br><span class="line">        !stats.hasErrors() &amp;&amp;</span><br><span class="line">        modules &amp;&amp;</span><br><span class="line">        modules.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        contentScriptsModules.includes(modules[<span class="number">0</span>].chunks[<span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldReload) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'Send extension reload signal!'</span>));</span><br><span class="line"></span><br><span class="line">        sseStream.write(</span><br><span class="line">          &#123;</span><br><span class="line">            event: <span class="string">'compiled-successfully'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">              action: <span class="string">'reload-extension-and-refresh-current-page'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'UTF-8'</span>,</span><br><span class="line">          error =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">              <span class="built_in">console</span>.error(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开链接后之前的 hook 就不要执行了</span></span><br><span class="line">    <span class="keyword">const</span> plugin = <span class="function">(<span class="params">stats: Stats</span>) =&gt;</span> !closed &amp;&amp; compileDoneHook(stats);</span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'extension-auto-reload-plugin'</span>, plugin);</span><br><span class="line"></span><br><span class="line">    res.on(<span class="string">'close'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      closed = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'SSE connection closed!'</span>));</span><br><span class="line">      sseStream.unpipe(res);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> extAutoReload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="background-监听推送事件"><a href="#background-监听推送事件" class="headerlink" title="background 监听推送事件"></a>background 监听推送事件</h4><p>监听 devServer 推送的 <code>compiled-successfully</code> 事件很简单，使用 SSE 客户端对 express 服务器也就是我们的 devServer 上指定的 SSE 路由建立 SSE 链接即可：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> EventSource(<span class="string">'http://127.0.0.1:3000/__extension_auto_reload__'</span>);</span><br><span class="line"></span><br><span class="line">source.addEventListener(<span class="string">'compiled-successfully'</span>, <span class="function">(<span class="params">event: EventSourceEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> shouldReload = <span class="built_in">JSON</span>.parse(event.data).action === <span class="string">'reload-extension-and-refresh-current-page'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldReload) &#123;</span><br><span class="line">    	<span class="comment">// 刷新扩展等后续步骤</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="调用扩展-API-reload-扩展，并发送消息给所有注入了-content-script-的页面让它们刷新页面"><a href="#调用扩展-API-reload-扩展，并发送消息给所有注入了-content-script-的页面让它们刷新页面" class="headerlink" title="调用扩展 API reload 扩展，并发送消息给所有注入了 content script 的页面让它们刷新页面"></a>调用扩展 API reload 扩展，并发送消息给所有注入了 content script 的页面让它们刷新页面</h4><p>查阅 chrome extension 官方文档，发现官方提供了一个 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3J1bnRpbWUjbWV0aG9kLXJlbG9hZA==" title="https://developer.chrome.com/extensions/runtime#method-reload">reload API<i class="fa fa-external-link"></i></span> 可以在扩展中直接让扩展重载。在 background 的 webpack entry 数组添加 autoReloadPatch.ts ：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProd) &#123;</span><br><span class="line">  entry.background.unshift(resolve(__dirname, <span class="string">'./autoReloadPatch.ts'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autoReloadPatch.ts 这个脚本在监听到服务器推送的指定消息时会先发送刷新页面的消息给所有 tab 页面，在接收到任意一个来自 content script 的响应后再 reload 扩展（如果我们的扩展都没有 content script 就没必要刷新了）。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tiza <span class="keyword">from</span> <span class="string">'tiza'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> EventSource(<span class="string">'http://127.0.0.1:3000/__extension_auto_reload__'</span>);</span><br><span class="line"></span><br><span class="line">source.addEventListener(</span><br><span class="line">  <span class="string">'compiled-successfully'</span>,</span><br><span class="line">  (event: EventSourceEvent) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> shouldReload = <span class="built_in">JSON</span>.parse(event.data).action === <span class="string">'reload-extension-and-refresh-current-page'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldReload) &#123;</span><br><span class="line">      tiza</span><br><span class="line">        .color(<span class="string">'green'</span>)</span><br><span class="line">        .bold()</span><br><span class="line">        .text(<span class="string">`Receive the signal to reload chrome extension as modify the content script!`</span>)</span><br><span class="line">        .info();</span><br><span class="line">      chrome.tabs.query(&#123;&#125;, <span class="function"><span class="params">tabs</span> =&gt;</span> &#123;</span><br><span class="line">        tabs.forEach(<span class="function"><span class="params">tab</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (tab.id) &#123;</span><br><span class="line">            <span class="keyword">let</span> received = <span class="literal">false</span>;</span><br><span class="line">            chrome.tabs.sendMessage(</span><br><span class="line">              tab.id,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">from</span>: <span class="string">'background'</span>,</span><br><span class="line">                action: <span class="string">'refresh-current-page'</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              (&#123; <span class="keyword">from</span>, action &#125;) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!received &amp;&amp; <span class="keyword">from</span> === <span class="string">'content script'</span> &amp;&amp; action === <span class="string">'reload extension'</span>) &#123;</span><br><span class="line">                  source.close();</span><br><span class="line">                  tiza</span><br><span class="line">                    .color(<span class="string">'green'</span>)</span><br><span class="line">                    .bold()</span><br><span class="line">                    .text(<span class="string">`Reload extension`</span>)</span><br><span class="line">                    .info();</span><br><span class="line">                  chrome.runtime.reload();</span><br><span class="line">                  received = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码会发送刷新页面的消息给所有页面，为了实现自动刷新页面，我们必须想办法注入一段监听刷新页面的代码到所有注入了 content script 的页面。我采取的做法是：默认添加一个 content script 也就是 all.ts，这个 all.ts 的代码必须注入到所有的其他 content script 注入到的页面。所以需要我们在配置 manifest.json 的时候注意一下，将 all.ts 的 matches 设置为其它所有 content scripts 的 matches 的父集。例如：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> "content_scripts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"matches"</span>: [<span class="string">"https://github.com/*"</span>],</span><br><span class="line">        <span class="attr">"css"</span>: [<span class="string">"css/all.css"</span>],</span><br><span class="line">        <span class="attr">"js"</span>: [<span class="string">"js/all.js"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"matches"</span>: [<span class="string">"https://github.com/pulls"</span>],</span><br><span class="line">        <span class="attr">"css"</span>: [<span class="string">"css/pulls.css"</span>],</span><br><span class="line">        <span class="attr">"js"</span>: [<span class="string">"js/pulls.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>all.ts 中的代码很简单，就是监听 background 发送的刷新页面的消息刷新当前页面：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tiza <span class="keyword">from</span> <span class="string">'tiza'</span>;</span><br><span class="line"></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function">(<span class="params">request, sender, sendResp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldRefresh = request.from === <span class="string">'background'</span> &amp;&amp; request.action === <span class="string">'refresh-current-page'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldRefresh) &#123;</span><br><span class="line">    tiza</span><br><span class="line">      .color(<span class="string">'green'</span>)</span><br><span class="line">      .bold()</span><br><span class="line">      .text(<span class="string">'Receive signal to refresh current page as modify the content script!'</span>)</span><br><span class="line">      .info();</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.location.reload();</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">    sendResp(&#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'content script'</span>,</span><br><span class="line">      action: <span class="string">'reload extension'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我本人平时很喜欢收集各种实用的扩展，也看过不少扩展的源码。发现其实它们大多是还是使用最原始的开发方式。没有模块化，很容易导致后期维护性非常差，而且还不能方便得调用 npm 包。人生苦短，直接用轮子不好吗？当然其实我是知道有一些工具例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hwbC9jcngtaG90cmVsb2Fk" title="https://github.com/xpl/crx-hotreload">crx-hotreload<i class="fa fa-external-link"></i></span> 可以实现自动刷新扩展，不过相比于我的模板来说功能上太简陋了。</p><p>实际上使用 webpack + react + TypeScript 开发 chrome 扩展，你可能还会遇到各种问题。这个时候不妨打开我的这个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9hd2Vzb21lLWNocm9tZS1leHRlbnNpb24tYm9pbGVycGxhdGU=" title="https://github.com/tjx666/awesome-chrome-extension-boilerplate">模板项目<i class="fa fa-external-link"></i></span>，去看看我是怎么配置项目去解决这些问题的。其实我学习编程从来就没人带过，都是靠自己慢慢摸索。我碰到问题也经常去 github 去搜索技术栈类似的项目，直接分析源码来找到解决办法。或者你也可以在评论区提问，一般来说我都会积极回复。如果本文内容对你有所帮助或者觉得这个模板项目可能用得上，请不要吝啬你的 star 😂。</p><p>最后，快过年了，祝大家新年快乐，2020 事业更上一层楼。</p><p>本文为原创内容，首发于<a href="https://lyreal666.com/">个人博客</a>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>webpack</tag>
        <tag>express</tag>
        <tag>chrome extension</tag>
      </tags>
  </entry>
  <entry>
    <title>全面总结 JavaScript 类型相关知识点</title>
    <url>/%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93-JavaScript-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>相信到了年底，不少前端都准备找工作跳槽了。而作为春招大军的一员，估计很多准备春招的应届生和我一样这个年过得很焦虑。JavaScript 类型是前端面试中考察 JavaScript 基础的常考知识点，经常性第一个问题就是 JavaScript 中有哪些类型。</p><p>笔者今年从春招实习到秋招经历了挺多的面试，也总结了一些规律：一般来讲第一轮面试往往就是考察基础，就算你简历很牛逼那也得走个流程啊。而考察基础一般就按照 HTML，CSS，JavaScript，计算机网络，常见的 web 安全，后端知识如数据库，鉴权，再就是最后来两道算法题或智力题或数学题。</p><p>最近几个月我都很少像以前那样一天到晚刷掘金和知乎的文章，基本上就是在开源项目中实战学习，我觉得刚入门前端的人确实需要多看一些优质的博客。<strong>刚入门更需要广度，随后是广度和深度并行，最后才是深度</strong>。其实说人话就是：刚开始入门时因为没怎么写过项目，懂得太少，所以需要多看，被动吸收。到后来有一定广度了，你会发现其实你在写一个项目的时候往往碰到的问题就是因为你的深度不够，这个时候你会更注重深度。最后当你广度慢慢到了一定程度后，由于网络上 99% 的文章都是小白文，你看了标题之后就大概闻的出文章是啥内容，看了对你也没啥用，这个时候你更因该把时间花在一个小的领域，注重深度，深度才是最能体现一个程序员<strong>技术价值</strong>的地方。</p><p>前面唠叨了一堆废话，下面正式开始本文内容。本文内容主要分两部分：</p><ol><li>总结 JavaScript 中各种类型一些值得注意的地方，小技巧和个人心得</li><li>JavaScript 如何进行类型判断</li></ol><a id="more"></a><h2 id="JavaScript-中的各种类型"><a href="#JavaScript-中的各种类型" class="headerlink" title="JavaScript 中的各种类型"></a>JavaScript 中的各种类型</h2><p>JavaScript 中类型主要分两大类：<strong>基本类型</strong> 和 <strong>对象类型</strong>。</p><p>基本类型又分 string，number，boolean，undefined，null，symbol，bigInt 七种，ES 以前只有前 5 种基本类型， ES6 往后新增了 symbol 和 bigInt。</p><p>对象类型又叫引用类型，除了基本类型就是对象类型，纯对象，标准对象实例，函数等都是对象类型。</p><p>前面说了那么多种类型，那么它们各自有什么特点呢？</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>在 js 里面表示一个字符串字面量有三种方式，单引号，双引号，或者反引号，反引号表示法又叫模板字符串，是 ES6 的新语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'使用单引号表示字符串'</span>;</span><br><span class="line"><span class="comment">// prettier-ignore</span></span><br><span class="line"><span class="string">"使用双引号表示字符串"</span>;;</span><br><span class="line"><span class="string">`使用模板字符串表示字符串`</span>;</span><br></pre></td></tr></table></figure><p>如果你要在字符串里面插入单引号或者双引号可以使用反引号：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`I'm a programer, "_"!`</span>;</span><br><span class="line"><span class="comment">// prettier-ignore</span></span><br><span class="line"><span class="string">'单引号字符串可以插入反引号`'</span>;</span><br></pre></td></tr></table></figure><p>如果你和我一样喜欢用单引号表示字符串，你会发现，基本上没有什么场景需要使用双引号，使用双引号的时候例如要在字符串中插单引号那可以使用模板字符串代替。</p><p>使用模板字符串有一些要注意的地方，一个是两个反引号内任意字符串都有效，下面的字符串输出的是 4，最前面一个空格，a，换行符，最后的空格，所以总共长度为 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prettier-ignore</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">` a</span></span><br><span class="line"><span class="string"> `</span>.length); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure><p>另一个问题是当模板字符串插入对象时并不会被转换成 JSON 字符串，下面两条语句输出的结果是不一样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">author</span>: <span class="string">'YuTengjing'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// =&gt; &#123; author: 'YuTengjing' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>); <span class="comment">// =&gt; [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该使用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(obj)&#125;</span>`</span>); <span class="comment">// =&gt; &#123;"author":"YuTengjing"&#125;</span></span><br></pre></td></tr></table></figure><p>模板字符串前面还可以带标签，例如使用 String.row 来获取原始字符串：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`aaa\n\\`</span>); <span class="comment">// =&gt; aaa\n\\</span></span><br></pre></td></tr></table></figure><p>带标签的模板字符串本质上就是函数调用，看 MDN 上的一个例子就懂了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTag</span>(<span class="params">strings, personExp, ageExp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// "that "</span></span><br><span class="line">  <span class="keyword">var</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// " is a "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// There is technically a string after</span></span><br><span class="line">  <span class="comment">// the final expression (in our example),</span></span><br><span class="line">  <span class="comment">// but it is empty (""), so disregard.</span></span><br><span class="line">  <span class="comment">// var str2 = strings[2];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ageStr;</span><br><span class="line">  <span class="keyword">if</span> (ageExp &gt; <span class="number">99</span>) &#123;</span><br><span class="line">    ageStr = <span class="string">'centenarian'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ageStr = <span class="string">'youngster'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str0 + personExp + str1 + ageStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output = myTag<span class="string">`that <span class="subst">$&#123;person&#125;</span> is a <span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br><span class="line"><span class="comment">// that Mike is a youngster</span></span><br></pre></td></tr></table></figure><p>其实有一些开源的模板引擎就利用到了标签模板字符串的，例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nob29qcy9oeXBlcng=" title="https://github.com/choojs/hyperx">hyperx<i class="fa fa-external-link"></i></span>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vdom = <span class="built_in">require</span>(<span class="string">'virtual-dom'</span>);</span><br><span class="line"><span class="keyword">var</span> hyperx = <span class="built_in">require</span>(<span class="string">'hyperx'</span>);</span><br><span class="line"><span class="keyword">var</span> hx = hyperx(vdom.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">var</span> wow = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> tree = hx<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1 y="ab<span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>cd"&gt;hello <span class="subst">$&#123;title&#125;</span>!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;hx<span class="string">`&lt;i&gt;cool&lt;/i&gt;`</span>&#125;</span></span></span><br><span class="line"><span class="string">  wow</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;wow.map(<span class="keyword">function</span>(w, i) &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="keyword">return</span> hx<span class="string">`&lt;b&gt;<span class="subst">$&#123;w&#125;</span>&lt;/b&gt;\n`</span>;</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>)&#125;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(vdom.create(tree).toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">&lt;div&gt;</span></span><br><span class="line"><span class="comment">  &lt;h1 y="ab3cd"&gt;hello world!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">  &lt;i&gt;cool&lt;/i&gt;</span></span><br><span class="line"><span class="comment">  wow</span></span><br><span class="line"><span class="comment">  &lt;b&gt;1&lt;/b&gt;&lt;b&gt;2&lt;/b&gt;&lt;b&gt;3&lt;/b&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>模板字符串说了这么多，那么什么时候应该使用模板字符串什么时候使用单引号呢？其实总结一下就是以下情况使用模板字符串：</p><ol><li>需要拼接表达式</li><li>写多行字符串字面量</li><li>需要在字符串中插入单引号和双引号的时候</li></ol><p>其它情况使用单引号即可。</p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>之前和一个同学聊前端的时候，我考了下他 NaN 是什么类型，它居然跟我说不知道…</p><p>NaN 其实属于 number 类型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">// =&gt; number</span></span><br></pre></td></tr></table></figure><p>JavaScript 中没有整数和小数之分，统一叫做 number 类型，所以 <code>5 / 2</code> 不会像很多其它语言一样等于 2。另外 JavaScript 的数字类型是遵循 IEEE（跟我一起读：I triple E）754 64 位浮点标准的，因此它也有浮点数精度问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>对于精度问题我们一般简单处理就是判断误差范围是否小于精度要求：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// =&gt; 0.30000000000000004</span></span><br><span class="line"><span class="comment">// 精度要求误差小于1亿分之一</span></span><br><span class="line"><span class="keyword">const</span> isEqual = result - <span class="number">0.3</span> &lt; <span class="number">1e-8</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isEqual); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>如果频繁处理精度问题或者要求精度要求比较高这个时候就要考虑使用第三方库如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanM=" title="https://github.com/josdejong/mathjs">math.js<i class="fa fa-external-link"></i></span> 或者可以使用 bigInt。</p><p>面试常考下面这个问题：</p><h4 id="如何判断一个数是不是-NaN？可不可以用等于号判断？"><a href="#如何判断一个数是不是-NaN？可不可以用等于号判断？" class="headerlink" title="如何判断一个数是不是 NaN？可不可以用等于号判断？"></a>如何判断一个数是不是 NaN？可不可以用等于号判断？</h4><p>其实面试官问你可不可以就是告诉你不可以，面试黑话之一ㄟ( ▔, ▔ )ㄏ。</p><p>使用等号判断是不行滴：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">1</span> / <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(value === <span class="literal">NaN</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>判断一个数是不是 NaN，一般来说用 isNaN 即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'123'</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'aaa'</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>注意最后这个判断，这个结果其实有点反直觉的：’aaa’ 并不是 NaN，应该返回 false 啊。其实 isNaN 也就是 window.isNaN 在判断传入的值是不是 NaN 是会先将其转换成数字，再判断结果是不是 NaN，也就是说 isNaN(‘aaa’) 等价于 isNaN(Number(‘aaa’));</p><p>除了使用 window.isNaN，ES6 在数字类型构造函数 Number 上新增了一个方法 Number.isNaN，它和 window.isNaN 的区别在于： Number.isNaN 只有在传递的值就是 NaN 时才返回 true，不会先转换成数字再比较，也就是说这个 API 就是用来计算一个值是不是就是 NaN。拿一个非数字符串一比较区别就很明显了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">'aaa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(value)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> transformedNumber = <span class="built_in">Number</span>(value);</span><br><span class="line"><span class="comment">// 转换后就等于 NaN 了</span></span><br><span class="line"><span class="built_in">console</span>.log(transformedNumber); <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(transformedNumber)); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有 value 就是 NaN 才会返回 true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(value)); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h4><p>取整是平时开发时经常会碰到的问题之一，其实 js 里面取整方法有很多，标准对象 Math 就自带了一堆取整函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">2.6</span>)); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">6.1</span>)); <span class="comment">// =&gt; 7</span></span><br><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">0.4</span>)); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">0.5</span>)); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// 纯粹的取整，不要小数部分</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">0.6</span>)); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">0.4</span>)); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-0.8</span>)); <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>因为 JavaScript 这门语言非常奇葩和灵活，所以常常能看到各种闻所未闻的奇淫技巧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1.5</span> &gt;&gt; <span class="number">0</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.5</span> &gt;&gt;&gt; <span class="number">0</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.5</span> &lt;&lt; <span class="number">0</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.5</span> ^ <span class="number">0</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.5</span> | <span class="number">0</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">1.5</span>); <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>其实还是不建议大家使用上面的这些技巧，主要还是可读性不好，表达式一复杂几天后再看代码一眼懵逼。不过事实情况是大家开会时说不能写这些乱七八糟的骚操作，但是私底下都偷偷的用….</p><p>我用的比较多的还是 <code>~~</code> 和 <code>|</code> 来取整，根据你表达式的执行顺序和它们的优先级合理选择：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~~ 适合立即取整</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">1.4</span>);</span><br><span class="line"><span class="comment">// | 优先级比较低，如果你取整之前有表达式建议使用这种方式</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1.4</span> + <span class="number">2.8</span>) | <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看一下 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpc2lvbm1lZGlhL3N1cGVyYWdlbnQ=" title="https://github.com/visionmedia/superagent">superagent<i class="fa fa-external-link"></i></span> 这个著名的请求库如何处理 status 和一些标记的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = (status / <span class="number">100</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// status / class</span></span><br><span class="line">res.status = status;</span><br><span class="line">res.statusType = type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basics</span></span><br><span class="line">res.info = <span class="number">1</span> == type;</span><br><span class="line">res.ok = <span class="number">2</span> == type;</span><br><span class="line">res.clientError = <span class="number">4</span> == type;</span><br><span class="line">res.serverError = <span class="number">5</span> == type;</span><br><span class="line">res.error = <span class="number">4</span> == type || <span class="number">5</span> == type;</span><br></pre></td></tr></table></figure><h4 id="千分位问题"><a href="#千分位问题" class="headerlink" title="千分位问题"></a>千分位问题</h4><h5 id="使用-Number-prototypo-toLocaleSctring"><a href="#使用-Number-prototypo-toLocaleSctring" class="headerlink" title="使用 Number.prototypo.toLocaleSctring"></a>使用 Number.prototypo.toLocaleSctring</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">123456.123456</span>).toLocaleString()); <span class="comment">// =&gt; 123,456.123</span></span><br></pre></td></tr></table></figure><h5 id="使用国际化-API"><a href="#使用国际化-API" class="headerlink" title="使用国际化 API"></a>使用国际化 API</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">console.log(<span class="keyword">new</span> Intl.NumberFormat(<span class="string">'en-US'</span>).format(<span class="number">123456.123456</span>)); <span class="comment">// =&gt; 123,456.123</span></span><br></pre></td></tr></table></figure><h5 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先行断言</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatRegExp1</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/(?=(\B\d&#123;3&#125;)+\.)/g</span>;</span><br><span class="line">  <span class="keyword">return</span> number</span><br><span class="line">    .toFixed(<span class="number">2</span>)</span><br><span class="line">    .toString()</span><br><span class="line">    .replace(pattern, <span class="string">','</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表示不等于-1"><a href="#表示不等于-1" class="headerlink" title="表示不等于 -1"></a>表示不等于 -1</h4><p>在 koa 的源码里面有这么个函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Check if the request is idempotent.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> idempotent() &#123;</span><br><span class="line">    <span class="keyword">const</span> methods = [<span class="string">'GET'</span>, <span class="string">'HEAD'</span>, <span class="string">'PUT'</span>, <span class="string">'DELETE'</span>, <span class="string">'OPTIONS'</span>, <span class="string">'TRACE'</span>];</span><br><span class="line">    <span class="keyword">return</span> !!~methods.indexOf(<span class="keyword">this</span>.method);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>搞懂这个判断幂等性的函数之前我们先来研究下 ~num 也就是位非操作符有什么规律：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~<span class="number">2</span>); <span class="comment">// -3</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">1</span>); <span class="comment">// =&gt; -2</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">0</span>); <span class="comment">// =&gt; -1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">-1</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">-2</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">-3</span>); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>看完上面的测试我们发现规律就是： 对于 ~num，如果 num 时正整数，结果就是等于 -(num + 1)，也就是把加一后的结果取负。如果是负整数，结果就是 num + 1，也就是加一。并且只有当 num 等于 -1， ~num 结果等于 0。 这是存粹从计算的角度发现的规律。</p><p>现在我们尝试把它们的结果转换成 boolean 类型再来康康：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">1</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">0</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// ~1 取 boolean 为 false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">-1</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">-2</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(~<span class="number">-3</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>发现了没，因为只有当 num 等于 -1 的时候， ~num 的值才等于 0，而对于 Boolean(value) 函数而言，只有 value 是 0 才返回 false，其它值即便是负数也返回 true。所以我们可以通过 ~num 表示 num 不等于-1。</p><p>至于前面的 <code>!!</code> 其实就是两次 boolean 取反也就是取 boolean 值，等同于 Boolean(~methods.indexOf(this.method))。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔类型只有两个值 true/false。JavaScript 的类型转换充分体现 JavaScript <code>灵活性</code>（艹蛋），虽然 js 底层可能做了很多层转换，但是对于我们平时的开发而言，不需要去了解的那么精细，了解其大致转换规律即可。举个例子来说：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == []; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>看起来很简单的一个非严格相等比较，其实要获得最终结果是要经历很多步：</p><ol><li>因为和 number 比较，需要将 [] 转换成原始值，调用 [].valueOf(), 返回 []，不是原始值</li><li>尝试使用 [].toString() 获取原始值，返回空字符串 <code>&#39;&#39;</code>，此时，变成 number 类型和 string 类型比较</li><li>将 <code>&#39;&#39;</code> 转换成 number 类型，Number(‘’) 返回 0</li><li>最后 0 和 0 比较相等</li></ol><p>其实平时不用像上面那样一步一步判断，非数字类型和数字类型比较基本上就是将非数字类型转换成数字后再比较，中间步骤不用去想，用 Number([]) 转换一下，结果返回 0，比较一下不就是了。</p><p>下面来看看其它类型转换成 boolean 类型是上面结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">-1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">' '</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在考虑转换成 boolean 类型时不需要去考虑内部的每一步转换，只要记住一个规律即可：那些消极的值一般会转换成 false，积极的值一般转换成 true, 对象一定会转换成 true，负数也会转换成 true。</p><blockquote><p>如果一个值在转换成 boolean 类型时值为 false，那么我们称这个值是 <strong>falsy</strong> 的。</p></blockquote><p>既然聊 boolean 类型，那么顺便说说 JavaScript 中的相等性判断。</p><h4 id="相等性判断"><a href="#相等性判断" class="headerlink" title="相等性判断"></a>相等性判断</h4><p>之前面试的时候碰到过这样一道题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">666</span> == <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">666</span>));</span><br></pre></td></tr></table></figure><p>这道题的结果是 true，比较过程其实是：</p><ol><li>右侧是 number 对象，数字类型和对象类型比较先把对象转成数字，调用 valueOf 方法，返回 666</li><li>666 和 666 相等</li></ol><p>其实在 js 里相等性判断其实有三种不同的值比较操作：</p><ul><li>严格相等 (“triple equals” 或 “identity”)，使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0NvbXBhcmlzb25fT3BlcmF0b3JzI0lkZW50aXR5" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity">===<i class="fa fa-external-link"></i></span> ,</li><li>宽松相等 (“double equals”) ，使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0NvbXBhcmlzb25fT3BlcmF0b3JzI0VxdWFsaXR5" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality">==<i class="fa fa-external-link"></i></span></li><li>以及 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"><code>Object.is</code></a> （ECMAScript 2015/ ES6 新特性）</li></ul><p>我们平时开发应该尽量使用 === 而不是 ==，因为 === 结果更加直观，更符合预期，只有严格相等才会返回 true。而使用 ==，你还要思考一下各种类型转换的情况。</p><p>前面两个我就不多说了，相信大家都非常清楚它们的区别了，就是 == 会在比较时做类型转换，而 === 不会。至于第三个 Object.is，我们看几个测试就知道它的特点了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>它和 === 也就是严格等的区别就在于 0 不等于 -0，NaN 和 NaN 是相等的。如果你问我 Object.is 有什么用，反正我觉得没什么卵用。</p><h4 id="是什么鬼"><a href="#是什么鬼" class="headerlink" title="!! 是什么鬼"></a>!! 是什么鬼</h4><p>在搞清楚 !! 之前，我们先探究下 <code>!</code>，学过编程的都知道，! 是逻辑运算符，功能是取反。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">true</span>); <span class="comment">//=&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>那么当 ! 后面跟着的操作数不是 boolean 类型会发生什么呢？稍微有点灵性就能猜出来是先将其转换成 boolean 值，再取反。看测试结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">-1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">-1</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(![]); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">''</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">' '</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">' '</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>测试结果证明了我们的猜想是对的。既然一次 ! 是将操作数转换成 boolean 再取反，那么再来一次取反，就是负负得正，其实就是转换成 boolean 值嘛。使用 <code>!!var</code> 比起 <code>Boolean(var)</code> 方便多了。</p><h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><p><strong>undefined 类型只有 undefined 一个值，null 类型同样也只有 null 一个值</strong>。这俩放一起说是因为它俩实在是太像了，我感觉很多人甚至认为他俩没区别。</p><p>个人认为它们还是有区别的，从语义的角度来说：undefined 表示一个变量被声明了但是没被赋值，而 null 表示获取不到值，一般是你刻意设置的空值，具体表现就是设置函数返回值时如果获取不到值的时候我们往往是返回 null，而不会返回 undefined。</p><p>有些人可能会下意识认为 <code>false == null</code>，事实却是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>事实上只有 undefined 和 null 才会和 null 非严格等，false 也不行，所以当你看到有人使用 if (val == null) 时应该要知道它是在判断 val 是不是等于 undefined 或者 null，而不是判断是不是 falsy。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol 我感觉平时写项目可能不太用得上，但是在写库或者设计框架的时候还是能派上用场的，例如我在实现完全符合 A+ 规范的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9kZWVwLWluLWZl" title="https://github.com/tjx666/deep-in-fe">MyPromise<i class="fa fa-external-link"></i></span> 的时候就用 Symbol 来表示状态枚举值。</p><p>symbol 和后面要说的 bigInt 一样，<strong>不能使用 new 来构造值</strong>。获取一个 symbol 值只能通过 Symbol(description) 或者 Symbol.for(key)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'mark'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'mark'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1); <span class="comment">// =&gt; symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// =&gt; Symbol(mark)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.for(<span class="string">'key'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'key'</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>symbol 最大的特点便是唯一性，每次通过 Symbol 返回的都是 js 内部计算好的一个 唯一的 symbol 值。除了唯一性，symbol 类型的值还能作为对象的键，这在 ES5 时代是只有字符串类型。有些人可能认为 number 也能作为对象的键，一个显而易见的例子便是数组，事实真的是这样吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.keys(arr)[<span class="number">0</span>]); <span class="comment">// =&gt; string</span></span><br></pre></td></tr></table></figure><p>那么 symbol 有什么用呢？最大的用途其实还是作为对象的属性使用。使用 symbol 值定义属性，好处就是：<strong>防止用户修改内部属性</strong>。事实上 js 内部有很多属性都是使用 symbol 值定义的，这些属性大多直接绑定到 Symbol 函数上，例如 <code>Symbol.toPrimitive</code>，对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li>Number：该场合需要转成数值</li><li>String：该场合需要转成字符串</li><li>Default：该场合可以转成数值，也可以转成字符串</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj; <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj; <span class="comment">// '3default'</span></span><br><span class="line">obj == <span class="string">'default'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj); <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure><p>除了定义属性，我觉得还可以用于搭配对象实现枚举。因为 js 没有枚举这种类型，所以我们只能模拟了，使用 symbol 可以模拟一个更 perfect 的枚举，让枚举值不可能会重复，还能避免使用 switch/case 的时候由于枚举值相等造成逻辑 bug。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举的特点：不能重复，不能被修改</span></span><br><span class="line"><span class="comment">// 这个版本更好理解</span></span><br><span class="line"><span class="keyword">const</span> Season = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  SPRING: <span class="built_in">Symbol</span>(<span class="string">'season-spring'</span>),</span><br><span class="line">  SUMMER: <span class="built_in">Symbol</span>(<span class="string">'season-summer'</span>),</span><br><span class="line">  AUTUMN: <span class="built_in">Symbol</span>(<span class="string">'season-autumn'</span>),</span><br><span class="line">  WINTER: <span class="built_in">Symbol</span>(<span class="string">'season-winter'</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Season.SPRING = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Season.SPRING); <span class="comment">// =&gt; Symbol(season-spring)</span></span><br><span class="line"><span class="comment">// 枚举值不能重复</span></span><br><span class="line"><span class="built_in">console</span>.log(Season.SPRING === Season.SUMMER); <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更完善的实现，枚举应该是不能被修改的，这里使用了 ES6 的 proxy</span></span><br><span class="line"><span class="keyword">const</span> Season = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    SPRING: <span class="built_in">Symbol</span>(<span class="string">'season-spring'</span>),</span><br><span class="line">    SUMMER: <span class="built_in">Symbol</span>(<span class="string">'season-summer'</span>),</span><br><span class="line">    AUTUMN: <span class="built_in">Symbol</span>(<span class="string">'season-autumn'</span>),</span><br><span class="line">    WINTER: <span class="built_in">Symbol</span>(<span class="string">'season-winter'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">set</span>() &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`can't modify enumeration Season`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Season.SPRING = 666; // =&gt; can't modify enumeration Season</span></span><br><span class="line"><span class="built_in">console</span>.log(Season.SPRING); <span class="comment">// =&gt; Symbol(season-spring)</span></span><br><span class="line"><span class="built_in">console</span>.log(Season.SPRING === Season.SUMMER); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="bigInt"><a href="#bigInt" class="headerlink" title="bigInt"></a>bigInt</h3><p>看一道 leetcode 题：</p><p><img data-src="https://i.loli.net/2020/01/15/LpExMSo5rPtOR2s.png" alt="leetcode-question"></p><p>这道题我不假思索的就写下了下边的答案：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusOne</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">Number</span>(digits.join(<span class="string">''</span>)) + <span class="number">1</span>&#125;</span>`</span>.split(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果提交的时候出错了：</p><p><img data-src="https://i.loli.net/2020/01/15/7P4X31eEacMkL6v.png" alt="leetcode-record"></p><p>出错的原因很简单，因为测试的数据大于 js 最大安全整数了，出现了精度丢失：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">Number</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>].join(<span class="string">''</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// =&gt; 614 5390 1951 8670 5000</span></span><br><span class="line"><span class="built_in">console</span>.log(num &gt; <span class="built_in">Number</span>.MAX_SAFE_INTEGER); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER); <span class="comment">// =&gt; 9007 1992 5474 0991</span></span><br></pre></td></tr></table></figure><p>换成 BigInt 来试试：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusOne</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;BigInt(digits.join(<span class="string">''</span>)) + <span class="number">1n</span>&#125;</span>`</span>.split(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次就顺利通过了所有测试：</p><p><img data-src="https://i.loli.net/2020/01/15/vpHTwQet7ZugAYc.png" alt="leetcode-test-pass"></p><p>这里来说点题外话，笔者最近在刷 leetcode，因为很多题其实有很多解法，有时我就会拿 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2JlbmNobWFyay5qcw==" title="https://github.com/bestiejs/benchmark.js">benchmark.js<i class="fa fa-external-link"></i></span> 来去测试不同解法的效率。不过，测着测着。我就发现：<strong>使用 JavaScript 测试不同的算法效率很扯淡</strong>。来看一个具体的例子，leetcode 26 题，删除重复元素。</p><p>解法一：两层循环，算法复杂度： O(n²)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// removeDuplicates1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicates</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">        nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">      &#125;</span><br><span class="line">      nums.length--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：快慢双指针，一次遍历即可，算法复杂度 O(n)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// removeDuplicates2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicates</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = nums;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> tail = <span class="number">1</span>; tail &lt; length; tail++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[tail] !== nums[head]) &#123;</span><br><span class="line">      head++;</span><br><span class="line">      nums[head] = nums[tail];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resultLength = head + <span class="number">1</span>;</span><br><span class="line">  nums.length = resultLength;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我拿最能发挥双指针优势的情况，也即是大量重复元素的情况来测试测试：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Suite &#125; = <span class="built_in">require</span>(<span class="string">'benchmark'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeDuplicates1 = <span class="built_in">require</span>(<span class="string">'../src/0026-Remove Duplicates from Sorted Array/removeDuplicates1'</span>);</span><br><span class="line"><span class="keyword">const</span> removeDuplicates2 = <span class="built_in">require</span>(<span class="string">'../src/0026-Remove Duplicates from Sorted Array/removeDuplicates2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testArr = [...Array(<span class="number">1e5</span>)].map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Suite()</span><br><span class="line">  .add(<span class="string">'removeDuplicates1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    removeDuplicates1(testArr);</span><br><span class="line">  &#125;)</span><br><span class="line">  .add(<span class="string">'removeDuplicates2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    removeDuplicates2(testArr);</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Fastest is <span class="subst">$&#123;<span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>)&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .run(&#123; <span class="attr">async</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>结果出人意料，还特么是算法一效率高</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* &#x3D;&gt;</span><br><span class="line">removeDuplicates1 x 94,495,506 ops&#x2F;sec ±1.94% (83 runs sampled)</span><br><span class="line">removeDuplicates2 x 11,855,308 ops&#x2F;sec ±3.34% (84 runs sampled)</span><br><span class="line">Fastest is removeDuplicates1</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>所以我觉得吧，在写 JS 的时候，我们一般情况都不需要去考虑算法效率，去重我用 Set 难道不香吗？虽然这个解法不符合 leetcode 的题目要求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = <span class="function"><span class="params">nums</span> =&gt;</span> [...new <span class="built_in">Set</span>(nums)];</span><br></pre></td></tr></table></figure><p>其是也就是常说的不要过早的优化，即便是真需要算法进行优化的时候，我们也应该需要对实际效果测试之后再决定是否优化，理论和实际还是有很大区别的，现实情况往往想像的要复杂的多。</p><h2 id="JavaScript-类型判断"><a href="#JavaScript-类型判断" class="headerlink" title="JavaScript 类型判断"></a>JavaScript 类型判断</h2><p>先归纳一下常见的判断方法：</p><ol><li>typeof</li><li>instanceof</li><li>Object.prototype.toString</li><li>比较构造器</li><li>比较对象的属性</li><li>原生 API</li><li>直接比较值是否等于你要判断的值</li></ol><p>下面一个一个来说说它们的各自适合的使用场景和优缺点。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>当你需要判断一个变量的类型的时候，首先应该想到的是就是能不能用 typeof 来判断。为什么？因为 typeof 比其它的方式更安全：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> abc); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(def <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// 报错：ReferenceError: def is not defined</span></span><br></pre></td></tr></table></figure><p>当你对一个没有声明过的变量进行判断时，使用 typeof 相比与 instanceof 等其它方法更安全，使用 typeof 只会返回 undefined，而其它方式直接报错了。</p><p>但是 typeof 绝对安全吗？No，碰到暂时性死区照样歇菜：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>再给 typeof 适合哪些情况下结论之前我们先来测试一下 typeof 的特性:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">6</span>); <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'6'</span>); <span class="comment">// =&gt; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// =&gt; boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'6'</span>)); <span class="comment">// =&gt; symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> BigInt(<span class="number">6</span>)); <span class="comment">// =&gt; bigint</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// =&gt; object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// =&gt; object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// =&gt; function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">6</span>)); <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>()); <span class="comment">// =&gt; object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)); <span class="comment">// =&gt; object</span></span><br></pre></td></tr></table></figure><p>值得注意的是最后两组测试，前面的测试都比较符合预期，也就是说 typeof 对基本类型使用时会返回它的类型字符串。出乎意料的是 typeof null 居然也返回 object，还有 typeof 函数时返回的是 function，讲道理应该返回 null 和 object 才对。</p><p>最后一组测试的结果表面当我们 new 基本类型的构造函数的时候返回的是它们的包装类实例，也就是对象类型。</p><p>根据测试结果我们可以下结论：<strong>typeof 适合判断除了 null 以外的基本类型和函数类型，也可以用于判断是否为对象类型，不适合判断是否为某种类的实例。</strong></p><p>其实 typeof 还是比较万能的，当我们在开发时需要类型判断时，可以先考虑下能不能使用 typeof 来判断。我们来实现一个判断是否为 number 的工具函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'number'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像挺简单的，实测一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="number">6</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">6</span>))); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>你会发现当 val 是数字对象的时候就返回 false 了，因为 typeof new Number(6) 返回的是 ‘object’，如果要求 isNumber 兼容数字对象怎么办？</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>我们知道在 js 中很多类型的对象可以通过 new constructor() 的方式来构造对象，<strong>如果你需要判断一个变量是否是某个类的实例，就可以用 instanceof 来判断</strong>：</p><p>instanceof 的原理很简单：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="built_in">require</span>(<span class="string">'../is/isObject'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">obj, constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(<span class="keyword">constructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not an object`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">constructor</span> !== 'function') &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Right-hand side of 'instanceof' is not callable`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">constructor</span>.prototype.isPrototypeOf(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的其它代码保存在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9kZWVwLWluLWZlL2Jsb2IvbWFzdGVyL3NyYy9pbnN0YW5jZW9m" title="https://github.com/tjx666/deep-in-fe/blob/master/src/instanceof">instanceof 运算符原理<i class="fa fa-external-link"></i></span>。主要是最后一句 <code>constructor.prototype.isPrototypeOf(obj)</code>，也就是对于 obj instanceof constructor，返回的就是 constructor 的原型是否在 obj 的原型链上。</p><p>下面的测试结果表明 instanceof 不能用于判断基本类型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>() <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(BigInt(<span class="number">5</span>) <span class="keyword">instanceof</span> BigInt); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>现在我们来完善一下之前的 isNumber 函数:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'number'</span> || val <span class="keyword">instanceof</span> <span class="built_in">Number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="string">'123'</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="literal">true</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="literal">null</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(&#123;&#125;)); <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="number">1</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="built_in">Object</span>(<span class="number">1</span>))); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">555</span>))); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>测试成功。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>我们看看 lodash 它的 isNumber 是怎么实现的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> || (isObjectLike(value) &amp;&amp; getTag(value) == <span class="string">'[object Number]'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再贴一下 isObjectLike 和 getTag 的源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObjectLike</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toString.call(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好理解， isObjectLike 就是判断一个变量是否是非函数对象，getTag 就是封装了一下 Object.prototype.toString，让它也能处理 value 等于 undefined 或者 null 的时候。</p><p>那么 Object.prototype.toString 是干嘛用的呢，看几个测试：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>)); <span class="comment">// =&gt; [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>)); <span class="comment">// =&gt; [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>)); <span class="comment">// =&gt; [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>)); <span class="comment">// =&gt; [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;)); <span class="comment">// =&gt; [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// =&gt; [object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="regexp">/e/</span>)); <span class="comment">// =&gt; [object RegExp]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> Foo())); <span class="comment">// =&gt; [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'自定义的 tag'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> Bar())); <span class="comment">// =&gt; [object 自定义的 tag]</span></span><br></pre></td></tr></table></figure><p>一般来说所有的对象的原型链往上追溯最后都会到 Object.prototype，所以你可以在任意对象上调用 toString 方法。为什么 lodash 在 getTage 中还特意处理了下 value 是 null 或者 undefined 的情况呢？参考 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3RvU3RyaW5n" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">MDN<i class="fa fa-external-link"></i></span> 的说明：</p><blockquote><p><strong>Note:</strong> Starting in JavaScript 1.8.5, <code>toString()</code> called on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> returns <code>[object Null]</code>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> returns <code>[object Undefined]</code>, as defined in the 5th Edition of ECMAScript and subsequent Errata.</p><p>See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#Using_toString_to_detect_object_class" target="_blank" rel="noopener">Using <code>toString()</code> to detect object class</a>.</p></blockquote><p>也就是说在早期版本的 js 中 toString.call(null) 不会返回 <code>[object Null]</code>。我们还可以使用 Symbol.toStringTag 属性来定义对象的 stringTag。为什么我们不直接拿变量的 toString 函数返回值去比较而是要用 Object.prototype.toString.call(value) 去绑定对象原型的 toString 函数的 this 到变量上，这样来获取 stringTag 呢？原因其实很简单，一方面大多数类型都重写了自己的 tostring 函数，例如 Date 返回的就是本地时间字符串而不是 [object Date]，另一方面是因为直接对 null 或 undefined 调用 toString 会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.toString()); <span class="comment">// =&gt; [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()); <span class="comment">// =&gt; Wed Jan 15 2020 16:03:59 GMT+0800 (GMT+08:00)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/e/</span>).toString()); <span class="comment">// =&gt; /e/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.toString()); <span class="comment">// Cannot read property 'toString' of null</span></span><br></pre></td></tr></table></figure><p>现在再来看 lodash 实现的 isNumber 就很好理解了，就是先用 typeof 来判断是不是 number 类型，再用 isObjectLike 和 getTag 判断是不是 number 对象。</p><h3 id="比较构造器"><a href="#比较构造器" class="headerlink" title="比较构造器"></a>比较构造器</h3><p><strong>通过直接比较对象得构造器是不是等于某个构造器也可以用来做类型判断，</strong>笔者前不久在看 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4Lmpz" title="https://github.com/tj/co/blob/master/index.js">co<i class="fa fa-external-link"></i></span> 源码的时候看到它定义了好几个类型判断函数，先来看一个简单点的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span> == val.constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实是用来判断 val 是不是纯对象的，也就是使用对象字面量和 new Object() 构造的实例。其实单独单独看这个函数是设计的有问题的，当 val 是 undefined 或 null 就会出错。但是这只是我摘得部分代码，真正源码上下文，这个 val 是不会等于 null 或 undefined 的，希望读者不要误解。</p><h3 id="比较对象的属性"><a href="#比较对象的属性" class="headerlink" title="比较对象的属性"></a>比较对象的属性</h3><p>再来看 co 源码中另外两个个稍微复杂的类型判断：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGenerator</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.next &amp;&amp; <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.throw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGeneratorFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = obj.<span class="keyword">constructor</span>;</span><br><span class="line">  if (!<span class="keyword">constructor</span>) return false;</span><br><span class="line">  if ('GeneratorFunction' === <span class="keyword">constructor</span>.name || 'GeneratorFunction' === <span class="keyword">constructor</span>.displayName) return true;</span><br><span class="line">  return isGenerator(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看第一个函数，判断一个对象是否是生成器对象，生成器我们知道，生成器函数返回的对象就是生成器对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> genObj.next); <span class="comment">// =&gt; function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> genObj.throw); <span class="comment">// =&gt; function</span></span><br></pre></td></tr></table></figure><p>由于生成器对象都有 next 和 throw 函数，因此我们可以根据这点来判断一个对象是不是生成器对象。类似的应用像是判断一个对象是不是 promise，可以简单使用有没有 then 函数来判断。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着再看看第二个函数 isGeneratorFunction，看名字就知道是用来判断一个对象是不是生成器函数，其实也是<strong>利用对象特有属性来判断类型</strong>。我们知道构造器都是函数，然后函数有 name 属性和 displayName 属性，对于生成器函数来说，生成器函数的 name 固定是 <code>GeneratorFunction</code>。displayName 是一个非标准属性，这个属性表示设计者对于函数名的定义。所以这里就是简单判断了传入的对象的构造器的名称是否是 <code>GeneratorFunction</code>，如果不是再判断它的原型是不是生成器对象，不过我也没搞明白最后为什么要有最后这个判断。</p><p><img data-src="https://i.loli.net/2020/01/15/iyn6XPecHkhBOzJ.png" alt="isGeneratorFunction"></p><h3 id="原生-API"><a href="#原生-API" class="headerlink" title="原生 API"></a>原生 API</h3><p>关于类型判断，面试常问的除了 NaN，还有就是数组如何判断。其实 JS 本身就自带了一些类型判断 API，判断数组可以直接用 Array.isArray：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123; <span class="attr">length</span>: <span class="number">6</span> &#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>相对于浏览器环境，node 的 <code>util</code> 模块真的是贴心多了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; types &#125; = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(types.isPromise(<span class="built_in">Promise</span>.resolve()));</span><br><span class="line"><span class="built_in">console</span>.log(types.isProxy(<span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;&#125;)));</span><br><span class="line"><span class="built_in">console</span>.log(types.isGeneratorFunction(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(types.isGeneratorObject(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;()));</span><br><span class="line"><span class="built_in">console</span>.log(types.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(types.isSet(<span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(types.isMap(<span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(types.isRegExp(<span class="regexp">/exp/</span>));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 以上全部返回 true，并且都是 node V10 新增的</span></span><br></pre></td></tr></table></figure><p>这里提一下我之前在使用 babel 转码 node 代码发现的一个 bug，就是 <code>util.types.isGeneratorFunction</code> 方法在 babel 转码之后判断有问题：</p><p><img data-src="https://i.loli.net/2020/01/15/VbPUtD4epTl2arK.png" alt="babel-node-bug"></p><p>可以看到 bebug 控制台输出的是 false。</p><h3 id="直接比较值是否等于你要判断的值"><a href="#直接比较值是否等于你要判断的值" class="headerlink" title="直接比较值是否等于你要判断的值"></a>直接比较值是否等于你要判断的值</h3><p>这个很好理解，例如判断 null 和 undefined，我们就可以用这种方式，看一下 lodash 的 isObject，就是判断不等于 null 且 typeof 返回的是<code>&#39;object&#39;</code> 或者 <code>‘function’</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文的内容就这么多，最近写了两个 VSCode 插件：[<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni92aWV3LWdpdGh1Yi1yZXBvc2l0b3J5" title="https://github.com/tjx666/view-github-repository">view-github-repository<i class="fa fa-external-link"></i></span>] 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9vcGVuLWluLWV4dGVybmFsLWFwcA==" title="https://github.com/tjx666/open-in-external-app">open-in-external-app<i class="fa fa-external-link"></i></span>，以及几个模板项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9hd2Vzb21lLWNocm9tZS1leHRlbnNpb24tYm9pbGVycGxhdGU=" title="https://github.com/tjx666/awesome-chrome-extension-boilerplate">awesome-chrome-extension-boilerplate<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni92c2NvZGUtZXh0ZW5zaW9uLWJvaWxlcnBsYXRl" title="https://github.com/tjx666/vscode-extension-boilerplate">vscode-extension-boilerplate<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9rb2EtcmVzdGZ1bC1ib2lsZXJwbGF0ZQ==" title="https://github.com/tjx666/koa-restful-boilerplate">koa-restful-boilerplate<i class="fa fa-external-link"></i></span>。感兴趣不妨去<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ng==" title="https://github.com/tjx666">我的 github 主页<i class="fa fa-external-link"></i></span>逛逛。</p><p>最后，快过年了，祝大家新年快乐，2020 事业更上一层楼。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 基础之 call, apply, bind</title>
    <url>/javascript-%E5%9F%BA%E7%A1%80%E4%B9%8B-call-apply-bind/</url>
    <content><![CDATA[<p>系统，扎实的 javascript 语言基础是一个优秀的前端工程师必须具备的。在看了一些关于 call，apply，bind 的文章后，我还是打算写下这篇总结，原因有几个。首先，在如今 ES6 大行其道的今天，很多文章中讲述的它们的应用场景其实用 ES6 可以更优雅的解决，但是基本上·没有文章会去提 ES6 的解法。再则，讲它们的实现原理的文章其实不少，但是或多或少实现的有些不够完美，本文将把它们通过代码一一比较完美的实现，让它们不再神秘。不谦虚的说，关于 call，apply，bind 的知识，看这一篇文章就够了。</p><a id="more"></a><h2 id="改变函数中-this-指向的三兄弟"><a href="#改变函数中-this-指向的三兄弟" class="headerlink" title="改变函数中 this 指向的三兄弟"></a>改变函数中 this 指向的三兄弟</h2><p>我们知道在 javascript 的 function 中有 <code>this</code>，<code>arguments</code> 等关键字。本文不讨论 this 指向问题，那个都可以单独整一篇文章了。一个常见的使用场景是当你使用 <code>.</code> 来调用一个函数的时候，此时函数中 this 指向 <code>.</code> 前面的调用者：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'YuTengjing'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  introduce() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello everyone! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 此时指向 person</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce()); <span class="comment">// =&gt; Hello everyone! My name is YuTengjing. I'm 22 years old.</span></span><br></pre></td></tr></table></figure><p>通过 call，apply，bind 这三兄弟可以改变 <code>introduce</code> 中 this 的指向。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call<i class="fa fa-external-link"></i></span></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFriend = &#123;</span><br><span class="line">  name: <span class="string">'dongdong'</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce.call(myFriend)); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br></pre></td></tr></table></figure><p>通过上面代码我们可以看出 <code>introduce</code> 这个函数中的 this 指向被改成了 myFriend。Function.prototype.call 的函数签名是 <code>fun.call(thisArg, arg1, arg2, ...)</code>。第一个参数为调用函数时 this 的指向，随后的参数则作为函数的参数并调用，也就是 fn(arg1, arg2, …)。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHk=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply<i class="fa fa-external-link"></i></span></h3><p>apply 和 call 的区别只有一个，就是它只有两个参数，而且第二个参数为调用函数时的参数构成的数组。函数签名：<code>func.apply(thisArg, [argsArray])</code>。如果不用给函数传参数，那么他俩就其实是完全一样的，需要传参数的时候注意它的应该将参数转换成数组形式。</p><p>一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayHobbies</span>(<span class="params">...hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> likes <span class="subst">$&#123;hobbies.join(<span class="string">', '</span>)&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个等价</span></span><br><span class="line">displayHobbies.call(&#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;, <span class="string">'swimming'</span>, <span class="string">'basketball'</span>, <span class="string">'anime'</span>); <span class="comment">// =&gt; // =&gt; Bob likes swimming, basketball, anime.</span></span><br><span class="line">displayHobbies.apply(&#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;, [<span class="string">'swimming'</span>, <span class="string">'basketball'</span>, <span class="string">'anime'</span>]); <span class="comment">// =&gt; Bob likes swimming, basketball, anime.</span></span><br></pre></td></tr></table></figure><p>有些 API 比如 Math.max 它的参数为多参数，当我们有多参数构成的数组使或者说参数很多时该怎么办呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Math.max 参数为多参数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在已知一个很大的元素为随机大小的整数数组</span></span><br><span class="line"><span class="keyword">const</span> bigRandomArray = [...Array(<span class="number">10000</span>).keys()].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.trunc(num * <span class="built_in">Math</span>.random()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎样使用 Math.max 获取 bigRandomArray 中的最大值呢？Math.max 接受的是多参数而不是数组参数啊!</span></span><br><span class="line"><span class="comment">// 思考下面的写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, bigRandomArray)); <span class="comment">// =&gt; 9936</span></span><br></pre></td></tr></table></figure><p>可以上 ES6 的话就简单了，使用扩展运算符即可，优雅简洁。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...bigRandomArray));</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind<i class="fa fa-external-link"></i></span></h3><p>bind 和上面两个用途差别还是比较大，如同字面意思（绑定），是用来绑定 this 指向的，返回一个原函数被绑定 this 后的新函数。一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'YuTengjing'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello everyone! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFriend = &#123; <span class="attr">name</span>: <span class="string">'dongdong'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line">person.introduce = introduce.bind(myFriend);</span><br><span class="line"></span><br><span class="line"><span class="comment">// person.introduce 的 this 已经被绑定到 myFriend 上了</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce()); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.introduce.call(person)); <span class="comment">// =&gt; Hello everyone! My name is dongdong. I'm 21 years old.</span></span><br></pre></td></tr></table></figure><p>bind 的函数签名是 <code>func.bind(thisArg, arg1, arg2, ...)</code>。春招的时候被问过 bind 的第二个参数是干嘛用的，因为我之前写代码本身不怎么用这几个 API，用的时候我也只用第一个参数，所以当时面试的时候被问这个问题的时候我还是愣了一下。不过其实如果可以传多个参数的话，猜也能猜得出来是干嘛用的，我当时就猜对了 φ(*￣ 0 ￣)。</p><h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><p>我们学习知识的时候不能只是停留在理解层面，需要去思考它们有什么用，应用场景有哪些。这样的话，当你处在这种场景中，你就能很自然的想出解决方案。</p><h3 id="多参函数转换为单个数组参数调用"><a href="#多参函数转换为单个数组参数调用" class="headerlink" title="多参函数转换为单个数组参数调用"></a>多参函数转换为单个数组参数调用</h3><p>javascript 中有很多 API 是接受多个参数的比如之前提过的 Math.max，还有很多例如 Math.min，Array.prototype.push 等它们都是接受多个参数的 API，但是有时候我们只有多个参数构成的数组，而且可能还特别大，这个时候就可以利用 apply 巧妙的来转换。</p><p>下面是利用 apply 来巧妙的合并数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>但是，其实用 ES6 可以非常的简洁：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>所以，忘了这种用法吧（￣︶￣）↗ 　。</p><h3 id="将类数组转换为数组"><a href="#将类数组转换为数组" class="headerlink" title="将类数组转换为数组"></a>将<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9UeXBlZF9hcnJheXM=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">类数组<i class="fa fa-external-link"></i></span>转换为数组</h3><p>JavaScript 类型化数组是一种类似数组的对象，它们有数组的一些属性，但是如果你用 Array.isArray() 去测试会返回 false，常见的像 arguments，NodeList 等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testArrayLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有 length 属性没有 slice 属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// =&gt; 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.slice); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类数组不是数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// =&gt; &#123; [Iterator]  0: 'a', 1: 'b', 2: 'c', [Symbol(Symbol.iterator)]: [λ: values] &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> array = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array)); <span class="comment">// =&gt; true</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// =&gt; [ 'a', 'b', 'c' ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testArrayLike(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><p>其实 把 slice 换成 concat，splice 等其它 API 也是可以的。思考：<strong>为什么通过 Array.prototype.slice.call(arrayLike) 可以转换类数组为数组？</strong></p><p>我没有研究过 slice 的具体实现，猜测是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySlice = <span class="function"><span class="keyword">function</span>(<span class="params">start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> end = end === <span class="literal">undefined</span> ? array.length : end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resultArray = [];</span><br><span class="line">  <span class="keyword">if</span> (array.length === <span class="number">0</span>) <span class="keyword">return</span> resultArray;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">    resultArray.push(array[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我想 slice 内部实现可能就是会像我上面的代码一样只需要一个 length 属性，遍历元素返回新数组，所以调用 slice 时将其 this 指向类数组能正常工作。</p><p>其实，这个用法也可以忘了，用 ES6 来转换不造多简单，ES6 大法好 😂。</p><p>可以使用 Array.from(arrayLike)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>还可以使用扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [...arguments];</span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>ES6 class 出现之前，个人认为比较完美的继承是使用原型链加组合的继承方式，以前研究原型继承写的代码在这：<a href="https://github.com/tjx666/javascript-code-lab/tree/master/src/prototypeExtends" target="_blank" rel="noopener"><strong>prototypeExtends</strong></a>。这里不展开讲 javascript 的继承，那会又是一个巨坑。</p><p>组合继承其实很好理解，这个组合指的是子类的实例属性组合了父类的实例属性，看代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">type, color</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>, type);</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bird = <span class="keyword">new</span> Bird(<span class="string">'bird'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bird); <span class="comment">// =&gt; Bird &#123; type: 'bird', color: 'green' &#125;</span></span><br></pre></td></tr></table></figure><p>组合继承核心代码就是那句 Animal.call(this, type)，通过调用父类构造器并修改其 this 指向为子类实例来达到子类实例上组合父类的实例属性目的。</p><h2 id="自己实现-call，apply，bind"><a href="#自己实现-call，apply，bind" class="headerlink" title="自己实现 call，apply，bind"></a>自己实现 call，apply，bind</h2><h3 id="call-1"><a href="#call-1" class="headerlink" title="call"></a>call</h3><p>实现 call 主要有两种思路，一种是通过在 thisArg 上临时添加 func，然后直接调用 thisArg.func()。另外一种是利用 func.toString() 替换 this 为 thisArg，再 eval 来实现。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>下面这个版本主要为了说明思路，其实是有很多缺陷的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg.tempFunc = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.tempFunc(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.tempFunc;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>上面的代码中有一些缺陷：</p><ol><li><p>myCall 的第一个参数可能被传入非对象参数，要对不同类型的 thisArg 分别处理。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 中对 thisArg 的描述<i class="fa fa-external-link"></i></span>：</p><blockquote><p>在 <em>fun</em> 函数运行时指定的 <code>this</code> 值<em>。</em>需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener"><code>非严格模式</code></a>下运行，则指定为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 的 <code>this</code> 值会自动指向全局对象（浏览器中就是 window 对象），同时值为原始值（数字，字符串，布尔值）的 <code>this</code> 会指向该原始值的自动包装对象。</p></blockquote></li><li><p>可能 thisArg 原本就有一个属性叫 tempFunc，这是完全有可能的，按照上面的代码来实现 myCall 就把原有的 tempFunc 属性消除了。可以使用 ES6 Symbol 来解决这个问题。</p></li></ol><p>所以完善后的 myCall 是酱紫：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> tempFunc(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">Symbol</span>(<span class="string">'Temp property'</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="built_in">Reflect</span>.deleteProperty(thisArg, tempFunc);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>讲第二中方式之前，先来聊聊其它的一些相关的东西。</p><h5 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString"></a>Function.prototype.toString</h5><p>调用一个函数的 toString 方法返回的是这个函数定义时代码字符：</p><p><img data-src="https://i.loli.net/2019/06/29/5d16c5b48ef8590170.png" alt="function toString"></p><p>我故意在 <code>console.log(&#39;hello world&#39;);</code> 上下插了一个空行，func 左右多打了几个空格，可以看到 func.toString() 返回的字符串完全是我定义 func 时的样子，多余的空行和空格依然存在，没有格式化。</p><h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5><p>eval 函数可以让我们将一个字符串当作代码来运行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(ctx.name)'</span>); <span class="comment">// Bob</span></span><br></pre></td></tr></table></figure><h5 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h5><p>所以看到这里思路已经很清晰了：先通过 func.toString 拿到 func 的代码字符串，再替换其中的 this 为 thisArg，再使用 eval 获取替换 this 后的临时函数（函数名显然和 func 一样）并执行。代码实现就是酱紫：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> tempFunc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换 this 为 thisArg</span></span><br><span class="line">  <span class="keyword">const</span> tempFuncString = funcString.replace(<span class="regexp">/this/g</span>, <span class="string">'thisArg'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 eval 构造一个临时函数并执行</span></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">eval</span>(<span class="string">`(<span class="subst">$&#123;tempFuncString&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 tempFunc 并传入参数</span></span><br><span class="line">  <span class="keyword">return</span> tempFunc(...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>添加一些打印语句后在 chrome 中的执行情况：<br><img data-src="https://i.loli.net/2019/06/29/5d16d5a0b97eb35960.png" alt="eval-call"></p><p>但是，<strong>这种实现方式其实是很扯淡的</strong>。它有很多不能容忍而且无解的缺陷：</p><ol><li>临时函数的作用域和 func 的作用域不一样。使用 eval(<code>(${tempFuncString})</code>) 时声明了一个和 func 同名的临时函数，它的作用域是 myCall 这个函数作用域，而 func 的作用域显然在 myCall 外。</li><li>替换 ‘this’ 时有可能 func 函数其中有字符串或者标识符本身包含了 ‘this’，比如 func 函数中有 console.log(‘this’) 这么一条输出语句，那这个 this 也被替换了，或者定义了个变量叫 xxthisxx。</li></ol><p>所以，相对而言，第一种实现更靠谱。</p><h3 id="apply-1"><a href="#apply-1" class="headerlink" title="apply"></a>apply</h3><p>call 和 apply 除了参数不一样之外没什么区别。所以稍微调整 myCall 中的参数和调用 func 时的调用形式即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> tempFunc(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="built_in">Symbol</span>(<span class="string">'Temp property'</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[tempFunc];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printName.myCall(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure><p>第二种方式就不写了，其实也很简单，不写主要时因为第二种实现没什么实用性，介绍它的就是为了扩展一下思路。</p><h3 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h3><p>使用 call 来实现 bind 是一个比较常见的面试题，类似于使用 map 实现 reduce，其实还是考察你 javascript 掌握的怎么样。如果面试被问到闭包有哪些实际应用你其实也可以说可以使用闭包来实现 bind，对吧，面试还是有些技巧的。</p><p>思路我上面其实已经说了，就是利用闭包和 call 就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行函数时 this 始终为外层函数中的 thisArg，前面的调用参数也被绑定为 args</span></span><br><span class="line">    <span class="keyword">return</span> func.call(thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printThisAndAndArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)&#125;</span>, arguments is <span class="subst">$&#123;[...<span class="built_in">arguments</span>].join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunc = printThisAndAndArgs.myBind(&#123; <span class="attr">name</span>: <span class="string">'Lily'</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">boundFunc(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// =&gt; This is &#123;"name":"Lily"&#125;, arguments is 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><p>按照惯例，上面实现的版本肯定是有些问题的ㄟ( ▔, ▔ )ㄏ。</p><h4 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h4><p>第一个问题是没处理当使用 new 调用的情况：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent1 = Student.bind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent1(<span class="number">22</span>)); <span class="comment">// =&gt; Student &#123; name: 'ly', age: 22 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>)); <span class="comment">// =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 bind 当返回的函数被使用 new 调用时， thisArg 被忽略，此时 bind 函数的作用只是起到了绑定构造函数参数的作用。当前版本的 myBind 只是返回了一个空对象，没有在返回的实例对象上绑定属性。</p><p>这里补充一下 new 操作符的实现原理。我有一个项目<a href="https://github.com/tjx666/javascript-code-lab" target="_blank" rel="noopener"><strong>javascript-code-lab</strong></a>上保存我探索原生 js 奥秘的一些代码，有兴趣可以看看。其中我 new 操作符的实现是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _new = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">const</span> result = fn.call(target, ...args);</span><br><span class="line">    <span class="keyword">const</span> isObjectOrFunction = (result !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">'object'</span>) || <span class="keyword">typeof</span> result === <span class="string">'function'</span>);</span><br><span class="line">    <span class="keyword">return</span> isObjectOrFunction ? result : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很好理解，当我们调用 new fn(arg1, arg2, …) 的时候，其实相当于执行了 _new(fn, arg1, arg2, …)。具体内部的执行步骤是这样的：</p><p>首先构造一个空对象 target，它的原型应该为 fn.prototype，这里我使用了 ES6 的 Object.create 来实现。</p><p>然后我们需要在 target 上绑定你在 fn 中通过 this.key = value 来绑定到实例对象的属性。具体做法就是执行 fn 并且将其 this 指向 target，也就是 const result = fn.call(target, …args);。</p><p>最后还要注意的就是当 fn 的返回值 result 是对象或者函数的时候，new fn(arg1, arg2, …) 返回的就是指行 fn 的返回值而不是 target，否则直接返回 target，也就是实例对象。</p><p><img data-src="https://i.loli.net/2019/06/29/5d16ec374162677354.png" alt="new"></p><p>如果有人问你有哪些方式可以修改函数的 this 指向，其实 <strong>new 操作符也可以修改构造函数的指向</strong>，没毛病吧。</p><p>了解了 new 操作符的原理之后，我们再来看看上面我们实现的 myBind 为什么会在 new 时工作不正常。当我们调用 new BoundStudent2(22) 时，根据我上面讲的 new 的原理知道，在构造出一个以 BoundStudent.prototype 为原型的空对象 target 后，会调用 BoundStudent.call(target) 。但是，观察我们实现的 myBind，作为 myBind(thisArg) 的返回值的 BoundStudent2，它内部执行时始是调用 func.call(thisArg, …args, …otherArgs)，也就是说 this 始终是 thisArg，所以才没有绑定 name，age 属性到 target 上，其实是被绑定到了 thisArg 上去了。而且由于 BoundStudent.call(target) 返回值为 undefined，所以 new BoundStudent2(22) 的结果就是 target。</p><h4 id="区分函数是否是通过-new-调用"><a href="#区分函数是否是通过-new-调用" class="headerlink" title="区分函数是否是通过 new 调用"></a>区分函数是否是通过 new 调用</h4><p>上面我们分析了 new 调用 myBind 绑定的函数产生的问题的原因，那么该如何解决呢？想要解决这个问题我们必须得能够区分出调用 BoundFunc2 时是否是通过 new 来调用的。可以使用 ES6 中 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldy50YXJnZXQ=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target">new.target<i class="fa fa-external-link"></i></span> 来区分。</p><p><img data-src="https://i.loli.net/2019/06/29/5d16fed23267568788.png" alt="new.target"></p><p><strong>new.target</strong>属性允许你检测函数或构造方法是否是通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldw==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new<i class="fa fa-external-link"></i></span>运算符被调用的。在通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL25ldw==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new<i class="fa fa-external-link"></i></span>运算符被初始化的函数或构造方法中，<code>new.target</code>返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent1 = Student.bind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent1(<span class="number">22</span>)); <span class="comment">// =&gt; Student &#123; name: 'ly', age: 22 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>)); <span class="comment">// =&gt; &#123; name: 'ly', age: 22 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="处理原型链"><a href="#处理原型链" class="headerlink" title="处理原型链"></a>处理原型链</h4><p>当前版本的 myBind 没有处理原型链，BoundStudent2 new 出来的实例无法访问 Student 原型链上的属性。修改如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">const</span> boundFunc = <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  boundFunc.prototype = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  boundFunc.prototype.constructor = boundFunc;</span><br><span class="line">  <span class="keyword">return</span> boundFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.type = <span class="string">'student'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>).type); <span class="comment">// =&gt; student</span></span><br></pre></td></tr></table></figure><h4 id="完善一些细节"><a href="#完善一些细节" class="headerlink" title="完善一些细节"></a>完善一些细节</h4><p>返回的函数毕竟是一个新的函数，它的有些属性需要我们修改。我们在处理一下 name 和 length 属性。如果一个函数 func 被绑定了英文叫 bound，那么 func.name 应该是 <code>bound func</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> boundFunc = func.bind(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(boundFunc.name); <span class="comment">// bound func</span></span><br></pre></td></tr></table></figure><p>func.length 表示函数的参数个数，但是 BoundFunc 的参数个数和 func 的参数个数可不一样，所以我们需要调整 func.length。值得注意的是 Function.prototype.name 和 Function.prototype.length 是不可写的，所以要通过 Object.defineProperties 来修改。</p><p>最终版：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 返回的是一个新函数，如果使用 new 调用了被绑定后的函数，其中的 this 即是 new 最后返回的实例对象，也就是 target</span></span><br><span class="line">  <span class="keyword">const</span> boundFunc = <span class="function"><span class="keyword">function</span>(<span class="params">...otherArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 new.target 为 func，不为空时，绑定 this，而不是 thisArg</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="keyword">new</span>.target ? <span class="keyword">this</span> : thisArg, ...args, ...otherArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  boundFunc.prototype = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  boundFunc.prototype.constructor = boundFunc;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(boundFunc, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      value: <span class="string">`bound <span class="subst">$&#123;func.name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    length: &#123;</span><br><span class="line">      value: func.length,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> boundFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.type = <span class="string">'student'</span>;</span><br><span class="line"><span class="keyword">const</span> BoundStudent2 = Student.myBind(&#123; <span class="attr">name</span>: <span class="string">'Taylor'</span> &#125;, <span class="string">'ly'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> BoundStudent2(<span class="number">22</span>).type); <span class="comment">// =&gt; student</span></span><br><span class="line"><span class="built_in">console</span>.log(BoundStudent2.name); <span class="comment">// =&gt; bound Student</span></span><br><span class="line"><span class="built_in">console</span>.log(BoundStudent2.length); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>bind 是 ES5 才新增的 API，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGlt" title="https://github.com/es-shims/es5-shim">es5-shim<i class="fa fa-external-link"></i></span> 是一个让传统和现代的浏览器引擎兼容 es5 的垫片库，其中 bind 的定义是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">defineProperties(FunctionPrototype, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .length is 1</span></span><br><span class="line">    <span class="comment">// 1. Let Target be the this value.</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 2. If IsCallable(Target) is false, throw a TypeError exception.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallable(target)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind called on incompatible '</span> + target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. Let A be a new (possibly empty) internal list of all of the</span></span><br><span class="line">    <span class="comment">//   argument values provided after thisArg (arg1, arg2 etc), in order.</span></span><br><span class="line">    <span class="comment">// XXX slicedArgs will stand in for "A" if used</span></span><br><span class="line">    <span class="keyword">var</span> args = array_slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// for normal call</span></span><br><span class="line">    <span class="comment">// 4. Let F be a new native ECMAScript object.</span></span><br><span class="line">    <span class="comment">// 11. Set the [[Prototype]] internal property of F to the standard</span></span><br><span class="line">    <span class="comment">//   built-in Function prototype object as specified in 15.3.3.1.</span></span><br><span class="line">    <span class="comment">// 12. Set the [[Call]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.1.</span></span><br><span class="line">    <span class="comment">// 13. Set the [[Construct]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.2.</span></span><br><span class="line">    <span class="comment">// 14. Set the [[HasInstance]] internal property of F as described in</span></span><br><span class="line">    <span class="comment">//   15.3.4.5.3.</span></span><br><span class="line">    <span class="keyword">var</span> bound;</span><br><span class="line">    <span class="keyword">var</span> binder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> bound) &#123;</span><br><span class="line">        <span class="comment">// 15.3.4.5.2 [[Construct]]</span></span><br><span class="line">        <span class="comment">// When the [[Construct]] internal method of a function object,</span></span><br><span class="line">        <span class="comment">// F that was created using the bind function is called with a</span></span><br><span class="line">        <span class="comment">// list of arguments ExtraArgs, the following steps are taken:</span></span><br><span class="line">        <span class="comment">// 1. Let target be the value of F's [[TargetFunction]]</span></span><br><span class="line">        <span class="comment">//   internal property.</span></span><br><span class="line">        <span class="comment">// 2. If target has no [[Construct]] internal method, a</span></span><br><span class="line">        <span class="comment">//   TypeError exception is thrown.</span></span><br><span class="line">        <span class="comment">// 3. Let boundArgs be the value of F's [[BoundArgs]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 4. Let args be a new list containing the same values as the</span></span><br><span class="line">        <span class="comment">//   list boundArgs in the same order followed by the same</span></span><br><span class="line">        <span class="comment">//   values as the list ExtraArgs in the same order.</span></span><br><span class="line">        <span class="comment">// 5. Return the result of calling the [[Construct]] internal</span></span><br><span class="line">        <span class="comment">//   method of target providing args as the arguments.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = apply.call(target, <span class="keyword">this</span>, array_concat.call(args, array_slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        <span class="keyword">if</span> ($<span class="built_in">Object</span>(result) === result) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 15.3.4.5.1 [[Call]]</span></span><br><span class="line">        <span class="comment">// When the [[Call]] internal method of a function object, F,</span></span><br><span class="line">        <span class="comment">// which was created using the bind function is called with a</span></span><br><span class="line">        <span class="comment">// this value and a list of arguments ExtraArgs, the following</span></span><br><span class="line">        <span class="comment">// steps are taken:</span></span><br><span class="line">        <span class="comment">// 1. Let boundArgs be the value of F's [[BoundArgs]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 2. Let boundThis be the value of F's [[BoundThis]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 3. Let target be the value of F's [[TargetFunction]] internal</span></span><br><span class="line">        <span class="comment">//   property.</span></span><br><span class="line">        <span class="comment">// 4. Let args be a new list containing the same values as the</span></span><br><span class="line">        <span class="comment">//   list boundArgs in the same order followed by the same</span></span><br><span class="line">        <span class="comment">//   values as the list ExtraArgs in the same order.</span></span><br><span class="line">        <span class="comment">// 5. Return the result of calling the [[Call]] internal method</span></span><br><span class="line">        <span class="comment">//   of target providing boundThis as the this value and</span></span><br><span class="line">        <span class="comment">//   providing args as the arguments.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// equiv: target.call(this, ...boundArgs, ...args)</span></span><br><span class="line">        <span class="keyword">return</span> apply.call(target, that, array_concat.call(args, array_slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 15. If the [[Class]] internal property of Target is "Function", then</span></span><br><span class="line">    <span class="comment">//     a. Let L be the length property of Target minus the length of A.</span></span><br><span class="line">    <span class="comment">//     b. Set the length own property of F to either 0 or L, whichever is</span></span><br><span class="line">    <span class="comment">//       larger.</span></span><br><span class="line">    <span class="comment">// 16. Else set the length own property of F to 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> boundLength = max(<span class="number">0</span>, target.length - args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17. Set the attributes of the length own property of F to the values</span></span><br><span class="line">    <span class="comment">//   specified in 15.3.5.1.</span></span><br><span class="line">    <span class="keyword">var</span> boundArgs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boundLength; i++) &#123;</span><br><span class="line">      array_push.call(boundArgs, <span class="string">'$'</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX Build a dynamic function with desired amount of arguments is the only</span></span><br><span class="line">    <span class="comment">// way to set the length property of a function.</span></span><br><span class="line">    <span class="comment">// In environments where Content Security Policies enabled (Chrome extensions,</span></span><br><span class="line">    <span class="comment">// for ex.) all use of eval or Function costructor throws an exception.</span></span><br><span class="line">    <span class="comment">// However in all of these environments Function.prototype.bind exists</span></span><br><span class="line">    <span class="comment">// and so this code will never be executed.</span></span><br><span class="line">    bound = $<span class="built_in">Function</span>(</span><br><span class="line">      <span class="string">'binder'</span>,</span><br><span class="line">      <span class="string">'return function ('</span> + array_join.call(boundArgs, <span class="string">','</span>) + <span class="string">')&#123; return binder.apply(this, arguments); &#125;'</span></span><br><span class="line">    )(binder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target.prototype) &#123;</span><br><span class="line">      Empty.prototype = target.prototype;</span><br><span class="line">      bound.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line">      <span class="comment">// Clean up dangling references.</span></span><br><span class="line">      Empty.prototype = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 18. Set the [[Extensible]] internal property of F to true.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).</span></span><br><span class="line">    <span class="comment">// 20. Call the [[DefineOwnProperty]] internal method of F with</span></span><br><span class="line">    <span class="comment">//   arguments "caller", PropertyDescriptor &#123;[[Get]]: thrower, [[Set]]:</span></span><br><span class="line">    <span class="comment">//   thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;, and</span></span><br><span class="line">    <span class="comment">//   false.</span></span><br><span class="line">    <span class="comment">// 21. Call the [[DefineOwnProperty]] internal method of F with</span></span><br><span class="line">    <span class="comment">//   arguments "arguments", PropertyDescriptor &#123;[[Get]]: thrower,</span></span><br><span class="line">    <span class="comment">//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;,</span></span><br><span class="line">    <span class="comment">//   and false.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// NOTE Function objects created using Function.prototype.bind do not</span></span><br><span class="line">    <span class="comment">// have a prototype property or the [[Code]], [[FormalParameters]], and</span></span><br><span class="line">    <span class="comment">// [[Scope]] internal properties.</span></span><br><span class="line">    <span class="comment">// XXX can't delete prototype in pure-js.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 22. Return F.</span></span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于这个库是用来兼容 ES5 的，所以没有用 ES6 的 <strong>new.target</strong> 而是用 <strong>instanceOf</strong> 来判断是否是使用 new 来调用的，也没有使用 ES6 的 Object.defineProperty 或者 Object.definePropertyies。可以看到官方源代码中的注释还是很详细清晰的，感兴趣的读者可以自行研究一下，有什么问题也可以在评论区提出来。</p><h2 id="几个疑问"><a href="#几个疑问" class="headerlink" title="几个疑问"></a>几个疑问</h2><h3 id="使用-bind-多次绑定一个函数，后续的绑定能生效吗？"><a href="#使用-bind-多次绑定一个函数，后续的绑定能生效吗？" class="headerlink" title="使用 bind 多次绑定一个函数，后续的绑定能生效吗？"></a>使用 bind 多次绑定一个函数，后续的绑定能生效吗？</h3><p>不能，被绑定后，后续再次使用 bind 绑定没有作用。最后执行函数 fn 时，this 始终时被指向第一次 bind 时的 thisArg。</p><h3 id="使用-bind-绑定函数-this-后，可以使用-call，apply-改变函数的指向吗？"><a href="#使用-bind-绑定函数-this-后，可以使用-call，apply-改变函数的指向吗？" class="headerlink" title="使用 bind 绑定函数 this 后，可以使用 call，apply 改变函数的指向吗？"></a>使用 bind 绑定函数 this 后，可以使用 call，apply 改变函数的指向吗？</h3><p>不能，原因和上面一样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boundTest = test.bind(&#123; <span class="attr">name</span>: <span class="string">'ly'</span> &#125;);</span><br><span class="line">boundTest(); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br><span class="line"></span><br><span class="line">boundTest = boundTest.bind(&#123; <span class="attr">name</span>: <span class="string">'dongdong'</span> &#125;);</span><br><span class="line">boundTest(); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br><span class="line"></span><br><span class="line">boundTest.call(&#123; <span class="attr">name</span>: <span class="string">'yinyin'</span> &#125;); <span class="comment">// =&gt; &#123; name: 'ly' &#125;</span></span><br></pre></td></tr></table></figure><p>其实最近看过有些公司前端面试还考了偏函数的知识，其实也用到了 bind。这里我不打算讲偏函数了，偏函数我有空再写一篇文章单独讲。</p><p>参考资料：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wMGRjNGFkOWI4M2Y=" title="https://www.jianshu.com/p/00dc4ad9b83f">JavaScript 中的 call、apply、bind 深入理解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzgxM2FhNWYyNjVkYTJkZDk0Y2Q3YzI=" title="https://juejin.im/post/5c813aa5f265da2dd94cd7c2">彻底弄清 this call apply bind 以及原生实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmVjNDE4M2YyNjVkYTYxNmIxMDQ0ZDc=" title="https://juejin.im/post/5bec4183f265da616b1044d7">面试官问：能否模拟实现 JS 的 bind 方法<i class="fa fa-external-link"></i></span></li></ol><p>如果文章内容有什么错误或者不当之处，欢迎在评论区指出。感谢您的阅读，如果文章对您有所帮助或者启发，不妨点个赞，关注一下呗。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 koa2 服务器实践探究浏览器 HTTP 缓存机制</title>
    <url>/%E9%80%9A%E8%BF%87-koa2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>浏览器 HTTP 缓存是一种常见的 web 性能优化的手段，也是在前端面试中经常被考察的一个知识点。本文通过配置 koa2 服务器，在实践中带你探究浏览器的 HTTP 缓存机制。</p><a id="more"></a><p>先来直观认识一下浏览器 HTTP 缓存：</p><p><img data-src="https://i.loli.net/2019/06/17/5d070499177b444422.png" alt="v2EX首页首次加载"></p><p>上面是打开浏览器后直接访问 V2EX 首页后的截图，矩形圈起来的那块也就是 size 部分显示的都是 <code>from disk cached</code>，说明这些资源命中了强缓存，强缓存的状态码都是 200。</p><p>再来看看我直接访问上面箭头指向的那张图片是什么情况：</p><p><img data-src="https://i.loli.net/2019/06/17/5d070673e1d7c93593.png" alt="演示协商缓存">可以看到返回码是 304，并且请求的时候带上了协商缓存用于协商的两个请求头 if-modified-since 和 if-none-match，命中了协商缓存。可能有部份读者看到这里不太理解我前面提到的强缓存和协商缓存是什么鬼，没关系，看到最后再回过头来看，你就自然能清晰的看懂我上面圈起来的东西和提到的一些不懂术语。</p><h3 id="缓存判断规则是怎么实现的"><a href="#缓存判断规则是怎么实现的" class="headerlink" title="缓存判断规则是怎么实现的"></a>缓存判断规则是怎么实现的</h3><p><strong>其实所有的网络协议都是一套规范，客户端和服务器端是怎么只是按照规范来实现而已</strong>。浏览器 HTTP 缓存也是如此，浏览器在开发的时候便按照 HTTP 缓存规范来开发，我们开发的 HTTP 服务器也应该遵守其规范。当然了，服务器是你自己写的，你完全可以不按规范来，但是浏览器不知道你在搞什么名堂啊，HTTP 缓存肯定不会正常工作了。</p><p>我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为 HTTP 报文。</p><p><img data-src="https://i.loli.net/2019/06/17/5d0756f543e2f45062.png" alt="HTTP报文结构">与缓存相关的规则信息就包含在报文首部中。下面是 chrome network 面板中的信息：</p><p><img data-src="https://i.loli.net/2019/06/18/5d087d429e22146774.png" alt="network报文结构说明"></p><p>浏览器的 HTTP 缓存协议本质上就通过请求响应过程中在首部中携带那些和缓存相关的字段来实现的。</p><h3 id="浏览器-HTTP-缓存的分类"><a href="#浏览器-HTTP-缓存的分类" class="headerlink" title="浏览器 HTTP 缓存的分类"></a>浏览器 HTTP 缓存的分类</h3><p>浏览器 HTTP 缓存分两钟：</p><ol><li>强缓存</li><li>协商缓存</li></ol><p><strong>强缓存</strong>指的是浏览器在本地判定缓存有无过期，未过期直接从内存或磁盘读取缓存，整个过程不需要和服务器通信。</p><p><strong>协商缓存</strong>需要向服务器发送一次协商请求，请求时带上和协商缓存相关的请求头，由服务器判断缓存是否过期，未过期就返回状态码 304，浏览器当发现响应的返回码是 304，也直接是读取本地缓存，如果服务器判定过期就直接返回请求资源和 last-modified，状态码为 200。</p><p>浏览器请求资源时判定缓存的简略流程如下图：</p><p><img data-src="https://i.loli.net/2019/06/17/5d0748842436b59302.png" alt="浏览器 HTTP 缓存判断过程"></p><p>文字解释一下：当浏览器请求一个资源时，浏览器会先从内存中或者磁盘中查看是否有该资源的缓存。如果没有缓存，可能浏览器之前没访问过这个资源或者缓存被清除了那只能向服务器请求该资源。</p><p>如果有缓存，那么就先判断有没有命中强缓存。如果命中了强缓存则直接使用本地缓存。如果没有命中强缓存但是上次请求该资源时返回了和协商缓存相关的响应头如 last-modified 那么就带上和协商缓存相关的请求头发送请求给服务器，根据服务器返回的状态码来判定是否命中了协商缓存，命中了的话是用本地缓存，没有命中则使用请求返回的内容。</p><h4 id="强缓存和协商缓存的区别"><a href="#强缓存和协商缓存的区别" class="headerlink" title="强缓存和协商缓存的区别"></a>强缓存和协商缓存的区别</h4><ol><li>命中时状态码不同。强缓存返回 200，协商缓存返回 304。</li><li>优先级不同。先判定强缓存，强缓存判断失败再判定协商缓存。</li><li>强缓存的收益高于协商缓存，因为协商缓存相对于强缓存多了一次协商请求。</li></ol><h3 id="演示服务器说明"><a href="#演示服务器说明" class="headerlink" title="演示服务器说明"></a>演示服务器说明</h3><p>整个 koa2 演示服务器在这：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9rb2EyLWJyb3dzZXItSFRUUC1jYWNoZQ==" title="https://github.com/tjx666/koa2-browser-HTTP-cache">koa2-browser-HTTP-cache<i class="fa fa-external-link"></i></span>。总共就几个文件，index.js 入口文件，index.html 首页源代码，sunset.jpg 和 style.css 是 index.html 用到的图片和样式。</p><p><img data-src="https://i.loli.net/2019/06/18/5d08b61fe2ee448544.png" alt="目录结构"></p><p>服务器代码代码很简单，使用 koa-router 配了三个路由，目前还没有写缓存相关的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> Path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理首页</span></span><br><span class="line">router.get(<span class="regexp">/(^\/index(.html)?$)|(^\/$)/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">'.html'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">'./index.html'</span>), <span class="string">'UTF-8'</span>);</span><br><span class="line">  ctx.body = content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理图片</span></span><br><span class="line">router.get(<span class="regexp">/\S*\.(jpe?g|png)$/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>));</span><br><span class="line">  ctx.body = imageBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 css 文件</span></span><br><span class="line">router.get(<span class="regexp">/\S*\.css$/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>), <span class="string">'UTF-8'</span>);</span><br><span class="line">  ctx.body = content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'有 promise 没有 catch'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>访问首页后页面长这样的：</p><p><img data-src="https://i.loli.net/2019/06/18/5d08a6aaed4b785068.png" alt="未配置缓存访问首页"></p><p>当前服务器没有配置缓存，可以看到 size 部分显示了资源的大小，如果是命强缓存就会显示 <code>from memory cache</code> 或者 <code>from disk cache</code>。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是 web 性能优化中收益非常高的一种手段。</p><h4 id="强缓存相关的头部字段"><a href="#强缓存相关的头部字段" class="headerlink" title="强缓存相关的头部字段"></a>强缓存相关的头部字段</h4><p>前面说过缓存协议本质上是通过请求响应头来实现的。和强缓存相关的头部字段有以下这些：</p><h5 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1ByYWdtYQ==" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma">pragma<i class="fa fa-external-link"></i></span></h5><p>progma 是 HTTP1.0 时期的产物，和后面要说的 cache-control 作用差不多，它的值只能设置为 <code>no-cache</code>。与 Cache-Control: no-cache 效果一致，即禁用强缓存，只能使用协商缓存。</p><h5 id="expires"><a href="#expires" class="headerlink" title="expires"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGlyZXM=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">expires<i class="fa fa-external-link"></i></span></h5><p>响应头字段，包含日期/时间， 表示资源的过期时间。例如 <code>Thu, 31 Dec 2037 23:55:55 GMT</code>。无效的日期，比如 0，代表着过去的日期，都表明该资源已经过期。</p><p>如果在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener"><code>Cache-Control</code></a>响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 <code>Expires</code> 头会被忽略，也就是说优先级 cacahe-control 大于 expires。</p><p>因为 expires 是一个时间值，如果服务器和客户端是系统时间差较大，就会引起缓存混乱。</p><h5 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NhY2hlLUNvbnRyb2w=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">cache-control<i class="fa fa-external-link"></i></span></h5><p>HTTP 1.1 中增加的字段，被设计用来替代 pragma。cache-control 这个头部字段既可以用在请求头也可以用在响应头中。</p><p>我们都知道在 chrome 中 shift + F5 或者在 network 面板勾选了 disable cache 时浏览器每次加载资源时都会请求最新的资源而不是使用缓存。仔细观察 network 面板的 request headers，发现当禁用缓存后，浏览器每次请求资源时会带上 cache-control: no-cache 来告诉服务器我不需要协商缓存，你直接把最新的资源返回。</p><p>下面是我勾选了禁用缓存之后请求配置了协商缓存的图片的截图：</p><p><img data-src="https://i.loli.net/2019/06/18/5d08b2aa904ec34767.png" alt="禁用缓存"></p><p>cache-control 作为响应头字段其实是对 expires 做了改进，cache-control 其中的一种值形式为 cache-control: max-age=seconds，例如：cache-control: max-age=315360000。seconds 是一个时间差而不是固定的时间，因为是时间差所以不存在上面提到的 expires 的客户端和服务器端时间不同步导致缓存混乱的问题。</p><h4 id="强缓存相关的首部字段的优先级"><a href="#强缓存相关的首部字段的优先级" class="headerlink" title="强缓存相关的首部字段的优先级"></a>强缓存相关的首部字段的优先级</h4><p>pragma &gt; cache-control &gt; expires。</p><h4 id="强缓存的具体流程"><a href="#强缓存的具体流程" class="headerlink" title="强缓存的具体流程"></a>强缓存的具体流程</h4><p>前面讲过浏览器 HTTP 缓存的简略流程，这里具体讲讲<strong>强缓存</strong>的判定过程。</p><p>首先，当浏览器发现了内存或者磁盘有你请求的资源缓存时，此时浏览器还会检查该资源上一次请求时的有没有返回上面叙述的和强缓存相关的响应头。根据上面说的和强缓存相关的首部字段的优先级，一步一步判断。可能有些字段服务器不会返回，比如 pragma，那就直接往后判断。具体就是：如果 pragma: no-cache，那强缓存直接就判断失败了，只能走协商缓存。如果没有 pragma，但是有 cache-control: no-cache，这就和 pragma: no-cache 一样，强缓存判断失败。如果 cache-control: max-age=seconds，那么此时就根据浏览器上次请求该资源的时间和 seconds 算出过期时间，如果早于过期时间也就是未过期，那么命中强缓存，如果过期了强缓存判定失败。前面说过了如果 control-control 值为 max-age 或者 s-max-age 那么 expires 直接就无效了。当 cache-control 值不是那两个或则没有时，还要根据 expires 值也就是过期时间来判定有没有过期，没有过期就命中强缓存，否则，缓存失效，向服务器请求最新资源。</p><h4 id="使用-expires-配置强缓存"><a href="#使用-expires-配置强缓存" class="headerlink" title="使用 expires 配置强缓存"></a>使用 expires 配置强缓存</h4><p>修改 src/index.js 中处理图片的路由，其实就是在响应头中加上了 expires 字段，过期时间为 2 分钟后。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 处理图片</span><br><span class="line">router.get(/\S*\.(jpe?g|png)$/, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; response, path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">    // 添加 expires 字段到响应头，过期时间 2 分钟</span><br><span class="line"><span class="addition">+    response.set('expires', new Date(Date.now() + 2 * 60 * 1000).toString());</span></span><br><span class="line"></span><br><span class="line">    const imageBuffer = await fs.readFile(Path.resolve(__dirname, `.$&#123;path&#125;`));</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line"></span><br><span class="line">    await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一次访问：</p><p><img data-src="https://i.loli.net/2019/06/18/5d09071435c3c54245.png" alt="expires配置强缓存第一次访问"></p><p>注意我上面的箭头指向的地方，鼠标左键长按加载按钮会弹出三个不同的加载选项，尤其是最后一个在开发时很有用，可以清除页面缓存。</p><p>然后立即刷新页面：</p><p><img data-src="https://i.loli.net/2019/06/18/5d0907799f29b67306.png" alt="expires 配置强缓存生效"></p><p>2 分钟后再次刷新又是和第一张图一样，我就不放截图了。可以看出，其实配置强缓存很简单，就是按照协议约定配置响应头。</p><h4 id="测试-pragram，cache-control，-expires-优先级"><a href="#测试-pragram，cache-control，-expires-优先级" class="headerlink" title="测试 pragram，cache-control， expires 优先级"></a>测试 pragram，cache-control， expires 优先级</h4><p>响应头添加 cache-control: no-cache，即不允许使用强缓存。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 处理图片</span><br><span class="line">router.get(/\S*\.(jpe?g|png)$/, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; response, path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line"><span class="addition">+    response.set('cache-control', 'no-cache');</span></span><br><span class="line">    // 添加 expires 字段到响应头，过期时间 2 分钟</span><br><span class="line">    response.set('expires', new Date(Date.now() + 2 * 60 * 1000).toString());</span><br><span class="line"></span><br><span class="line">    const imageBuffer = await fs.readFile(Path.resolve(__dirname, `.$&#123;path&#125;`));</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line"></span><br><span class="line">    await next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 处理 css 文件</span><br><span class="line">router.get(/\S*\.css$/, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">    const content = await fs.readFile(Path.resolve(__dirname, `.$&#123;path&#125;`), 'UTF-8');</span><br><span class="line">    ctx.body = content;</span><br><span class="line"></span><br><span class="line">    await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>设置了 cache-control: no-cache 后，每次刷新都是下面截图一样，浏览器不再使用缓存，如果使用了缓存就会像上面的那张截图一样在 Status Code 部分有说明。得出结论 cache-control 确实优先级比 expires 高。</p><p><img data-src="https://i.loli.net/2019/06/22/5d0e28a42085198392.png" alt=""></p><p>设置 cache-control: max-age=60，理论上效果应该是缓存 1 分钟后失效，事实证明确实如此。</p><p>注意观察下面两张图的 expires 时间，第一张截图显示 21:33 失效。然而，由于 cache-control 优先级更高，所以会提前一分钟过期，所以结果就像第二张图 21:22 分钟缓存就失效了。</p><p><img data-src="https://i.loli.net/2019/06/22/5d0e2e1ac157716766.png" alt="max-age1"></p><p><img data-src="https://i.loli.net/2019/06/22/5d0e2e5095d0115156.png" alt="max-age2"></p><p>再来测试一下 pragma。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 处理图片</span><br><span class="line">router.get(/\S*\.(jpe?g|png)$/, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; response, path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line"><span class="addition">+    response.set('pragma', 'no-cache');</span></span><br><span class="line">    // max-age 值是精确到秒，设置过期时间为 1 分钟</span><br><span class="line">    response.set('cache-control', `max-age=$&#123;1 * 60&#125;`);</span><br><span class="line">    // 添加 expires 字段到响应头，过期时间 2 分钟</span><br><span class="line">    response.set('expires', new Date(Date.now() + 2 * 60 * 1000).toString());</span><br><span class="line"></span><br><span class="line">    const imageBuffer = await fs.readFile(Path.resolve(__dirname, `.$&#123;path&#125;`));</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line"></span><br><span class="line">    await next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 处理 css 文件</span><br><span class="line">router.get(/\S*\.css$/, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">    const content = await fs.readFile(Path.resolve(__dirname, `.$&#123;path&#125;`), 'UTF-8');</span><br><span class="line">    ctx.body = content;</span><br><span class="line"></span><br><span class="line">    await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果和设置 cache-control: no-cache 效果一样，永远不会使用本地缓存。所以结论就是:</p><blockquote><p>pragma &gt; cache-control &gt; expires。</p></blockquote><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存由于需要向服务器发送一次请求，所以相比于强缓存来收收益更低，缓存资源体积越大，收益越高。</p><h4 id="和协商缓存相关的首部字段"><a href="#和协商缓存相关的首部字段" class="headerlink" title="和协商缓存相关的首部字段"></a>和协商缓存相关的首部字段</h4><p>协商缓存中那几个首部字段是<strong>配对使用</strong>的，即：</p><ul><li>请求头 if-modified-since 和响应头 last-modified</li><li>请求头 if-none-match 和响应头 etag</li></ul><h5 id="if-modified-since-和-last-modified"><a href="#if-modified-since-和-last-modified" class="headerlink" title="if-modified-since 和 last-modified"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLU1vZGlmaWVkLVNpbmNl" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">if-modified-since<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xhc3QtTW9kaWZpZWQ=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified">last-modified<i class="fa fa-external-link"></i></span></h5><p>它俩的值都是 GMT 格式的<strong>精确到秒</strong>的时间值。从字面上就很好理解它们的含义：<code>自从某某时间有没有修改过?</code>，<code>最后一次修改时间为某某时间</code>。</p><p>他俩有啥关系呢？其实<strong>本次请求头 if-modified-since 的值应该为上一次请求该资源的响应头中 last-modified 的值</strong>。</p><p>当浏览器发起资源请求并携带 if-modified-since 字段，服务器会将请求头中的 if-modified-since 值和请求资源的 最后修改时间进行比较，如果资源最后修改时间比 if-modified-since 时间晚，那么资源过期，状态码为 200，响应体为请求资源，响应头中加入最新的 last-modified 的值。没过期就返回状态码 304，命中协商缓存，响应体为空，响应头不需要 last-modified 值。</p><h5 id="if-none-match-和响应头-etag"><a href="#if-none-match-和响应头-etag" class="headerlink" title="if-none-match 和响应头 etag"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLU5vbmUtTWF0Y2g=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">if-none-match<i class="fa fa-external-link"></i></span> 和响应头 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0VUYWc=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag">etag<i class="fa fa-external-link"></i></span></h5><p>上面两个是 HTTP 1.0 中处理协商缓存的首部字段，这两个是 HTTP 1.1 才出现的。</p><p>这里我总结下 MDN 中对 if-none-match 的描述的几个重点（这里只讨论 GET 请求资源）：</p><ol><li>当且仅当服务器上没有任何资源的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener"><code>ETag</code></a> 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200。</li><li>服务器端在生成状态码为 304 的响应的时候，会存在于对应的 200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。</li><li>If-none-match 优先级比 if-modified-since 优先级高。</li></ol><p>etag 常见的样子是 <code>etag: &quot;54984c2b-44e&quot;</code>。和上面那对一样，<strong>本次请求头 if-none-match 的值为上一次请求该资源的响应头中 etag 的值</strong>。</p><p>有人可能看到这里会问：etag 到底是个啥玩意？如果你了解哈希摘要我觉得就很好理解了，etag 表示的是所请求资源的唯一标识符，简单来实现就是给请求的资源通过某种 hash 算法取个摘要字符串然后用双引号包起来就好了。</p><p>MDN 上对 etag 的描述是：</p><blockquote><p>它们是位于双引号之间的 ASCII 字符串（如“675af34563dc-tr34”）。 没有明确指定生成 ETag 值的方法。 通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。 例如，MDN 使用 wiki 内容的十六进制数字的哈希值。</p></blockquote><p>使用 if-none-match/etag 这对头部字段来处理协商缓存的过程和 if-modified-since/etag 其实是差不多。只不过比较的是 hash 值而不是日期。</p><h4 id="为什么有了-last-modified-还需要-etag-？"><a href="#为什么有了-last-modified-还需要-etag-？" class="headerlink" title="为什么有了 last-modified 还需要 etag ？"></a>为什么有了 last-modified 还需要 etag ？</h4><ol><li>资源在 1 秒内更新，并且在该一秒内访问，使用 last-modified 处理协商缓存无法获取最新资源。本质上的原因还是因为 last-modified 是精确到秒的，无法反映在 1 秒内的变化。</li><li>当资源多次被修改后内容不变，使用 last-modified 来处理有点浪费。多次修改资源，其 last-modified 值肯定是会变的，但是如果内容不变我们其实不需要服务器返回最新资源，直接使用本地缓存。使用 etag 就没这个问题，因为同一个资源多次修改，内容一样， hash 值也一样。</li><li>使用 etag 更加灵活，因为 etag 并不一定是我说的就用 hash 值，etag 采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。</li></ol><h4 id="协商缓存首部字段优先级"><a href="#协商缓存首部字段优先级" class="headerlink" title="协商缓存首部字段优先级"></a>协商缓存首部字段优先级</h4><p><strong>if-none-match &gt; if-modified-since</strong>。</p><p>当服务器收到的请求中同时包含 if-modified-since 和 if-none-match 时，服务器会忽略 if-modified-since。</p><h4 id="测试-last-modified-配置协商缓存"><a href="#测试-last-modified-配置协商缓存" class="headerlink" title="测试 last-modified 配置协商缓存"></a>测试 last-modified 配置协商缓存</h4><p>写到这里时，笔者稍微重构了下服务器代码并使用 last-modified 配置了协商缓存：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> Path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responseFile = <span class="keyword">async</span> (path, context, encoding) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileContent = <span class="keyword">await</span> fs.readFile(path, encoding);</span><br><span class="line">  context.type = mime.getType(path);</span><br><span class="line">  context.body = fileContent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理首页</span></span><br><span class="line">router.get(<span class="regexp">/(^\/index(.html)?$)|(^\/$)/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> responseFile(Path.resolve(__dirname, <span class="string">'./index.html'</span>), ctx, <span class="string">'UTF-8'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理图片</span></span><br><span class="line">router.get(<span class="regexp">/\S*\.(jpe?g|png)$/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; request, response, path &#125; = ctx;</span><br><span class="line">  response.set(<span class="string">'pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// max-age 值是精确到秒，设置过期时间为 1 分钟</span></span><br><span class="line">  <span class="comment">// response.set('cache-control', `max-age=$&#123;1 * 60&#125;`);</span></span><br><span class="line">  <span class="comment">// 添加 expires 字段到响应头，过期时间 2 分钟</span></span><br><span class="line">  <span class="comment">// response.set('expires', new Date(Date.now() + 2 * 60 * 1000).toString());</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> ifModifiedSince = request.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">  <span class="keyword">const</span> imageStatus = <span class="keyword">await</span> fs.stat(imagePath);</span><br><span class="line">  <span class="keyword">const</span> lastModified = imageStatus.mtime.toGMTString();</span><br><span class="line">  <span class="keyword">if</span> (ifModifiedSince === lastModified) &#123;</span><br><span class="line">    response.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.lastModified = lastModified;</span><br><span class="line">    <span class="keyword">await</span> responseFile(imagePath, ctx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 css 文件</span></span><br><span class="line">router.get(<span class="regexp">/\S*\.css$/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  <span class="keyword">await</span> responseFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>), ctx, <span class="string">'UTF-8'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'有 promise 没有 catch'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先是禁用缓存情况下首次访问，可以看到请求头中没有 if-modified-since，服务器返回了 last-modified。</p><p><img data-src="https://i.loli.net/2019/06/23/5d0f7bf17fe8b85005.png" alt=""></p><p>关闭 disable cache 后再次访问图片时，发现带上了 if-modified-since 请求头，值就是上次请求响应的 last-modified 值，因为图片最后修改时间不变，所以 304 Not Modified,。其实上面的代码有点小毛病，在 if-modified-since 不等于 last-modified 时没有设置 content-type，不过这些细节不影响我们探讨协商缓存核心知识。</p><p><img data-src="https://i.loli.net/2019/06/23/5d0f7d383c8c222295.png" alt="last-modified"></p><p>当我把 sunset.jpg 这张图替换成另外一张图后，图片最后修改时间改变了，所以返回了新的图片并且响应头中还加入了最新的 last-modified，下次请求带上的 if-modified-since 就是这次返回后的 last-modified 了。</p><p><img data-src="https://i.loli.net/2019/06/23/5d0f7e780cc7448744.png" alt=""></p><h4 id="测试使用-etag-配置协商缓存"><a href="#测试使用-etag-配置协商缓存" class="headerlink" title="测试使用 etag 配置协商缓存"></a>测试使用 etag 配置协商缓存</h4><p>修改处理图片的路由：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理图片</span></span><br><span class="line">router.get(<span class="regexp">/\S*\.(jpe?g|png)$/</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; request, response, path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line">  response.set(<span class="string">'pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ifNoneMatch = request.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">  <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line">  <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(imagePath);</span><br><span class="line">  hash.update(imageBuffer);</span><br><span class="line">  <span class="keyword">const</span> etag = <span class="string">`"<span class="subst">$&#123;hash.digest(<span class="string">'hex'</span>)&#125;</span>"`</span>;</span><br><span class="line">  <span class="keyword">if</span> (ifNoneMatch === etag) &#123;</span><br><span class="line">    response.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.set(<span class="string">'etag'</span>, etag);</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里就不放图了，效果和使用 last-modified 差不多。</p><p><strong>注意</strong>：我这里的代码只是为了达到演示的目的，如果是真正要配置一个用于生产的缓存机制，是会对资源的 last-modified 和 etag 值建立索引缓存的，而不是像我代码中那样每次都去访问文件状态和读取文件通过 hash 算法取 hash 值。</p><h3 id="怎样更新配置了强缓存的资源？"><a href="#怎样更新配置了强缓存的资源？" class="headerlink" title="怎样更新配置了强缓存的资源？"></a>怎样更新配置了强缓存的资源？</h3><p>之前面春招实习的时候我在面试腾讯的时候某次 2 面被问过这个问题，然后答不上上来，被挂了。那次面试感觉难度挺大的，影响比较深刻，当时还问了怎样做 dns 优化，也答的不好，日后抽空一定会写一篇怎么做 dns 优化的文章。</p><p>更新强缓存这个问题，要是以前没研究过，突然问你，确实有点难。其实想想看，你要更新强缓存，如果请求的是同一个 url，浏览器肯定在没过期的情况下会直接返回缓存了。所以解决办法就是页面中需要更新强缓存的地方对他们的 url 做文章，也就是需要更新强缓存的时候更新 url 就可以了。因为需要可以更新 url，所以当前页面那么就不能使用强缓存了，不然咋更新 url。具体咋更新 url 有很多形式比如使用版本号： “/v1-0-0/sunset.jpg”，还可以在 url 中插入资源内容的 hash 值: “/5bed2702-557a-sunset.jpg”。</p><p>举个实例：</p><p>第一次访问首页 index.html 中 img 标签的 src 为 “/v1-0-0/sunset.jpg”，当服务器上修改了 sunset.jpg 为另外一张图片时。</p><p>再次访问 index.html。由于 index.html 本身这个 html 文件没有使用强缓存，每次访问都需要请求服务器，页面中 src 被修改为了 “/v1-0-1/sunset.jpg”，这张配置强缓存的图片就更新过来了。</p><p>最后放一张盗来的图，本人实在不擅长画图(。&gt;︿&lt;)_θ，这张图比较详细的展示了强缓存和协商缓存的判定流程。</p><p><img data-src="https://i.loli.net/2019/06/23/5d0f938d920a328031.png" alt="summary"></p><p>感谢您的阅读，如果对你有所帮助不妨加个关注，点个赞支持一下 O(∩_∩)O，如果文中有什么错误，欢迎在评论区指出。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p><p>参考资源：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmRlYWJiYmU1MWQ0NTA1NDY2Y2Q3NDE=" title="https://juejin.im/post/5bdeabbbe51d4505466cd741">浅谈 HTTP 缓存<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjNjODczODZmYjlhMDRmOWE1Y2IwMzc=" title="https://juejin.im/post/5b3c87386fb9a04f9a5cb037">面试精选之 http 缓存<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdHVnZW5odWEwNzA3L3AvMTA4MDcyODkuaHRtbA==" title="https://www.cnblogs.com/tugenhua0707/p/10807289.html">理解 http 浏览器的协商缓存和强制缓存<i class="fa fa-external-link"></i></span></li></ol>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 react + typescript + ant design 开发环境</title>
    <url>/%E6%90%AD%E5%BB%BA-react-typescript-ant-design-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>9102 年了，前端工程化发展在 nodejs 的基础上已经发展的非常完善了，各种前端构建辅助工具层出不穷。ES6 编译器 babel，css 辅助工具 postcss / sass / less，代码风格检测工具 eslint / prettier / stylelint，git 辅助工具 husky / lint-staged / commitizen / commitlint，自动化构建工具 webpack / gulp / grunt，测试工具 jest / mocha 等等。</p><p>这么多开发辅助工具每次写项目都去配置一遍那也太浪费时间了，自己维护一套模板有得时不时去更新。比较方便的配置开发环境还是使用 cli 或者一些热门的 bolierplate。本篇文章将以 react 官方维护的 cli 工具 create-react-app （简称 cra）为基础，以不 eject 的方式去配置 ant design，以及一些 cra 并没有内置的辅助工具。</p><a id="more"></a><h2 id="初始化项目并添加-typescript-支持"><a href="#初始化项目并添加-typescript-支持" class="headerlink" title="初始化项目并添加 typescript 支持"></a>初始化项目并添加 typescript 支持</h2><p>Typescript 在近两年以惊人的速度被越来越多的开发者和开源项目所采用，我在使用 typescript 开发了一个项目之后也被 typescript 圈粉了。使用 typescript 开发带来的智能提示可以很大程度上杜绝手贱的发生，大多数情况我们都不需要查文档了，以及 typescript 中的一些 javascript 中没有的语法特性如枚举，使得项目组织可以非常的优雅。从 angular2 默认使用 typescript 开发，到如今 vue3 使用 typescript 重写也能看出 typescript 在前端界的地位将越来越重要。9102，除非是非常小的项目，否则上 typescript 绝对是明智之举。</p><p>我的开发环境：</p><blockquote><p>node: 10.15.3 LTS</p><p>yarn: 1.15.2</p><p>editor: visual studio code</p></blockquote><p>cra 内置了 typescript 支持，只需要在初始化项目时指定 <code>--typescript</code> 参数即可。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app --typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">yarn create react-app my-app --typescript</span><br></pre></td></tr></table></figure><p>如果 cra 项目已经存在，先安装以下 ts types 依赖：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save typescript @types/node @types/react @types/react-dom @types/jest</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">yarn add typescript @types/node @types/react @types/react-dom @types/jest</span><br></pre></td></tr></table></figure><p>然后将 .js 结尾的文件重命名为 .tsx 即可。</p><p>更多关于在 cra 中使用 ts 的信息查看官方文档：<span class="exturl" data-url="aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vY3JlYXRlLXJlYWN0LWFwcC9kb2NzL2FkZGluZy10eXBlc2NyaXB0" title="https://facebook.github.io/create-react-app/docs/adding-typescript">Adding TypeScript<i class="fa fa-external-link"></i></span></p><h2 id="配置-ant-design"><a href="#配置-ant-design" class="headerlink" title="配置 ant design"></a>配置 ant design</h2><h3 id="安装-ant-design-依赖"><a href="#安装-ant-design-依赖" class="headerlink" title="安装 ant design 依赖"></a>安装 ant design 依赖</h3><p>现在从 yarn 或 npm 安装并引入 antd。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add antd</span><br></pre></td></tr></table></figure><h3 id="配置-ant-design-css-按需加载"><a href="#配置-ant-design-css-按需加载" class="headerlink" title="配置 ant design css 按需加载"></a>配置 ant design css 按需加载</h3><p>配置 css 按需加载的方式有很多，归根到底就是修改 cra 的 webpack 配置。可以采用暴露 cra webpack 配置的方式，使用 <code>yarn eject</code> 命令即可在项目根目录下暴露出项目的 webpack 配置，配置保存在 config 文件夹下面。我记得 cra 早期版本 eject 之后暴露的配置是拆分成两份 <code>webpack.config.dev.js</code>，<code>webpack.config.prod.js</code>。最新的 cra 配置被合并到一个配置文件里面了，就一个配置文件，通过一个计算出的环境（development/producation）来动态生成 webpack 配置，这种方式我觉得配置起来更麻烦了，而且 eject 是不可逆的，采用 eject 来修改 webpack 配置需要慎重考虑。这种方式的好处就是 webpack 配置你可以直接修改，所以基本上没什么配置不能通过这种方式来加载。</p><p>这里我采用社区的 cra 配置解决方案：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpbWFybmV5L3JlYWN0LWFwcC1yZXdpcmVk" title="https://github.com/timarney/react-app-rewired">react-app-rewired<i class="fa fa-external-link"></i></span>。</p><p>引入 react-app-rewired 并修改 package.json 里的启动配置。由于新的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpbWFybmV5L3JlYWN0LWFwcC1yZXdpcmVkI2FsdGVybmF0aXZlcw==" title="https://github.com/timarney/react-app-rewired#alternatives">react-app-rewired@2.x<i class="fa fa-external-link"></i></span> 版本的关系，你还需要安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FyYWNrYWYvY3VzdG9taXplLWNyYQ==" title="https://github.com/arackaf/customize-cra">customize-cra<i class="fa fa-external-link"></i></span>。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add react-app-rewired customize-cra</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/* package.json */</span><br><span class="line">"scripts": &#123;</span><br><span class="line"><span class="deletion">-   "start": "react-scripts start",</span></span><br><span class="line"><span class="addition">+   "start": "react-app-rewired start",</span></span><br><span class="line"><span class="deletion">-   "build": "react-scripts build",</span></span><br><span class="line"><span class="addition">+   "build": "react-app-rewired build",</span></span><br><span class="line"><span class="deletion">-   "test": "react-scripts test",</span></span><br><span class="line"><span class="addition">+   "test": "react-app-rewired test",</span></span><br><span class="line">	"eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录新建 <code>config</code> 文件夹，并在 package.json 中添加配置：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"config-overrides-path": "config/config-overrides.js"</span><br></pre></td></tr></table></figure><p>然后再在其中创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-babel-plugin-import"><a href="#使用-babel-plugin-import" class="headerlink" title="使用 babel-plugin-import"></a>使用 babel-plugin-import</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYmFiZWwtcGx1Z2luLWltcG9ydA==" title="https://github.com/ant-design/babel-plugin-import">babel-plugin-import<i class="fa fa-external-link"></i></span> 是一个用于按需加载组件代码和样式的 babel 插件（<span class="exturl" data-url="aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvZ2V0dGluZy1zdGFydGVkLWNuI+aMiemcgOWKoOi9vQ==" title="https://ant.design/docs/react/getting-started-cn#按需加载">原理<i class="fa fa-external-link"></i></span>），现在我们尝试安装它并修改 <code>config-overrides.js</code> 文件。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">$ yarn add babel-plugin-import</span><br><span class="line"><span class="addition">+ const &#123; override, fixBabelImports &#125; = require('customize-cra');</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- module.exports = function override(config, env) &#123;</span></span><br><span class="line"><span class="deletion">-   // do stuff with the webpack config...</span></span><br><span class="line"><span class="deletion">-   return config;</span></span><br><span class="line"><span class="deletion">- &#125;;</span></span><br><span class="line"><span class="addition">+ module.exports = override(</span></span><br><span class="line"><span class="addition">+   fixBabelImports('import', &#123;</span></span><br><span class="line"><span class="addition">+     libraryName: 'antd',</span></span><br><span class="line"><span class="addition">+     libraryDirectory: 'es',</span></span><br><span class="line"><span class="addition">+     style: 'css',</span></span><br><span class="line"><span class="addition">+   &#125;),</span></span><br><span class="line"><span class="addition">+ );</span></span><br></pre></td></tr></table></figure><p>按下面的格式引入 ant design 组件。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  // src/App.js</span><br><span class="line">  import React, &#123; Component &#125; from 'react';</span><br><span class="line"><span class="deletion">- import Button from 'antd/lib/button';</span></span><br><span class="line"><span class="addition">+ import &#123; Button &#125; from 'antd';</span></span><br><span class="line">  import './App.css';</span><br><span class="line"></span><br><span class="line">  class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div className="App"&gt;</span><br><span class="line">          &lt;Button type="primary"&gt;Button&lt;/Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  export default App;</span><br></pre></td></tr></table></figure><p>最后重启 <code>yarn start</code> 访问页面，antd 组件的 js 和 css 代码都会按需加载，你在控制台也不会看到这样的<span class="exturl" data-url="aHR0cHM6Ly96b3MuYWxpcGF5b2JqZWN0cy5jb20vcm1zcG9ydGFsL3ZnY0hKUlZaRm1QakFhd3dWb1hLLnBuZw==" title="https://zos.alipayobjects.com/rmsportal/vgcHJRVZFmPjAawwVoXK.png">警告信息<i class="fa fa-external-link"></i></span>。关于按需加载的原理和其他方式可以阅读<span class="exturl" data-url="aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvZ2V0dGluZy1zdGFydGVkLWNuI+aMiemcgOWKoOi9vQ==" title="https://ant.design/docs/react/getting-started-cn#按需加载">这里<i class="fa fa-external-link"></i></span>。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>按照 <span class="exturl" data-url="aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvY3VzdG9taXplLXRoZW1lLWNu" title="https://ant.design/docs/react/customize-theme-cn">配置主题<i class="fa fa-external-link"></i></span> 的要求，自定义主题需要用到 less 变量覆盖功能。我们可以引入 <code>customize-cra</code> 中提供的 less 相关的函数 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FyYWNrYWYvY3VzdG9taXplLWNyYSNhZGRsZXNzbG9hZGVybG9hZGVyb3B0aW9ucw==" title="https://github.com/arackaf/customize-cra#addlessloaderloaderoptions">addLessLoader<i class="fa fa-external-link"></i></span> 来帮助加载 less 样式，同时修改 <code>config-overrides.js</code> 文件如下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add less less-loader</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- const &#123; override, fixBabelImports &#125; = require('customize-cra');</span></span><br><span class="line"><span class="addition">+ const &#123; override, fixBabelImports, addLessLoader &#125; = require('customize-cra');</span></span><br><span class="line"></span><br><span class="line">module.exports = override(</span><br><span class="line">  fixBabelImports('import', &#123;</span><br><span class="line">    libraryName: 'antd',</span><br><span class="line">    libraryDirectory: 'es',</span><br><span class="line"><span class="deletion">-   style: 'css',</span></span><br><span class="line"><span class="addition">+   style: true,</span></span><br><span class="line">  &#125;),</span><br><span class="line"><span class="addition">+ addLessLoader(&#123;</span></span><br><span class="line"><span class="addition">+   javascriptEnabled: true,</span></span><br><span class="line"><span class="addition">+   modifyVars: &#123; '@primary-color': '#1DA57A' &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;),</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里利用了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svbGVzcy1sb2FkZXIjbGVzcy1vcHRpb25z" title="https://github.com/webpack/less-loader#less-options">less-loader<i class="fa fa-external-link"></i></span> 的 <code>modifyVars</code> 来进行主题配置， 变量和其他配置方式可以参考 <span class="exturl" data-url="aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvY3VzdG9taXplLXRoZW1lLWNu" title="https://ant.design/docs/react/customize-theme-cn">配置主题<i class="fa fa-external-link"></i></span> 文档。</p><p>修改后重启 <code>yarn start</code>。</p><h2 id="添加-sass-支持"><a href="#添加-sass-支持" class="headerlink" title="添加 sass 支持"></a>添加 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2Fzcy5oay8=" title="https://www.sass.hk/">sass<i class="fa fa-external-link"></i></span> 支持</h2><p><span class="exturl" data-url="bWFpbHRvOnJlYWN0LXNjcmlwdHNAMi4wLjA=" title="mailto:react-scripts@2.0.0">react-scripts@2.0.0<i class="fa fa-external-link"></i></span> 内置了 sass 支持，我们只需要安装 node-sass 依赖即可。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add node-sass</span><br></pre></td></tr></table></figure><p>然后就可以把项目模板中的 css 文件后缀改成 <code>.scss</code> 了。注意是 <code>.scss</code> 不是 <code>.sass</code> 哦，<code>.sass</code> 是 yml 的写法。</p><h2 id="添加-editorconfig"><a href="#添加-editorconfig" class="headerlink" title="添加 editorconfig"></a>添加 <span class="exturl" data-url="aHR0cHM6Ly9lZGl0b3Jjb25maWcub3JnLw==" title="https://editorconfig.org/">editorconfig<i class="fa fa-external-link"></i></span></h2><p>editorconfig 帮助我们约束多个开发者在同一个项目中代码风格，更重要的是它是跨编辑器，IDE 的。</p><p>在 vscode 中使用时可以安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VkaXRvcmNvbmZpZy9lZGl0b3Jjb25maWctdnNjb2Rl" title="https://github.com/editorconfig/editorconfig-vscode">EditorConfig for VS Code<i class="fa fa-external-link"></i></span> 插件，然后 <code>ctrl + shift + p</code> 调出命令面板，输入 <code>editorconfig</code> 就可以看到 <code>Generator .editorconfig</code> 命令，选择命令后根目录就会生成初始的 <code>.editorconfig</code> 文件。</p><h2 id="添加-nvmrc"><a href="#添加-nvmrc" class="headerlink" title="添加 nvmrc"></a>添加 nvmrc</h2><p>在项目根目录创建文件 <code>.nvmrc</code>，再将 <code>node -v</code> 的结果复制进去就可以了。或者直接在项目根目录执行下面的命令。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node -v &gt; .nvmrc</span><br></pre></td></tr></table></figure><h2 id="添加-gitignore"><a href="#添加-gitignore" class="headerlink" title="添加 .gitignore"></a>添加 .gitignore</h2><p>cra 默认已经帮我们添加了 <code>.gitignore</code>，我们可以再添加一些比如 <code>src/assets/videos/*</code>。使用 vscode 的插件 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWNvZGV6b21iaWVjaC5naXRpZ25vcmU=" title="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore">gitignore<i class="fa fa-external-link"></i></span> 我们可以很方便的追加其它要忽略的文件，比如可以选择再添加 <code>VisualStudioCode</code>，<code>Windows</code> 的忽略文件。</p><p><img data-src="https://i.loli.net/2019/05/11/5cd6c95ba52a1.gif" alt="gitignore"></p><h2 id="配置-linters"><a href="#配置-linters" class="headerlink" title="配置 linters"></a>配置 linters</h2><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a><span class="exturl" data-url="aHR0cHM6Ly9jbi5lc2xpbnQub3JnLw==" title="https://cn.eslint.org/">ESLint<i class="fa fa-external-link"></i></span></h3><p>ESLint 可以约束团队成员的代码风格，并且找出一些容易产生问题的代码。vscode 中安装 ESLint 后可以在 <code>PROBLEMS</code> 面板中看到 ESLint 提示的各种错误。ESLint 自带的 <code>autoFix</code> 也挺好用的，不过我一般会直接让 <code>prettier</code> 去在提交代码时格式化一遍。</p><p>cra 默认集成了 ESLint，要让编辑器正确提示 ESLint 错误，需要在项目根目录添加 <code>.eslintrc.json</code>。内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"react-app"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让 vscode 的 eslint 插件启用 typescript 支持，需要添加下面的配置到 <code>.vscode/settings.json</code> 中。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"javascript"</span>,</span><br><span class="line">    <span class="string">"javascriptreact"</span>,</span><br><span class="line">    &#123; <span class="attr">"language"</span>: <span class="string">"typescript"</span>, <span class="attr">"autoFix"</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"language"</span>: <span class="string">"typescriptreact"</span>, <span class="attr">"autoFix"</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集成-prettier"><a href="#集成-prettier" class="headerlink" title="集成 prettier"></a>集成 <span class="exturl" data-url="aHR0cHM6Ly9wcmV0dGllci5pby8=" title="https://prettier.io/">prettier<i class="fa fa-external-link"></i></span></h3><blockquote><p>Prettier is an opinionated code formatter</p></blockquote><p>opinionated 有武断，自以为是的意思，这里应该理解为 prettier 提供的配置很少，有点强制约定代码风格的意思。</p><p>使用 prettier 来格式化我们的代码建议在 git commit 时自动触发就好了，要给 git 设置钩子，我们可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2h1c2t5" title="https://github.com/typicode/husky">husky<i class="fa fa-external-link"></i></span> 工具。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add -D husky lint-staged prettier</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29rb25ldC9saW50LXN0YWdlZA==" title="https://github.com/okonet/lint-staged">lint-staged<i class="fa fa-external-link"></i></span> 是一个提高 lint 工具速度的工具，他的作用就和它的名字一样，lint-staged 可以让 lint 工具只 lint 保存在 stage 区的代码，从而加快 lint 速度。</p><p>接着配置 husky 和 lint-staged。在 package.json 中加入下面内容。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "lint-staged"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "lint-staged": &#123;</span><br><span class="line">    "src/**/*.&#123;js,jsx,ts,tsx,json,css,scss,md&#125;": [</span><br><span class="line">      "prettier --single-quote --write",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>如果还需要配置 prettier，在项目根目录添加配置文件 .prettierrc.js。就像前面叙述的，prettier 可以配置的选项很少。内容如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prettier.config.js or .prettierrc.js</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    trailingComma: "es5",</span><br><span class="line">    tabWidth: 4,</span><br><span class="line">    semi: false,</span><br><span class="line">    singleQuote: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="集成-stylelint"><a href="#集成-stylelint" class="headerlink" title="集成 stylelint"></a>集成 <span class="exturl" data-url="aHR0cHM6Ly9zdHlsZWxpbnQuaW8v" title="https://stylelint.io/">stylelint<i class="fa fa-external-link"></i></span></h3><p>stylelint 我主要参考了 ant design 的配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add -D stylelint</span><br></pre></td></tr></table></figure><p>在根目录添加 stylelint 配置文件 <code>.stylelintrc.json</code> 或者 package 添加字段 “stylelint”，内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"stylelint-config-standard"</span>, <span class="string">"stylelint-config-rational-order"</span>, <span class="string">"stylelint-config-prettier"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"stylelint-order"</span>, <span class="string">"stylelint-declaration-block-no-ignored-properties"</span>],</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"comment-empty-line-before"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"function-name-case"</span>: [<span class="string">"lower"</span>],</span><br><span class="line">    <span class="attr">"no-invalid-double-slash-comments"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"no-descending-specificity"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"declaration-empty-line-before"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ignoreFiles"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装上面配置中使用的插件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add -D stylelint-config-standard stylelint-config-rational-order stylelint-config-prettier stylelint-order stylelint-declaration-block-no-ignored-properties</span><br></pre></td></tr></table></figure><p>修改 lint-staged 配置为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"lint-staged": &#123;</span><br><span class="line">    "src/**/*.&#123;js,jsx,ts,tsx,json,css,scss,md&#125;": [</span><br><span class="line">      "prettier --single-quote --write",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ],</span><br><span class="line">    "src/**/*.css": "stylelint",</span><br><span class="line">    "src/**/*.scss": "stylelint --syntax=scss"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="配置-commitlint"><a href="#配置-commitlint" class="headerlink" title="配置 commitlint"></a>配置 commitlint</h2><p>推荐一个可以实现规范的<strong>提交说明</strong>的工具：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRmNvbW1pdGl6ZW4lMkZjei1jbGk=" title="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcommitizen%2Fcz-cli">commitizen/cz-cli<i class="fa fa-external-link"></i></span>。全局安装该工具：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn global add commitizen</span><br></pre></td></tr></table></figure><p>该工具的使用方式可以文章最后的提交代码时的 GIF 图。使用时输入 <code>git cz</code> 即可。</p><p>安装校验工具 @commitlint/cli。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/cli</span><br></pre></td></tr></table></figure><p>安装符合 Angular 风格的校验规则。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add -D @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>package.json 添加 “commitlint” 字段并设置：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"commitlint": &#123;</span><br><span class="line">    "extends": [</span><br><span class="line">      <span class="string">"@commitlint/config-conventional"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json 中 husky 配置修改为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"husky": &#123;</span><br><span class="line">        "hooks": &#123;</span><br><span class="line">            "pre-commit": "lint-staged",</span><br><span class="line">            "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="调整模板"><a href="#调整模板" class="headerlink" title="调整模板"></a>调整模板</h2><p>这篇文章是我边配置我的一个项目边写的，下面部分有些内容是根据我这个项目技术栈来配置的，后面的内容自行斟酌按需配置。比如我打算用 react hooks 写项目，那么可以安装 react-use 这个工具库，不打算使用 react hooks 就不要安装了。</p><h3 id="添加常用文件夹"><a href="#添加常用文件夹" class="headerlink" title="添加常用文件夹"></a>添加常用文件夹</h3><p>项目根目录添加 docs 文件夹用来放文档。在 src 目录下添加 assets（存放资源），components（放组件），pages（页面组件），stores（状态管理工具相关的文件），models（typescript 类或者接口），utils，styles（全局样式主题等） 这几个文件夹。assets 文件夹下面还有 images，videos 等，components 和 pages 目录下加入 index.tsx 用来导出所有 component 和 page。</p><h3 id="删除无用文件和内容"><a href="#删除无用文件和内容" class="headerlink" title="删除无用文件和内容"></a>删除无用文件和内容</h3><p>public/manifest.json 是用来做 PWA 的，不搞 PWA 可以删掉。修改 public/index.html 中的首页标题。App.scss 中的内容可以全删了。src/logo.svg 可以删了。删除 App.tsx 的无用代码。cra 生成的默认 README.md 中的内容也全删了，加入自己的项目描述。</p><h3 id="替换网站图标-favicon-ico"><a href="#替换网站图标-favicon-ico" class="headerlink" title="替换网站图标 favicon.ico"></a>替换网站图标 favicon.ico</h3><p>推荐使用 <span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzg5YTcyOWE0MDEwMnh1eTMuaHRtbA==" title="http://blog.sina.com.cn/s/blog_89a729a40102xuy3.html">iconfx<i class="fa fa-external-link"></i></span> 工具制作 ico 格式的图标。iconfx 使用方式很简单，打开软件就会用。可以直接将图片转成 ico 格式的图标。将制作好的图标替换 public/favicon.ico 即可设置好网站图标。</p><h3 id="添加其它依赖"><a href="#添加其它依赖" class="headerlink" title="添加其它依赖"></a>添加其它依赖</h3><p>安装 react-router-dom，classnames，lodash，react-use，constate，faker.js 等工具库和对应的 types 文件，有些自带了类型声明的库就不用安装 types 了。像 react-use 和 constate 本身就是 typescript 编写的就不用安装对应的 types 了。安装 normalize.css 并在 index.tsx 直接导入。</p><p>做到这里，我的项目的开发环境算是配置好了,然后就可以进行业务开发了。</p><p>我的一个完全按照上述步骤配置的项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9taW5pLXNob3A=" title="https://github.com/tjx666/mini-shop">mini-shop<i class="fa fa-external-link"></i></span>。有需要可以直接去看我的配置，一般来说配置不会经常改动。</p><p>看看配置了上面那些工具提交代码时是啥样子的：</p><p><img data-src="https://i.loli.net/2019/05/11/5cd6dc5b8c31f.gif" alt="commit"></p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p><p>参考资料：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vY3JlYXRlLXJlYWN0LWFwcC9kb2NzL2dldHRpbmctc3RhcnRlZA==" title="https://facebook.github.io/create-react-app/docs/getting-started">create-react-app 官方文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvdXNlLXdpdGgtY3JlYXRlLXJlYWN0LWFwcC1jbg==" title="https://ant.design/docs/react/use-with-create-react-app-cn">在 create-react-app 中使用 ant design<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2M0Njk0YTZmYjlhMDMyMzgxMDZlYjk=" title="https://juejin.im/post/5cc4694a6fb9a03238106eb9">Cz 工具集使用介绍 - 规范 Git 提交说明<i class="fa fa-external-link"></i></span></li></ol>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
        <tag>webpack</tag>
        <tag>ant design</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用操作</title>
    <url>/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>这几天电脑总是蓝屏，有时候重启时还显示找不到系统，然后多重启几次又正常进入系统。昨天电脑蓝屏重启不下十次，忍无可忍，无须再忍，只好重装系统，换上了最新的 win10 1903。1903 在用户界面上做了挺多优化，窗口阴影，浅色主题，磨砂锁屏等，还有 windows 沙盒等新玩意。</p><p>但是换了之后还是会蓝屏重启，说明是硬件的问题。怀疑是主板有问题，平时用的是笔记本自带的键盘，很容易进灰，有时候边看视频边吃饭的时候可能进了些菜水什么的。今天把电脑后盖拆了之后清了清灰，用吹风机对着自带键盘吹了半天热风，再次重新装了系统。一天下来，啥也没干，装各种软件，配环境，用到现在也没蓝屏，不知道能持续几天。这不，现在要重新配下 git，顺便写篇文章记录一下，省的以后重新配的时候还要到处查资料。</p><a id="more"></a><h2 id="全局配置用户名和邮箱"><a href="#全局配置用户名和邮箱" class="headerlink" title="全局配置用户名和邮箱"></a>全局配置用户名和邮箱</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户名</span></span><br><span class="line">git config --global user.name <span class="string">'your name'</span></span><br><span class="line"><span class="comment"># 配置全局邮箱</span></span><br><span class="line">git config --global user.email <span class="string">'your email address'</span></span><br></pre></td></tr></table></figure><p>这里顺便说个之前碰到的一个很迷的问题。之前我发现我 github 的 <code>contributions</code> 一直没有计算我最近的 commit，只有零星几个绿点。当时我就发了个邮件向 github 团队求助，github 团队挺给力的，很快就给我说明了情况，说是计算用户的 commit 是和你提交数据中的邮箱账号相关的。也就是说判断一次提交是否是某个 github 用户的提交是看<strong>该用户绑定的邮箱是否和 commit 用户的邮箱是相同的</strong>。然后我就把我 github 绑定了我本地 git 配置的邮箱，之前的提交都重新算到我的 github 账号上了。</p><h2 id="生成非对称密钥对"><a href="#生成非对称密钥对" class="headerlink" title="生成非对称密钥对"></a>生成非对称密钥对</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 各个参数含义</span></span><br><span class="line">$ ssh-keygen --<span class="built_in">help</span></span><br><span class="line">ssh-keygen: unknown option -- -</span><br><span class="line">usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]</span><br><span class="line">                  [-N new_passphrase] [-C comment] [-f output_keyfile]</span><br><span class="line">       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">       ssh-keygen -i [-m key_format] [-f input_keyfile]</span><br><span class="line">       ssh-keygen -e [-m key_format] [-f input_keyfile]</span><br><span class="line">       ssh-keygen -y [-f input_keyfile]</span><br><span class="line">       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]</span><br><span class="line">       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]</span><br><span class="line">       ssh-keygen -B [-f input_keyfile]</span><br><span class="line">       ssh-keygen -D pkcs11</span><br><span class="line">       ssh-keygen -F hostname [-f known_hosts_file] [-l]</span><br><span class="line">       ssh-keygen -H [-f known_hosts_file]</span><br><span class="line">       ssh-keygen -R hostname [-f known_hosts_file]</span><br><span class="line">       ssh-keygen -r hostname [-f input_keyfile] [-g]</span><br><span class="line">       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]</span><br><span class="line">       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]</span><br><span class="line">                  [-j start_line] [-K checkpt] [-W generator]</span><br><span class="line">       ssh-keygen -s ca_key -I certificate_identity [-h] [-U]</span><br><span class="line">                  [-D pkcs11_provider] [-n principals] [-O option]</span><br><span class="line">                  [-V validity_interval] [-z serial_number] file ...</span><br><span class="line">       ssh-keygen -L [-f input_keyfile]</span><br><span class="line">       ssh-keygen -A</span><br><span class="line">       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]</span><br><span class="line">                  file ...</span><br><span class="line">       ssh-keygen -Q -f krl_file file ...</span><br></pre></td></tr></table></figure><p>一般用法：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密钥需要存放在 "~/.ssh" 文件夹下面，因为无论是 ssh 远程还是 git 远程仓库读取私钥都是从这个文件夹目录下读取，如果当前没有就创建</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 密钥长度建议设置 2048，越长越安全</span></span><br><span class="line">$ ssh-keygen -b 2048 -t rsa -C <span class="string">'ytj2713151713@gmail.com'</span></span><br></pre></td></tr></table></figure><h3 id="添加公钥（public-key）到-github"><a href="#添加公钥（public-key）到-github" class="headerlink" title="添加公钥（public key）到 github"></a>添加公钥（public key）到 github</h3><p>打开 ‘~/.ssh’ 目录，以 <code>.pub</code> 结尾的便是公钥。注意生成的公钥的第二行的空行也要复制过去。</p><p>可以看到下面的公钥是有个空行的。</p><p><img data-src="https://i.loli.net/2019/05/08/5cd2d0b0d4753.png" alt="public key"></p><p><img data-src="https://i.loli.net/2019/05/08/5cd2df9832175.jpg" alt="github-ssh"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化仓库后会在当前文件夹生成一个 <code>.git</code> 文件夹，这个文件夹就是用来存放了整个仓库的版本信息。</p><h3 id="将仓库添加为新版本"><a href="#将仓库添加为新版本" class="headerlink" title="将仓库添加为新版本"></a>将仓库添加为新版本</h3><h4 id="添加修改到暂存区"><a href="#添加修改到暂存区" class="headerlink" title="添加修改到暂存区"></a>添加修改到暂存区</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 file 添加到 stage 区</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line"><span class="comment"># 我一般都是用下面的命令一次性提交所有修改</span></span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'commit message'</span></span><br></pre></td></tr></table></figure><h3 id="推送本地代码到远程仓库服务器"><a href="#推送本地代码到远程仓库服务器" class="headerlink" title="推送本地代码到远程仓库服务器"></a>推送本地代码到远程仓库服务器</h3><h4 id="添加远程仓库地址"><a href="#添加远程仓库地址" class="headerlink" title="添加远程仓库地址"></a>添加远程仓库地址</h4><p><code>remote-server-name</code> 是你给远程服务器取的一个名字。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add remote-server-name server-address</span><br></pre></td></tr></table></figure><h4 id="推送本地提交"><a href="#推送本地提交" class="headerlink" title="推送本地提交"></a>推送本地提交</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push remote-server-name -u branch-name</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMDE5NDE5" title="https://www.zhihu.com/question/20019419">git push 的 -u 参数具体适合含义？<i class="fa fa-external-link"></i></span></p><p>使用 <code>-u</code> 参数建立分支之间的关联后，后续就可以不用后面的参数了，一个 <code>git push</code> 就会将当前分支推送到关联的远程分支了。</p><h3 id="查看仓库信息"><a href="#查看仓库信息" class="headerlink" title="查看仓库信息"></a>查看仓库信息</h3><h4 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><h4 id="查看文件修改内容"><a href="#查看文件修改内容" class="headerlink" title="查看文件修改内容"></a>查看文件修改内容</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- test.txt</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index a9682e5..a9ef16d 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line">-原谅我放荡不羁爱自由。</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+原谅我放荡不羁爱自由。</span><br><span class="line">+放屁，单身狗的自我安慰。</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 412d436e2380d4d64c663849c81eb7646a204755 (HEAD -&gt; master)</span><br><span class="line">Author: YuTengjing &lt;ytj2713151713@gmail.com&gt;</span><br><span class="line">Date:   Wed May 8 21:46:39 2019 +0800</span><br><span class="line"></span><br><span class="line">    append comment to test.txt</span><br><span class="line"></span><br><span class="line">commit 6bc24d2f5c1b1462e4fe8828492151ffab78b49e</span><br><span class="line">Author: YuTengjing &lt;ytj2713151713@gmail.com&gt;</span><br><span class="line">Date:   Wed May 8 21:40:26 2019 +0800</span><br><span class="line"></span><br><span class="line">    init project</span><br></pre></td></tr></table></figure><h4 id="查看版本操作记录"><a href="#查看版本操作记录" class="headerlink" title="查看版本操作记录"></a>查看版本操作记录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">412d436 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: append comment to test.txt</span><br><span class="line">6bc24d2 HEAD@&#123;1&#125;: commit (initial): init project</span><br></pre></td></tr></table></figure><p>待补充…</p>]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>超实用的 chrome 扩展推荐</title>
    <url>/%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84%20chrome%20%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p><img data-src="https://i.loli.net/2019/04/06/5ca8647de4816.png" alt="新标签页"></p><p>chrome 浏览器这么受欢迎，不仅是由于他的速度快，扩展的丰富和强大也是非常重要的一个因素。我是一个前端开发者，所以扩展中可能有相当大的一部份是开发者工具。当然了，程序员也是有生活娱乐的，我也收藏了许多普通大众适用的扩展。</p><p>我对工具的选择是比较挑剔的，同类型的插件中，我会优先选择免费，更新力度大，好评率高以及是否是官方出品的。我平时有事没事就会去 chrome 扩展市场去逛逛，也看过很多和 chrome 扩展相关的帖子，所以积攒的插件比较多。</p><p>一大波图片即将来袭，请在流量充足的情况下阅读[]<del>(￣ ▽ ￣)</del>*</p><a id="more"></a><h2 id="基础功能扩展"><a href="#基础功能扩展" class="headerlink" title="基础功能扩展"></a><strong>基础功能扩展</strong></h2><p>chrome 本身很多功能做的非常的简洁，因人而异，可能会满足不了用户的需求。部分用户从一些国产的浏览器切换到 chrome 上时，可能会觉得 chrome 很难用，要啥没啥。国产浏览器之所以好像比 chorme 功能多很多，部分原因是国产浏览器内置了一些扩展，比如下载，手势等扩展。又由于不可抗之力导致无法同步和访问扩展市场更加觉得 chrome 垃圾…</p><p><strong>我相信这部分的扩展绝对会让你感受 chrome 扩展魅力</strong>。</p><h3 id="Chrome-Better-History"><a href="#Chrome-Better-History" class="headerlink" title="Chrome Better History"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY2hyb21lLWJldHRlci1oaXN0b3J5L2FhZGJhYWdiYW5maWpkbmZsa2hlcGdqbWhscHBwYmFk" title="https://chrome.google.com/webstore/detail/chrome-better-history/aadbaagbanfijdnflkhepgjmhlpppbad">Chrome Better History<i class="fa fa-external-link"></i></span></h3><p>这是一个用来替代 chrome 自带的查看历史记录功能的扩展，界面设计的很简洁，比较赞的是有个可视化的日历让我们可以单独查看某一天的历史记录。</p><p><img data-src="https://pic4.zhimg.com/v2-10f32c63e7da1c55318384401d79cf1b_b.png" alt="img"></p><h3 id="Grammarly-for-Chrome"><a href="#Grammarly-for-Chrome" class="headerlink" title="Grammarly for Chrome"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZ3JhbW1hcmx5LWZvci1jaHJvbWUva2JmbmJjYWVwbGJjaW9ha2twY3BnZmtvYmtnaGxoZW4=" title="https://chrome.google.com/webstore/detail/grammarly-for-chrome/kbfnbcaeplbcioakkpcpgfkobkghlhen">Grammarly for Chrome<i class="fa fa-external-link"></i></span></h3><p>其实包括很多编辑器和 ide 都有类似的扩展用来纠正英文的拼写错误。当你在网页中的编辑框中编辑文本时，这个扩展能提示你单词的拼写错误，你少了标点符号和混淆单词提示等。妈妈再也不用担心我英语不好老拼错单词了。 高级版功能更多，不过我觉得如果你不是日常英文写作的话标准版就已经够用了。</p><p><img data-src="https://pic3.zhimg.com/v2-a776c7397092af45bf7fcaae38ec43da_b.png" alt="img"></p><h3 id="Webtime-Tracker"><a href="#Webtime-Tracker" class="headerlink" title="Webtime Tracker"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvd2VidGltZS10cmFja2VyL3BwYW9qbmJtbWFpZ2ptbHBqYWxkbmtnbmtsaGljcHBr" title="https://chrome.google.com/webstore/detail/webtime-tracker/ppaojnbmmaigjmlpjaldnkgnklhicppk">Webtime Tracker<i class="fa fa-external-link"></i></span></h3><p>统计你浏览各个网站的时间，以环形图和列表的形式展示，风格简洁功能专一。</p><p><img data-src="https://pic2.zhimg.com/v2-e0051da2db2125630e5e6483fc0bf069_b.png" alt="img"></p><h3 id="uBlock-Origin"><a href="#uBlock-Origin" class="headerlink" title="uBlock Origin"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdWJsb2NrLW9yaWdpbi9janBhbGhkbG5icGFmaWFtZWpkbmhjcGhqYmtlaWFnbQ==" title="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin<i class="fa fa-external-link"></i></span></h3><p>拦截广告的扩展有很多，比较有名的有 Adblock，Adblocks plus，AdGuard， uBlock Origin 等。说实话，我没怎么去深入研究过它们的区别，不好评价它们之间的优缺点。挑一个自己喜欢的安装就行了，安装多个完全没必要，浪费内存还容易起冲突。尤其是我们做前端开发的，很可能会导致我们开发网页出现问题，出现误拦截，解决办法就是加白名单或者直接关了广告拦截插件。感觉自从用了拦截广告的扩展后，浏览网页就没怎么碰到过恶心的广告和弹窗，清爽了不少，实在必备神器啊。</p><p><img data-src="https://pic2.zhimg.com/v2-43f1705ab13c3dd0487264dfb0fcbbdd_b.png" alt="img"></p><p>上面提到的几个大都是国外的开发者开发，国内的很多广告有可能拦截不了，可以试试另一款国人开发的扩展： <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTYwNTEyNC9baHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv5bm/5ZGK57uI57uT6ICFL2ZwZG5qZGxiZG1pZm9vY2VkaGtpZ2hobGJjaGJpaWtsXShodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC/lub/lkYrnu4jnu5PogIUvZnBkbmpkbGJkbWlmb29jZWRoa2lnaGhsYmNoYmlpa2wp" title="https://zhuanlan.zhihu.com/p/61605124/[https://chrome.google.com/webstore/detail/广告终结者/fpdnjdlbdmifoocedhkighhlbchbiikl](https://chrome.google.com/webstore/detail/广告终结者/fpdnjdlbdmifoocedhkighhlbchbiikl)">广告终结者<i class="fa fa-external-link"></i></span>。</p><h3 id="Enable-Copy"><a href="#Enable-Copy" class="headerlink" title="Enable Copy"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZW5hYmxlLWNvcHkvbG1uZ2FuYWRrZWNlZm5obmNva2RsYW9obGtuZWloaW8=" title="https://chrome.google.com/webstore/detail/enable-copy/lmnganadkecefnhncokdlaohlkneihio">Enable Copy<i class="fa fa-external-link"></i></span></h3><p>遇到限制复制和右键的网页是不是很头痛？安装这个扩展后，点下扩展按钮就能解决了～</p><p><img data-src="https://pic3.zhimg.com/v2-ba2281ec4ead7085b4fb80f623277bee_b.png" alt="img"></p><h3 id="Chrome-清理大师"><a href="#Chrome-清理大师" class="headerlink" title="Chrome 清理大师"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY2xlYW4tbWFzdGVyLXRoZS1iZXN0LWNoci9lYWdpYWtqbWpuYmxsaWFjb2toY2FsZWJnbmhlbGxmaQ==" title="https://chrome.google.com/webstore/detail/clean-master-the-best-chr/eagiakjmjnblliacokhcalebgnhellfi">Chrome 清理大师<i class="fa fa-external-link"></i></span></h3><p>非常小巧实用的清理工具，没有其他乱七八糟的功能。</p><p><img data-src="https://pic4.zhimg.com/v2-07cf825f6a6811ca14afd77af5110c07_b.png" alt="img"></p><h3 id="高效网页截图编辑扩展"><a href="#高效网页截图编辑扩展" class="headerlink" title="高效网页截图编辑扩展"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZXhwbGFpbi1hbmQtc2VuZC1zY3JlZW5zaC9tZGRkYWJqaGVscGlscG5wZ29uZGZtZWhoY3BscGlpbg==" title="https://chrome.google.com/webstore/detail/explain-and-send-screensh/mdddabjhelpilpnpgondfmehhcplpiin">高效网页截图编辑扩展<i class="fa fa-external-link"></i></span></h3><p>这款截图工具不但截图类型丰富，还可以在截图之后直接标注。</p><p><img data-src="https://pic3.zhimg.com/v2-75bb8bb483b438bb4e2ae385bcd29b3e_b.png" alt="img"></p><h3 id="划词翻译"><a href="#划词翻译" class="headerlink" title="划词翻译"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv5YiS6K+N57+76K+RL2lraGRra25jbm9nbGdobGpsa21jaW1sbmxoa2VhbWFk" title="https://chrome.google.com/webstore/detail/划词翻译/ikhdkkncnoglghljlkmcimlnlhkeamad">划词翻译<i class="fa fa-external-link"></i></span></h3><p>一款国人<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NlbGVjdGlvbi1UcmFuc2xhdG9yL2NyeC1zZWxlY3Rpb24tdHJhbnNsYXRl" title="https://github.com/Selection-Translator/crx-selection-translate">开源<i class="fa fa-external-link"></i></span>的翻译工具，非常简洁方便。</p><p><img data-src="https://pic3.zhimg.com/v2-ce82332c55c2ee3916ca597c4015b62a_b.png" alt="img"></p><h3 id="Quick-Tabs-和-OneTab"><a href="#Quick-Tabs-和-OneTab" class="headerlink" title="Quick Tabs 和 OneTab"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcXVpY2stdGFicy9qbmpmZWluamZtZW5sZGRhaGRqZG1ncGJva2lhY2JiYg==" title="https://chrome.google.com/webstore/detail/quick-tabs/jnjfeinjfmenlddahdjdmgpbokiacbbb">Quick Tabs<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb25ldGFiL2NocGhscGdra2JvbGlmYWltbmxsb2lpcGtkbmloYWxs" title="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">OneTab<i class="fa fa-external-link"></i></span></h3><p>经常看到 PM 同事开几十个 tab 页，tab 页多的只能看到一个网站图标 彡(-_-;)彡。那么多 tab 页一个一个打开看看是不是自己想看的那个 tab 页效率也太低了。如何你平时也是这样的情况，那么 Quick Tabs 和 OneTab 非常适合你。</p><p>Quick Tabs 激活搜索框的快捷键是 cmd + e ，作者受 IntelliJ IDEA 启发开发的这款按照最近使用顺序排序，可以搜索和快速切换到你想要打开的扩展。</p><p><img data-src="https://pic2.zhimg.com/v2-0efe002b694552eaef8e5537d6e4dbad_b.png" alt="img"></p><p>OneTab 这个扩展会将你所有打开的 tab 收到一个页面，需要打开哪个页面直接在这个页面点击恢复即可。</p><p><img data-src="https://pic2.zhimg.com/v2-f4442328d3cafea61c297cf32077c90d_b.png" alt="img"></p><h3 id="The-Great-Suspender"><a href="#The-Great-Suspender" class="headerlink" title="The Great Suspender"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdGhlLWdyZWF0LXN1c3BlbmRlci9rbGJpYmtlY2Nuamxramtpb2tqb2RvY2ViYWphbmFrZw==" title="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">The Great Suspender<i class="fa fa-external-link"></i></span></h3><p>这款插件也是一个 tab 页插件，它的功能是会在你不访问某个页面一定时间后自动冻结页面或者手动冻结，达到节省内存的目的。当你需要恢复页面，只要点击一下页面即可恢复。图标非常 cute 呢 ︿(￣︶￣)︿</p><p><img data-src="https://pic1.zhimg.com/v2-79ed87fe35cac30f79f7b07c4d6a5dc0_b.png" alt="img"></p><h3 id="Super-Simple-Highlighter"><a href="#Super-Simple-Highlighter" class="headerlink" title="Super Simple Highlighter"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc3VwZXItc2ltcGxlLWhpZ2hsaWdodGVyL2hobGhqZ2lhbnBvY3BvcHBhaWlobWxwZ2NvZWhsaGlv" title="https://chrome.google.com/webstore/detail/super-simple-highlighter/hhlhjgianpocpoppaiihmlpgcoehlhio">Super Simple Highlighter<i class="fa fa-external-link"></i></span></h3><p>这款扩展允许你在网页上直接高亮文字，当你关掉页面重新打开高亮也会恢复，对于一些经常需要在网页上浏览文档的人或许很有帮助。</p><p><img data-src="https://pic1.zhimg.com/v2-7d2424fdea5f4dc9bd8b4aebefaa6788_b.png" alt="img"></p><h3 id="Linkclump"><a href="#Linkclump" class="headerlink" title="Linkclump"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbGlua2NsdW1wL2xmcGprbmNva2xsbmZva2tncGtvYm5rYmttZWxmZWZq" title="https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj">Linkclump<i class="fa fa-external-link"></i></span></h3><p>选中一片局域一次性打开多个链接，这在某些情况下很实用。</p><p><img data-src="https://pic2.zhimg.com/v2-8a67eb0370247e36679fdad70e2d6451_b.png" alt="img"></p><h3 id="书签侧边栏"><a href="#书签侧边栏" class="headerlink" title="书签侧边栏"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvYm9va21hcmstc2lkZWJhci9qZGJub2ZjY21oZWZrbWpia2tka2ZpaWNqa2dvZmtkaA==" title="https://chrome.google.com/webstore/detail/bookmark-sidebar/jdbnofccmhefkmjbkkdkfiicjkgofkdh">书签侧边栏<i class="fa fa-external-link"></i></span></h3><p>如果你觉得每次打开自带的书签管理器都打开一个新 tab 页里面很不方便，不妨试试这款书签插件，这款书签管理非常 material 非常骚气，可以自定义的配置很多。</p><p><img data-src="https://pic4.zhimg.com/v2-e159365aa5f6e455e1b73dbfc4271757_b.jpg" alt="img"></p><h3 id="Pinbox-网络收藏夹"><a href="#Pinbox-网络收藏夹" class="headerlink" title="Pinbox - 网络收藏夹"></a><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTYwNTEyNC9baHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcGluYm94Lee9kee7nOaUtuiXj+WkuS9rbWlqZWFuZ25hamRjYW9tZGZqb2hoYm1uYmhuaGpqZF0oaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcGluYm94Lee9kee7nOaUtuiXj+WkuS9rbWlqZWFuZ25hamRjYW9tZGZqb2hoYm1uYmhuaGpqZCk=" title="https://zhuanlan.zhihu.com/p/61605124/[https://chrome.google.com/webstore/detail/pinbox-网络收藏夹/kmijeangnajdcaomdfjohhbmnbhnhjjd](https://chrome.google.com/webstore/detail/pinbox-网络收藏夹/kmijeangnajdcaomdfjohhbmnbhnhjjd)">Pinbox - 网络收藏夹<i class="fa fa-external-link"></i></span></h3><p>如果上满那款插件还是不能满足你的需求，你可以试试这款国人开发的网络收藏工具。官方介绍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您的专属网络收藏夹，将文章、视频或喜欢的任何内容一键保存到 Pinbox, 随时随地收藏互联网</span><br><span class="line">Pinbox 是一款跨平台的收藏工具，您可以用它来记录灵感，保存资料甚至网络上的任何内容。</span><br><span class="line"></span><br><span class="line">通过 Pinbox 您可以收藏（网页，图片，文本），打造您的私人空间，同时可以通过多级收藏集和批量操作来整理它们。</span><br><span class="line"></span><br><span class="line">Pinbox 同时是一款强大的生产力工具，利用快捷键，您可以迅速的打开收藏的内容。</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">1.收藏网页、图片、文本，甚至网络上的一切内容；</span><br><span class="line">2.编辑标题和备注：您可以编辑已经收藏的内容，使之更加清晰直观；</span><br><span class="line">3.多级收藏集：帮助您整理收藏的内容；</span><br><span class="line">4.编辑模式：支持多选、拖拽等功能，可以批量整理您的收藏；</span><br><span class="line">5.搜索：搜索收藏的标题、链接、同样也支持您自定义的标题和备注；</span><br><span class="line">6.导入书签：一键快速导入浏览器书签，并保留书签结构；</span><br><span class="line">7.回收站：放心的删除收藏，它们都将自动进入回收站，随时恢复；</span><br><span class="line">8.跨平台支持：网页 + 浏览器扩展 + APP；</span><br><span class="line">9.注重隐私：我们十分注重用户隐私，您的收藏只有您自己能看到。</span><br></pre></td></tr></table></figure><p>这款插件比起上面那款可以说功能是强大很多了，跨平台，在线同步，不仅可以收藏网页还可以收藏很多其它类型的内容。打开 pinbox 页面就可以看出作者非常的用心啊，不多说了，感兴趣的读者可以自己使用感受下。</p><p><img data-src="https://pic4.zhimg.com/v2-3929cecc5c57ed79e68fde6ce81f2837_b.jpg" alt="img"></p><h3 id="Wappalyzer"><a href="#Wappalyzer" class="headerlink" title="Wappalyzer"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvd2FwcGFseXplci9ncHBvbmdtaGprcGZuYmhhZ3BtamZrYW5uZmJsbGFtZw==" title="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg">Wappalyzer<i class="fa fa-external-link"></i></span></h3><p>一款可以分析网站用到的技术框架的扩展。</p><p><img data-src="https://pic1.zhimg.com/v2-a4841bcc39cf5e66956dce1559cae070_b.png" alt="img"></p><h3 id="IP-Whois-amp-Flags-Chrome-amp-Websites-Rating"><a href="#IP-Whois-amp-Flags-Chrome-amp-Websites-Rating" class="headerlink" title="IP Whois &amp; Flags Chrome &amp; Websites Rating"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaXAtd2hvaXMtZmxhZ3MtY2hyb21lLXdlYi9rbWRmYmFjZ29tYm5kbmxsb2dvaWpobmdnYWxnbWtvbg==" title="https://chrome.google.com/webstore/detail/ip-whois-flags-chrome-web/kmdfbacgombndnllogoijhnggalgmkon">IP Whois &amp; Flags Chrome &amp; Websites Rating<i class="fa fa-external-link"></i></span></h3><p>可以显示网站的国旗，流行度，ip 等其它信息。</p><p><img data-src="https://pic2.zhimg.com/v2-f13cf852b115feffd06d8a1a9abc7a71_b.png" alt="img"></p><p>另一款更强大的 ip 分析扩展是 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaXAtYWRkcmVzcy1hbmQtZG9tYWluLWluZi9saGdrZWdlY2NuY2tvaWxpb2tvbmRwYWFhbGJoYWZvYQ==" title="https://chrome.google.com/webstore/detail/ip-address-and-domain-inf/lhgkegeccnckoiliokondpaaalbhafoa">IP Address and Domain Information<i class="fa fa-external-link"></i></span></p><h3 id="扩展管理器（Extension-Manager）"><a href="#扩展管理器（Extension-Manager）" class="headerlink" title="扩展管理器（Extension Manager）"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZXh0ZW5zaW9uLW1hbmFnZXIvZ2psZGNkbmdtZGtucGlub2VtbmRsaWRwY2Fia2dnY28=" title="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">扩展管理器（Extension Manager）<i class="fa fa-external-link"></i></span></h3><p>简单易用的扩展管理器，支持还有搜索和分组功能。默认是网格视图，还可以使用显示信息更多的列表视图。</p><p><img data-src="https://pic4.zhimg.com/v2-bcb3590e780b2ea29173c2b108feee53_b.png" alt="img"></p><p>这里介绍一下我平时是怎么用这款扩展的，我一般是分三个组：默认分组，开发分组，无扩展分组。</p><ul><li>默认分组：包含的扩展最多，就是一些平常可能用得上的扩展</li><li>开发分组：除去了一些广告拦截等可能会影响我做前端开发的扩展</li><li>无扩展分组：基本上没有开启扩展，只保留的一个新标签页扩展</li></ul><p>不同场景选择不同的扩展组，高效管理扩展。</p><h3 id="Online-Download-Manager"><a href="#Online-Download-Manager" class="headerlink" title="Online Download Manager"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb25saW5lLWRvd25sb2FkLW1hbmFnZXIvb3BqanBtaG9pb2ppZnBwa2tjZGFiaW9iaGFrbGpkZ20=" title="https://chrome.google.com/webstore/detail/online-download-manager/opjjpmhoiojifppkkcdabiobhakljdgm">Online Download Manager<i class="fa fa-external-link"></i></span></h3><p>如果你还在抱怨 chrome 自带的下载管理太简洁了，那么这款下载管理扩展绝对值得尝试。这款插件除了比自带的下载管理在管理方面功能更丰富，还有一大特色就是资源嗅探，可以嗅探出网页中的图片，视频，音频资源。以前有一款同样非常优秀的下载管理扩展叫 chrono，但是不造为啥 chrome 扩展市场已经搜索不到了(O_O)?</p><p><img data-src="https://pic3.zhimg.com/v2-9314f73804294bb73879dd040d0f283e_b.png" alt="img"></p><h3 id="Copyfish-🐟-Free-OCR-Software"><a href="#Copyfish-🐟-Free-OCR-Software" class="headerlink" title="Copyfish 🐟 Free OCR Software"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY29weWZpc2gt8J+Qny1mcmVlLW9jci1zb2Z0L2VlbmpkbmpsZGFwamFqam9mbWxkZ21ramFpZW5lYmJq" title="https://chrome.google.com/webstore/detail/copyfish-🐟-free-ocr-soft/eenjdnjldapjajjofmldgmkjaienebbj">Copyfish 🐟 Free OCR Software<i class="fa fa-external-link"></i></span></h3><p>一个 OCR 文字识别扩展。</p><p><img data-src="https://pic4.zhimg.com/v2-1e1085a888f2851517fb121a0c2f32ff_b.png" alt="img"></p><h3 id="Proxy-SwitchyOmega"><a href="#Proxy-SwitchyOmega" class="headerlink" title="Proxy SwitchyOmega"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcHJveHktc3dpdGNoeW9tZWdhL3BhZGVrZ2NlbWxva2JhZG9oZ2tpZmlqb21jbGdqZ2lm" title="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">Proxy SwitchyOmega<i class="fa fa-external-link"></i></span></h3><p>无论是开发还是日常使用都是非常强大实用的工具。这是一款管理代理的扩展，方便快速切换各种代理模式，前端开发也经常使用它来代理避免跨域问题。</p><p><img data-src="https://pic2.zhimg.com/v2-02b3a7c55fd2b46c4c9d42cff93b13e1_b.png" alt="img"></p><h3 id="Markdown-Preview-Plus"><a href="#Markdown-Preview-Plus" class="headerlink" title="Markdown Preview Plus"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbWFya2Rvd24tcHJldmlldy1wbHVzL2ZlYmlsa2JmY2JoZWJmbm9rYWZlZmVhY2ltamRja2ds" title="https://chrome.google.com/webstore/detail/markdown-preview-plus/febilkbfcbhebfnokafefeacimjdckgl">Markdown Preview Plus<i class="fa fa-external-link"></i></span></h3><p>一款可以让你在浏览器中阅读 markdown 文件的扩展，配色还是挺护眼的。</p><p><img data-src="https://pic4.zhimg.com/v2-06215cb1312993e6f7647270e2fac9e7_b.png" alt="img"></p><p>不过我现在已经切换到另一款扩展 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbWFya2Rvd24tdmlld2VyL2Nra2RsaW1obWNqbWlrZGxwa21iZ2ZrYWlrb2pjYmpr" title="https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk">Markdown Viewer<i class="fa fa-external-link"></i></span> 了，读者可以自行比较选择。</p><h3 id="Markdown-Here"><a href="#Markdown-Here" class="headerlink" title="Markdown Here"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbWFya2Rvd24taGVyZS9lbGlmaGFrY2pnYWxhaGNjbmprbmVvY2NlbWZhaGZvYQ==" title="https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa">Markdown Here<i class="fa fa-external-link"></i></span></h3><p>官方描述:</p><blockquote><p>``` Markdown Here 允许你在发送电子邮件之前用 Markdown 语法编辑并转换它(让它看起来漂亮极了!)。 这对于那些不喜欢在撰写电邮时反复摆弄排版按钮的人无疑是好消息。 它特别适合那些要在电子邮件中插入代码的程序员们 —— 没错，它甚至支持语法高亮显示。 对于我们之中的数学家们而言，Markdown Here 也支持转换 TeX 公式。 ```</p></blockquote><p><img data-src="https://pic3.zhimg.com/v2-74a505a3864cc5839138a25d8eb7d2a2_b.jpg" alt="img"></p><h3 id="类似的网站-发现相关网站"><a href="#类似的网站-发现相关网站" class="headerlink" title="类似的网站 - 发现相关网站"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc2ltaWxhci1zaXRlcy1kaXNjb3Zlci1yZS9uZWNwYm1iaGhkaXBsbWZobWppY2FiZGVpZ2hrbmRrbg==" title="https://chrome.google.com/webstore/detail/similar-sites-discover-re/necpbmbhhdiplmfhmjicabdeighkndkn">类似的网站 - 发现相关网站<i class="fa fa-external-link"></i></span></h3><p><img data-src="https://pic1.zhimg.com/v2-c7c6d99a3ff23988d0a77701532f7ae8_b.png" alt="img"></p><h3 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdGFtcGVybW9ua2V5L2RoZGdmZmtrZWJobWtmam9qZWptcGJsZG1wb2Jma2Zv" title="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey<i class="fa fa-external-link"></i></span></h3><p>很多网友叫这个扩展叫油猴，本质上是一个管理注入网站的 javascript 脚本的扩展。使用它我们可以自定义某个网站打开时注入的脚本，也可以去一些论坛直接安装别人分享的脚本。油猴搭配 idm 对于治疗百度网盘蜗速有奇效,，比较受欢迎的脚本还有破解会员之类的。推荐脚本源 <span class="exturl" data-url="aHR0cHM6Ly9ncmVhc3lmb3JrLm9yZy96aC1DTg==" title="https://greasyfork.org/zh-CN">greasyfork<i class="fa fa-external-link"></i></span>, 还有一个显示当前网站所有可用脚本的脚本 <span class="exturl" data-url="aHR0cHM6Ly9ncmVhc3lmb3JrLm9yZy96aC1DTi9zY3JpcHRzLzI0NTA4LXVzZXJzY3JpcHQtc2hvdy1zaXRlLWFsbC11c2VyanM=" title="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs">Userscript+<i class="fa fa-external-link"></i></span>。</p><h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc3R5bHVzL2NsbmdkYmtwa3BlZWJhaGpja2tqZm9iYWZobmNnbW5l" title="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Stylus<i class="fa fa-external-link"></i></span></h3><p>油猴是用来注入 javascript 脚本的，而这个是用来注入 css 样式的。</p><h3 id="Infinity-新标签页-Pro"><a href="#Infinity-新标签页-Pro" class="headerlink" title="Infinity 新标签页(Pro)"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaW5maW5pdHktbmV3LXRhYi1wcm8vbm5ua2Rkbm5scGFtb2JhamZpYmZkZ2ZuYmNua2duZ2g=" title="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh">Infinity 新标签页(Pro)<i class="fa fa-external-link"></i></span></h3><p>这个扩展被太多人推荐过了，所以我也不敢放文章最开头介绍，怕被认为我推荐一堆烂大街的扩展。非常良心的一款新标签页扩展，有很多地方都可以自定义，本文的封面就是这个扩展的普通版。我目前用的是 Pro 版本，Pro 版本目前可以无限期免费使用，良心啊。Pro 版本相比较于普通版自定义项更加丰富，还支持文件夹，动画，屏幕缩放等新功能。</p><p><img data-src="https://pic2.zhimg.com/v2-2ceb7f4214aa57a051ef29c229651e65_b.png" alt="img"></p><h3 id="HTTPS-Everywhere"><a href="#HTTPS-Everywhere" class="headerlink" title="HTTPS Everywhere"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaHR0cHMtZXZlcnl3aGVyZS9nY2JvbW1rY2xtY2xwY2hsbGZqZWtjZG9ucG1lamJkcA==" title="https://chrome.google.com/webstore/detail/https-everywhere/gcbommkclmclpchllfjekcdonpmejbdp">HTTPS Everywhere<i class="fa fa-external-link"></i></span></h3><p>加密网络浏览，自动使用 HTTPS 连接访问站点，更加安全。</p><p>还有一些都用得上的扩展我就简单列一下：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvYmxhY2stbWVudS1mb3ItZ29vZ2xlL2VpZ25oZGZnYWxkYWJpbGFhZWdtZGZiYWpuZ2ptb2tl" title="https://chrome.google.com/webstore/detail/black-menu-for-google/eignhdfgaldabilaaegmdfbajngjmoke">Black Menu for Google™<i class="fa fa-external-link"></i></span> 一个菜单扩展让你快速使用 Google 提供的各种服务</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZGlzdGlsbC13ZWItbW9uaXRvci9pbmxpa2plbWVla25vZmNra2pvbG5qYnBlaGdhZGdnZQ==" title="https://chrome.google.com/webstore/detail/distill-web-monitor/inlikjemeeknofckkjolnjbpehgadgge">Distill Web Monitor<i class="fa fa-external-link"></i></span> 监控网页变化，抢购神器</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY3J4bW91c2UtY2hyb21lLWdlc3R1cmVzL2psZ2twYWljaWtpaGlqYWRnaWZrbGticGRhamJraGpvXQ==" title="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo]">crxMouse Chrome™ 手势<i class="fa fa-external-link"></i></span> 极大的扩展了 chrome 的手势功能</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZmF0a3VuLWJhdGNoLWRvd25sb2FkLWltYS9ubmpqYWhsaWtpYWJuY2hjcGVoY3BrZGVja2Znbm9oZg==" title="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf">Fatkun 图片批量下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaWUtdGFiL2hlaGlqYmZnaWVrbWpma2ZqcGJrYmFtbWpiZGVuYWRk" title="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd">IE Tab<i class="fa fa-external-link"></i></span> 解决 chrome 无法使用网银的问题</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbm90ZS1ib2FyZC1zdGlja3ktbm90ZXMtYS9nb2ZpY21wY2djbm9tYmlvb2hqY2dkaGJhbG9rbmFiYg==" title="https://chrome.google.com/webstore/detail/note-board-sticky-notes-a/goficmpcgcnombioohjcgdhbaloknabb">Note Board - Sticky Notes App<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbWVnYS9iaWdlZnBmaG5mY29iZGxmYmVkb2ZoaGFpYm5sZ2hvZA==" title="https://chrome.google.com/webstore/detail/mega/bigefpfhnfcobdlfbedofhhaibnlghod">MEGA<i class="fa fa-external-link"></i></span> 免费 50 G 的网盘</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb2ZmaWNlLW9ubGluZS9uZGpwbmxhZGNhbGxtamVtbGJhZWJmYWRlY2Zoa2VwYg==" title="https://chrome.google.com/webstore/detail/office-online/ndjpnladcallmjemlbaebfadecfhkepb">Office Online<i class="fa fa-external-link"></i></span> 在浏览器中查看、编辑和创建 Office 文件。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcGRmLXZpZXdlci9vZW1tbmRjYmxkYm9pZWJmbmxhZGRhY2JkZm1hZGFkbQ==" title="https://chrome.google.com/webstore/detail/pdf-viewer/oemmndcbldboiebfnladdacbdfmadadm">PDF Viewer<i class="fa fa-external-link"></i></span> chrome 浏览 pdf</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc2NyZWVuY2FzdGlmeS1zY3JlZW4tdmlkZS9tbWVpamltZ2FiYnBiZ3Bka2xubGxwbmNtZG9ma2Nwbg==" title="https://chrome.google.com/webstore/detail/screencastify-screen-vide/mmeijimgabbpbgpdklnllpncmdofkcpn">Screencastify - Screen Video Recorder<i class="fa fa-external-link"></i></span> 网页录屏</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdGFicy1vdXRsaW5lci9lZ2drYW5vY2dkZGhtYW1sYmlpam5waGhwcGtwa21rbA==" title="https://chrome.google.com/webstore/detail/tabs-outliner/eggkanocgddhmamlbiijnphhppkpkmkl">Tabs Outliner<i class="fa fa-external-link"></i></span> 将标签页树状显示</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc3BlZWR0ZXN0LWJ5LW9va2xhL3Bnamppa2RpaWtpaGRmcG9wcGdhaWRjY2FoYWxlaGpo" title="https://chrome.google.com/webstore/detail/speedtest-by-ookla/pgjjikdiikihdfpoppgaidccahalehjh">Speedtest by Ookla<i class="fa fa-external-link"></i></span> 测试网络速度和打开网页的速度</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc3VyZmluZ2tleXMvZ2ZibGlvaG5uYXBpZWZqcGpscGpuZWhnbGZwYWtubmM=" title="https://chrome.google.com/webstore/detail/surfingkeys/gfbliohnnapiefjpjlpjnehglfpaknnc">Surfingkeys<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdmltaXVtL2RiZXBnZ2VvZ2JhaWJoZ25oaG5kb2pwZXBpaWhjbWVi" title="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium<i class="fa fa-external-link"></i></span> 像 vim 一样操控网页，vim 永生~</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdm9sdW1lLW1hc3Rlci9qZ2hlY2dhYmZnZmRsZG5tYmZraG1mZmNhYmRkaW9rZQ==" title="https://chrome.google.com/webstore/detail/volume-master/jghecgabfgfdldnmbfkhmffcabddioke">Volume Master<i class="fa fa-external-link"></i></span> 音量调节器</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv54K65LuA6bq85L2g5YCR5bCx5piv5LiN6IO95Yqg5YCL56m65qC85ZGi77yfL3BhcGhjZmRmZmpuYmNna29raWhjZGpsaWloaWNtYnBk" title="https://chrome.google.com/webstore/detail/為什麼你們就是不能加個空格呢？/paphcfdffjnbcgkokihcdjliihicmbpd">为什么你们就是不能加个空格呢？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpc3RlbjEvbGlzdGVuMV9jaHJvbWVfZXh0ZW5zaW9u" title="https://github.com/listen1/listen1_chrome_extension">Listen 1<i class="fa fa-external-link"></i></span> 音乐聚合</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdmlkZW8tc3BlZWQtY29udHJvbGxlci9uZmZhb2FsYmlsYm1tZmdibmJncHBqaWhvcGFicHBkaw==" title="https://chrome.google.com/webstore/detail/video-speed-controller/nffaoalbilbmmfgbnbgppjihopabppdk">Video Speed Controller<i class="fa fa-external-link"></i></span> 视频加速扩展，可以用来做坏事（。＾ ▽ ＾）</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaG92ZXItem9vbS9ub25qZGNqY2hnaGhrZG9vbG5sYmVrY2ZsbG1lZG5ibA==" title="https://chrome.google.com/webstore/detail/hover-zoom/nonjdcjchghhkdoolnlbekcfllmednbl">Hover Zoom<i class="fa fa-external-link"></i></span> 鼠标悬浮到图片上显示大图</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY29udGV4dC1tZW51cy9waGxmbWtmcG1waG9na29tZGRja21nZ2NmcG1mY2hwbg==" title="https://chrome.google.com/webstore/detail/context-menus/phlfmkfpmphogkomddckmggcfpmfchpn">右键搜<i class="fa fa-external-link"></i></span> 扩展右键菜单</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdHVybi1vZmYtdGhlLWxpZ2h0cy1mb3IteS9iZmJtam1pb2Ribm5wbGxiYmJmYmxjcGxmamplcGpkbg==" title="https://chrome.google.com/webstore/detail/turn-off-the-lights-for-y/bfbmjmiodbnnpllbbbfblcplfjjepjdn">关灯看视频<i class="fa fa-external-link"></i></span></li></ul><h2 id="网站加强扩展"><a href="#网站加强扩展" class="headerlink" title="网站加强扩展"></a>网站加强扩展</h2><p>github 相关的扩展比较多。</p><h3 id="Awesome-Autocomplete-for-GitHub"><a href="#Awesome-Autocomplete-for-GitHub" class="headerlink" title="Awesome Autocomplete for GitHub"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvYXdlc29tZS1hdXRvY29tcGxldGUtZm9yL2Rqa2ZkanBvZWxwaGhkY2xmamhuZmZtbmxub2tuZm5k" title="https://chrome.google.com/webstore/detail/awesome-autocomplete-for/djkfdjpoelphhdclfjhnffmnlnoknfnd">Awesome Autocomplete for GitHub<i class="fa fa-external-link"></i></span></h3><p>加强 github 的搜索框。</p><p><img data-src="https://pic4.zhimg.com/v2-c1e729c498574f6c102d961ba081b487_b.png" alt="img"></p><h3 id="File-Icon-for-GitHub-GitLab-and-Bitbucket"><a href="#File-Icon-for-GitHub-GitLab-and-Bitbucket" class="headerlink" title="File Icon for GitHub, GitLab and Bitbucket"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZmlsZS1pY29uLWZvci1naXRodWItZ2l0bC9maWNmbWlia2pqbnBvZ2RjZmhmb2ttaWhhbm9sZGJmZQ==" title="https://chrome.google.com/webstore/detail/file-icon-for-github-gitl/ficfmibkjjnpogdcfhfokmihanoldbfe">File Icon for GitHub, GitLab and Bitbucket<i class="fa fa-external-link"></i></span></h3><p>给 github 仓库文件添加图标。</p><p><img data-src="https://pic1.zhimg.com/v2-d15023e0fc05f372a785bf441ade8d00_b.png" alt="img"></p><h3 id="Octohint"><a href="#Octohint" class="headerlink" title="Octohint"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb2N0b2hpbnQvaGJrcGprZmRoZWFpbmpra2ViZW9vZmtwZ2Rkbm5icGs=" title="https://chrome.google.com/webstore/detail/octohint/hbkpjkfdheainjkkebeoofkpgddnnbpk">Octohint<i class="fa fa-external-link"></i></span></h3><p>github 代码智能高亮。</p><p><img data-src="https://pic4.zhimg.com/v2-08f14d4f0a7e2b27f04168591f7f4aeb_b.png" alt="img"></p><h3 id="OctoLinker"><a href="#OctoLinker" class="headerlink" title="OctoLinker"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb2N0b2xpbmtlci9qbG1hZmJhZW9vZmRlZ29oZGhpbmtoaWxoY2xha2xrcA==" title="https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp">OctoLinker<i class="fa fa-external-link"></i></span></h3><p>直接从代码跳转到 gtihub 对应仓库，相对路径也能跳转，支持很多编程语言。</p><p><img data-src="https://pic3.zhimg.com/v2-37f14183665d9738f6ebbe13526780a6_b.png" alt="img"></p><h3 id="Isometric-Contributions"><a href="#Isometric-Contributions" class="headerlink" title="Isometric Contributions"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaXNvbWV0cmljLWNvbnRyaWJ1dGlvbnMvbWpvZWRsZmZsY2Nobmxla25uY2VpcGxnYWVvZWdpZW4=" title="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions<i class="fa fa-external-link"></i></span></h3><p>立体显示 github Contributions 的扩展，瞬间提升逼格有木有。</p><p><img data-src="https://pic1.zhimg.com/v2-49a6fd7c9c3211cc0dc9a3d5d5fc4754_b.png" alt="img"></p><h3 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvb2N0b3RyZWUvYmtoYWFnamFoZm1qbGphbG9wam5vZWFsbmZuZG5hZ2M=" title="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree<i class="fa fa-external-link"></i></span></h3><p>在左侧添加一个文件浏览器，可以更快的在文件之间跳转。</p><p><img data-src="https://pic3.zhimg.com/v2-84aa828392d89c51e096ffb9468dbc12_b.png" alt="img"></p><h3 id="Sourcegraph"><a href="#Sourcegraph" class="headerlink" title="Sourcegraph"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc291cmNlZ3JhcGgvZGdqaGZvbWppZWFhZHBvbGpsbmlkbWJna2RmZnBhY2s=" title="https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack">Sourcegraph<i class="fa fa-external-link"></i></span></h3><p>这个扩展厉害了，将 github 变得和 IDE 一般，集成各种功能。</p><p><img data-src="https://pic1.zhimg.com/v2-41d7ffc22968473a2c853cf4b6255298_b.png" alt="img"></p><p>和 github 相关的还有几个我就简要介绍一下了</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZ2F5aHViL21kY2ZmZWxnaGlrZGlhZm5mb2RqbGdsbGVuaGxuZWps" title="https://chrome.google.com/webstore/detail/gayhub/mdcffelghikdiafnfodjlgllenhlnejl">GayHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVmaW5lZC1naXRodWIvaGxlcGZvb2hlZ2toaG1qaWVvZWNoYWRkYWVqYW9raGY=" title="https://chrome.google.com/webstore/detail/refined-github/hlepfoohegkhhmjieoechaddaejaokhf">Refined GitHub<i class="fa fa-external-link"></i></span> 这个和上面的都是对 github 整体进行加强的扩展</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZ2l0aHViLWhvdmVyY2FyZC9tbW9haGJibm9qZ2tjbGdjZWFoaGFraG5jY2ltbnBsaw==" title="https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk">GitHub Hovercard<i class="fa fa-external-link"></i></span> 这个加强了 github 悬浮在某些元素上的功能</li></ul><h3 id="v2ex-plus"><a href="#v2ex-plus" class="headerlink" title="v2ex plus"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdjJleC1wbHVzL2RhZWNsaWptbm9qb2Vtb29ibGNiZmVlY2VvcG5rb2xv" title="https://chrome.google.com/webstore/detail/v2ex-plus/daeclijmnojoemooblcbfeeceopnkolo">v2ex plus<i class="fa fa-external-link"></i></span></h3><p>官方介绍：</p><blockquote><p>优雅便捷的 V2EX 扩展</p></blockquote><ul><li>帖子会话详细.</li><li>帖子列表主题预览.</li><li>只看楼主功能.</li><li>楼主回复背景色高亮(颜色可自定义).</li><li>感谢爱心颜色自定义.</li><li>插入表情与图片(weibo 或 imgur).</li><li>回复内图片旋转.</li><li>一键签到与自动签到.</li><li>新消息通知提醒并改变扩展按钮颜色.</li></ul><p>One more thing… ^-^</p><h3 id="YouTube™-广告拦截器"><a href="#YouTube™-广告拦截器" class="headerlink" title="YouTube™ 广告拦截器"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdmlkZW8tYWRibG9ja2VyLWZvci15b3V0dS9oZmxlZmpoa2ZlaWFpZ25rY2xtcGhtb2ttbWJoYmhpaw==" title="https://chrome.google.com/webstore/detail/video-adblocker-for-youtu/hflefjhkfeiaignkclmphmokmmbhbhik">YouTube™ 广告拦截器<i class="fa fa-external-link"></i></span></h3><p>这个广告拦截器会删除 YouTube 上的所有广告。前贴片视频广告，文字和横幅广告。</p><p>还有一个和 youtube 相关的扩展 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbWFnaWMtYWN0aW9ucy1mb3IteW91dHViZS9hYmpjZmFiYmhhZmJjZGZqb2VjZGdlcGxsbXBmY2VpZg==" title="https://chrome.google.com/webstore/detail/magic-actions-for-youtube/abjcfabbhafbcdfjoecdgepllmpfceif">Magic Actions for YouTube™<i class="fa fa-external-link"></i></span></p><h3 id="眼不见心不烦（新浪微博）"><a href="#眼不见心不烦（新浪微博）" class="headerlink" title="眼不见心不烦（新浪微博）"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv55y85LiN6KeB5b+D5LiN54Om77yI5paw5rWq5b6u5Y2a77yJL2FvZ25hYXBkZm5ubGRuamdsYW5mYmJrbGFha2JwZWpt" title="https://chrome.google.com/webstore/detail/眼不见心不烦（新浪微博）/aognaapdfnnldnjglanfbbklaakbpejm">眼不见心不烦（新浪微博）<i class="fa fa-external-link"></i></span></h3><p>新浪微博加强扩展，不过评论有些负面评价，我也不知道是不是真的，平时不怎么玩微博。</p><h3 id="新浪微博图床"><a href="#新浪微博图床" class="headerlink" title="新浪微博图床"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv5paw5rWq5b6u5Y2a5Zu+5bqKL2ZkZmRuZnBkcGxmYmJuZW1tbW9rbGJmamJoZWNwbmhm" title="https://chrome.google.com/webstore/detail/新浪微博图床/fdfdnfpdplfbbnemmmoklbfjbhecpnhf">新浪微博图床<i class="fa fa-external-link"></i></span></h3><p>简单好用的新浪微博图床,支持选择/拖拽/粘贴上传图片,并生成图片地址,HTML,UBB 和 Markdown 等格式,支持浏览和删除历史记录</p><h3 id="哔哩哔哩助手：bilibili-com-综合辅助扩展"><a href="#哔哩哔哩助手：bilibili-com-综合辅助扩展" class="headerlink" title="哔哩哔哩助手：bilibili.com 综合辅助扩展"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwv5ZOU5ZOp5ZOU5ZOp5Yqp5omL77yaYmlsaWJpbGljb20t57u85ZCI6L6F5Yqp5omp5bGVL2twYm5vbWJwbnBjZmZsbG5pYW5qaWJtcGFkam9sYW5o" title="https://chrome.google.com/webstore/detail/哔哩哔哩助手：bilibilicom-综合辅助扩展/kpbnombpnpcffllnianjibmpadjolanh">哔哩哔哩助手：bilibili.com 综合辅助扩展<i class="fa fa-external-link"></i></span></h3><p>哔哩哔哩弹幕网辅助扩展，拥有视频区和直播区的人性化功能。</p><p><img data-src="https://pic1.zhimg.com/v2-af198ce22b26ad2d00bc6e7a9c11adc0_b.png" alt="img"></p><h3 id="bilibili-哔哩哔哩下载助手"><a href="#bilibili-哔哩哔哩下载助手" class="headerlink" title="bilibili 哔哩哔哩下载助手"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvYmlsaWJpbGnlk5Tlk6nlk5Tlk6nkuIvovb3liqnmiYsvYmZjYmZvYmhjamJraWxjYmVobG5sY2hpaW5va2lpanA=" title="https://chrome.google.com/webstore/detail/bilibili哔哩哔哩下载助手/bfcbfobhcjbkilcbehlnlchiinokiijp">bilibili 哔哩哔哩下载助手<i class="fa fa-external-link"></i></span></h3><p>bilibili 哔哩哔哩下载助手帮你下载版权受限（能看不能缓存）的番剧和视频。</p><h2 id="前端扩展"><a href="#前端扩展" class="headerlink" title="前端扩展"></a>前端扩展</h2><h3 id="ColorZilla"><a href="#ColorZilla" class="headerlink" title="ColorZilla"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY29sb3J6aWxsYS9iaGxobmljcGJoaWduYmRoZWRnamhnZG9jbm1ob21ucA==" title="https://chrome.google.com/webstore/detail/colorzilla/bhlhnicpbhignbdhedgjhgdocnmhomnp">ColorZilla<i class="fa fa-external-link"></i></span></h3><p>取色器。</p><p><img data-src="https://pic2.zhimg.com/v2-6577f43f8cde605e2e3268514981b885_b.png" alt="img"></p><h3 id="Page-load-time"><a href="#Page-load-time" class="headerlink" title="Page load time"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcGFnZS1sb2FkLXRpbWUvZnBsb2lvbm1qZ2VjbGJrZW1pcG1rb2dvYW9oY2RiaWc=" title="https://chrome.google.com/webstore/detail/page-load-time/fploionmjgeclbkemipmkogoaohcdbig">Page load time<i class="fa fa-external-link"></i></span></h3><p>使用了 web timing API 来精确测量页面加载各个阶段的耗时，非常的简洁清晰。</p><p><img data-src="https://pic2.zhimg.com/v2-414189ca196d24e7d8c360677a7e3b1d_b.png" alt="img"></p><h3 id="CSSViewer"><a href="#CSSViewer" class="headerlink" title="CSSViewer"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY3Nzdmlld2VyL2dnZmdpamJwaWhlZWdlZmxpY2llbW9mb2JobW9mZ2Nl" title="https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce">CSSViewer<i class="fa fa-external-link"></i></span></h3><p>css 查看器。</p><p><img data-src="https://pic2.zhimg.com/v2-e0668a798cc18644c87257c3d4c4cc3d_b.png" alt="img"></p><h3 id="EditThisCookie"><a href="#EditThisCookie" class="headerlink" title="EditThisCookie"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZWRpdHRoaXNjb29raWUvZm5nbWhubnBpbGhwbGFlZWRpZmhjY2Nlb21jbGdmYmc=" title="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg">EditThisCookie<i class="fa fa-external-link"></i></span></h3><p>EditThisCookie 是一个 cookie 管理器。您可以添加，删除，编辑，搜索，锁定和屏蔽 cookies！</p><p>下面是知乎登入后的 cookie 编辑页面。</p><p><img data-src="https://pic4.zhimg.com/v2-ea286fdf8a920ab6f3709660606a9ff7_b.png" alt="img"></p><h3 id="JSON-Viewer-Awesome"><a href="#JSON-Viewer-Awesome" class="headerlink" title="JSON Viewer Awesome"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvanNvbi12aWV3ZXItYXdlc29tZS9pZW1hZGlhaGhiZWJka2xlcGFubWtqZW5mZGViZnBmZQ==" title="https://chrome.google.com/webstore/detail/json-viewer-awesome/iemadiahhbebdklepanmkjenfdebfpfe">JSON Viewer Awesome<i class="fa fa-external-link"></i></span></h3><p>美化 json 内容。</p><p><img data-src="https://pic3.zhimg.com/v2-43b9d7f1cc331f365ef969f75d36c4f6_b.png" alt="img"></p><h3 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvanNvbi1oYW5kbGUvaWFobmhmZGhpZG9tY3BnZ3BhaW1tbWFoZmZpaGtmbmo=" title="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj">JSON-handle<i class="fa fa-external-link"></i></span></h3><p>对 JSON 格式的内容进行浏览和编辑，以树形图样式展现 JSON 文档，并可实时编辑。</p><p><img data-src="https://pic1.zhimg.com/v2-a123dbaa4c088461dc5473f5372ae5b8_b.png" alt="img"></p><h3 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbGlnaHRob3VzZS9ibGlwbWRjb25sa3BpbmVmZWhubWphbW1manBtcGJqaw==" title="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk">Lighthouse<i class="fa fa-external-link"></i></span></h3><p>谷歌官方出品的一个网站性能测试，分析扩展。</p><p>下面是这个扩展生成的知乎首页的一份测试报告，可以看出知乎根本没做 PWA。</p><p><img data-src="https://pic3.zhimg.com/v2-1f13720b8d571ac49e701f62920d84e6_b.png" alt="img"></p><h3 id="Page-Ruler"><a href="#Page-Ruler" class="headerlink" title="Page Ruler"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcGFnZS1ydWxlci9lbWxpYW1pb29iZmZmYmdjZmRjaGFiZmlib25laGttZQ==" title="https://chrome.google.com/webstore/detail/page-ruler/emliamioobfffbgcfdchabfibonehkme">Page Ruler<i class="fa fa-external-link"></i></span></h3><p>一款尺寸测量工具。</p><p><img data-src="https://pic1.zhimg.com/v2-45ad6aa180403d73bed358712484a0ac_b.png" alt="img"></p><h3 id="ReRes"><a href="#ReRes" class="headerlink" title="ReRes"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVyZXMvZ2llb2Nwa2JibGlkbm9jZWZqYWtsZGVjYWhnZWVpY2E=" title="https://chrome.google.com/webstore/detail/reres/gieocpkbblidnocefjakldecahgeeica">ReRes<i class="fa fa-external-link"></i></span></h3><p>可以指定特定的 url 重定向到你想定向的 url。官方介绍：</p><blockquote><p>Change the response of the request. ReRes 可以用来更改页面请求响应的内容。通过指定规则，您可以把请求映射到其他的 url，也可以映射到本机的文件或者目录。ReRes 支持单个 url 映射，也支持目录映射。</p></blockquote><p><img data-src="https://pic4.zhimg.com/v2-9b1c50e91f7eaf0be671d5524ab318f3_b.jpg" alt="img"></p><p>另一款由阿里的一位大佬开发的可以实现跨域以及和这个插件相同功能的插件是：<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwveHN3aXRjaC9pZGtqaGpnZ3BmZm9scGlkZmtpa2lkY29rZGtkYW9nZw==" title="https://chrome.google.com/webstore/detail/xswitch/idkjhjggpffolpidfkikidcokdkdaogg">XSwitch<i class="fa fa-external-link"></i></span>。</p><h3 id="User-Agent-Switcher-and-Manager"><a href="#User-Agent-Switcher-and-Manager" class="headerlink" title="User-Agent Switcher and Manager"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdXNlci1hZ2VudC1zd2l0Y2hlci1hbmQtbS9iaGNoZGNlamhvaGZtaWdqYWZiYW1wb2dtYWFuYmZrZw==" title="https://chrome.google.com/webstore/detail/user-agent-switcher-and-m/bhchdcejhohfmigjafbampogmaanbfkg">User-Agent Switcher and Manager<i class="fa fa-external-link"></i></span></h3><p>这个扩展能让你自定义网站的 user-agent，切换不同的 user-agent，查看网页在不同的 user-agent 下的效果。</p><p><img data-src="https://pic2.zhimg.com/v2-2051037c0a827f6e4e6b74fd89f34a89_b.jpg" alt="img"></p><h3 id="WEB-前端助手-FeHelper"><a href="#WEB-前端助手-FeHelper" class="headerlink" title="WEB 前端助手(FeHelper)"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvd2Vi5YmN56uv5Yqp5omLZmVoZWxwZXIvcGtnY2NwZWpubWFsbWRpbm1oa2tmYWZlZmFnaWlpYWQ=" title="https://chrome.google.com/webstore/detail/web前端助手fehelper/pkgccpejnmalmdinmhkkfafefagiiiad">WEB 前端助手(FeHelper)<i class="fa fa-external-link"></i></span></h3><p>这个就不用介绍了吧，很多开发者都在用，国内开发者开发的一套前端工具集。</p><p><img data-src="https://pic4.zhimg.com/v2-df57f3e813aa9a3a8a6e0edbb7a6a053_b.jpg" alt="img"></p><h3 id="Restlet-Client-REST-API-Testing"><a href="#Restlet-Client-REST-API-Testing" class="headerlink" title="Restlet Client - REST API Testing"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVzdGxldC1jbGllbnQtcmVzdC1hcGktdC9hZWpvZWxhb2dnZW1iY2FoYWdpbWRpbGlhbWxjZG1mbQ==" title="https://chrome.google.com/webstore/detail/restlet-client-rest-api-t/aejoelaoggembcahagimdiliamlcdmfm">Restlet Client - REST API Testing<i class="fa fa-external-link"></i></span></h3><p>一款 restful api 测试工具，不过我一般都直接用 postman。</p><p><img data-src="https://pic2.zhimg.com/v2-c1cdeedb70a3f6d7155be34746f9e161_b.png" alt="img"></p><h3 id="VisBug"><a href="#VisBug" class="headerlink" title="VisBug"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdmlzYnVnL2Nkb2NrZW5hZG5hZGxkamJiZ2NhbGxpY2dsZWRiZW9j" title="https://chrome.google.com/webstore/detail/visbug/cdockenadnadldjbbgcallicgledbeoc">VisBug<i class="fa fa-external-link"></i></span></h3><p>谷歌公司开源的一款前端设计，调试工具。</p><p><img data-src="https://pic1.zhimg.com/v2-7ffa0b69b5f8d10650e723b51d516e78_b.png" alt="img"></p><h3 id="Moesif-Orign-amp-CORS-Changer"><a href="#Moesif-Orign-amp-CORS-Changer" class="headerlink" title="Moesif Orign &amp; CORS Changer"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbW9lc2lmLW9yaWduLWNvcnMtY2hhbmdlci9kaWdmYmZhcGhvampuZGtwY2NsamliZWpqYnBwaWZiYw==" title="https://chrome.google.com/webstore/detail/moesif-orign-cors-changer/digfbfaphojjndkpccljibejjbppifbc">Moesif Orign &amp; CORS Changer<i class="fa fa-external-link"></i></span></h3><p>解除浏览器跨域限制。</p><p><img data-src="https://pic4.zhimg.com/v2-7aa1b9f843d96b0e98d4f4e0b7f969c3_b.jpg" alt="img"></p><p>还有一些我就简要介绍一下了：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbGl2ZXJlbG9hZC9qbmloYWpiaHBucHBjZ2diY2dlZGFnbmtpZ2htZGxlaQ==" title="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">LiveReload<i class="fa fa-external-link"></i></span> liveReload 官方扩展</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVhY3QtZGV2ZWxvcGVyLXRvb2xzL2Zta2FkbWFwZ29mYWRvcGxqYmpma2FwZGtvaWVuaWhp" title="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools<i class="fa fa-external-link"></i></span> facebook 官方开发 react 开发扩展。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVkdXgtZGV2dG9vbHMvbG1oa3BtYmVrY3Bta25rbGlvZWliZmtwbW1maWJsamQ=" title="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Redux DevTools<i class="fa fa-external-link"></i></span> redux 开发扩展</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvbHVjaWQvcG5hb2VsZGxla2JmcG5hbGhhYmdna2NkZGxlZWxhbWM=" title="https://chrome.google.com/webstore/detail/lucid/pnaoeldlekbfpnalhabggkcddleelamc">lucid<i class="fa fa-external-link"></i></span> A React-GraphQL developer tool</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdnVlanMtZGV2dG9vbHMvbmhkb2dqbWVqaWdsaXBjY3Bubm5hbmhibGVkYWpicGQ=" title="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js devtools<i class="fa fa-external-link"></i></span> vue 官方开发 vue 开发扩展</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcHVwcGV0ZWVyLXJlY29yZGVyL2RqZWVnaWdnZWdsZWFka2tiZ29wb29uaGppbWdlaGRh" title="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjimgehda">Puppeteer Recorder<i class="fa fa-external-link"></i></span> 录制 puppeteer 脚本</li><li><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc2VvcXVha2UvYWtkZ25tY29nbGVlbmhiY2xnaGdobGtrZG5ka2pkamM=" title="https://chrome.google.com/webstore/detail/seoquake/akdgnmcogleenhbclghghlkkdndkjdjc">SEOquake<i class="fa fa-external-link"></i></span> 查看一个网站在各大搜索引擎的 SEO 情况</li></ul><h2 id="chrome-apps"><a href="#chrome-apps" class="headerlink" title="chrome apps"></a>chrome apps</h2><h3 id="Gliffy-Diagrams"><a href="#Gliffy-Diagrams" class="headerlink" title="Gliffy Diagrams"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZ2xpZmZ5LWRpYWdyYW1zL2JobWljaWxjbHBsZWZuZmxhcGptbm5nbWtra2twZmFk" title="https://chrome.google.com/webstore/detail/gliffy-diagrams/bhmicilclplefnflapjmnngmkkkkpfad">Gliffy Diagrams<i class="fa fa-external-link"></i></span></h3><p>有了它，就可以替代 process on, draw.io 之类的在线画图工具了。</p><p><img data-src="https://pic3.zhimg.com/v2-672f3504cf12e2076130451ff31b290e_b.png" alt="img"></p><h3 id="Secure-Shell-App"><a href="#Secure-Shell-App" class="headerlink" title="Secure Shell App"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc2VjdXJlLXNoZWxsLWFwcC9wbmhlY2hhcGZhaW5kamhvbXBibmZsY2xkYWJiZ2hqbw==" title="https://chrome.google.com/webstore/detail/secure-shell-app/pnhechapfaindjhompbnflcldabbghjo">Secure Shell App<i class="fa fa-external-link"></i></span></h3><p>一个终端模拟器，ssh 客户端，有兴趣可以体验一下，我自己是没怎么用过。</p><p><img data-src="https://pic4.zhimg.com/v2-25d3cfebbd4b62c917cc82ba2aefc26f_b.png" alt="img"></p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdGV4dC9tbWZiY2xqZmdsYm9rcG1raW1iZmdoZGtqbWpoZGdiZw==" title="https://chrome.google.com/webstore/detail/text/mmfbcljfglbokpmkimbfghdkjmjhdgbg">Text<i class="fa fa-external-link"></i></span></h3><p>一款文本编辑器，支持语法高亮，还可以保存内容到 Google Drive 上。</p><p><img data-src="https://pic3.zhimg.com/v2-eb2589a282ad738f4e7c707d8aaccd6a_b.png" alt="img"></p><h3 id="Codelf-Best-GitHub-Stars-organizer"><a href="#Codelf-Best-GitHub-Stars-organizer" class="headerlink" title="Codelf-Best GitHub Stars organizer"></a><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvY29kZWxmLWJlc3QtZ2l0aHViLXN0YXJzL2pubWphZ2xobW1jcGxla3BmbmJsbmlpYW1tbWRwYWFu" title="https://chrome.google.com/webstore/detail/codelf-best-github-stars/jnmjaglhmmcplekpfnblniiammmdpaan">Codelf-Best GitHub Stars organizer<i class="fa fa-external-link"></i></span></h3><p>程序员命名工具，像我这种英语渣时不时就会碰到给变量名取名字头疼的时候，这个时候不妨打开这个 app 解决你的命名烦恼。</p><p><img data-src="https://pic1.zhimg.com/v2-8ebd5803a3ef05d8b5e66aeabcde5d8c_b.png" alt="img"></p><h2 id="chrome-扩展，插件，App-的区别"><a href="#chrome-扩展，插件，App-的区别" class="headerlink" title="chrome 扩展，插件，App 的区别"></a><strong>chrome 扩展，插件，App 的区别</strong></h2><p>这部分内容我刻意放到后面，怕一些非专业用户看不懂。我觉得我还是有必要提一下的，它们几个其实是有很大区别的。</p><p>扩展叫 <strong>extension，</strong>你可以通过访问地址：chrome://extensions/ 查看所有扩展，所有启用的 chrome 扩展都会显示在右上角工具栏上。我们在 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZQ==" title="https://chrome.google.com/webstore">chrome 应用商店<i class="fa fa-external-link"></i></span> 下载安装的一般就是 chrome 扩展，当然了，chrome 应用商店除了扩展还可以安装主题和 app。技术上来说指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + CSS + JavaScript 语言开发。例如油猴 tampermonkey，AD Block 等。</p><p>插件叫 <strong>plugin，</strong>是更底层的 chrome 组件，可以通过访问地址：chrome://plugins/ 查看所有插件。从技术角度来说，指的是通过调用 Webkit 内核 NPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C/C++、Delphi 等。比如 Flash player 插件，就属于这种类型。一般在网页中用 <object>或者<embed>标签声明的部分，就要靠插件来渲染。</object></p><p>参考知乎问题：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNjI4NzY4" title="https://www.zhihu.com/question/20628768">Chrome 的插件（Plugin）与扩展（Extension）有什么区别？<i class="fa fa-external-link"></i></span></p><p>而 chrome APP 则是指那些可以独立于 chrome 窗口的应用，有点像 PWA 和 electron。你可以理解为就是普通的桌面软件，只不过是用网页技术开发的。例如 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvc2VjdXJlLXNoZWxsLWFwcC9wbmhlY2hhcGZhaW5kamhvbXBibmZsY2xkYWJiZ2hqbw==" title="https://chrome.google.com/webstore/detail/secure-shell-app/pnhechapfaindjhompbnflcldabbghjo">Secure Shell App<i class="fa fa-external-link"></i></span>。</p><h2 id="推广下自己的-chrome-扩展开发模板"><a href="#推广下自己的-chrome-扩展开发模板" class="headerlink" title="推广下自己的 chrome 扩展开发模板"></a><strong>推广下自己的 chrome 扩展开发模板</strong></h2><p>我前不久写了一个 chrome 扩展，开发完后将它的构建配置提取封装成一个模板项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9hd2Vzb21lLWNocm9tZS1leHRlbnNpb24tYm9pbGVycGxhdGU=" title="https://github.com/tjx666/awesome-chrome-extension-boilerplate">awesome-chrome-extension-boilerplate<i class="fa fa-external-link"></i></span>。有以下特性：</p><ul><li>支持修改 content scripts 代码自动重载扩展和刷新注入了 content scripts 的页面（通过自定义 devServer 和 SSE）</li><li>选项和弹窗页面支持 react &amp; react hooks &amp; react hot reload &amp; react devtools，充分享受现代前端工程化的便捷，让你从开发 SPA 无缝切换到 chrome 扩展开发。</li><li>整个模板包括 webpack 配置和 devServer 都是用 TypeScript 编写的，使用 ts 配置 webpack 减少你查阅文档次数和手残的概率。</li><li>支持 sass/less CSS 扩展语言，使用 mini-css-extract-plugin 插件将 CSS 分离成 content CSS Script</li><li>集成了社区很多的优秀 webpack 插件优化 webpack 构建和 bundle 分析</li><li>使用 eslint 和相关插件 lint TypeScript。使用 babel 编译 TypeScript，fork-ts-checker-webpack-plugin 检查 TypeScript 类型，在享受 babel 生态中各种实用的插件的同时还不丢失类型检查的能力。</li></ul><p>对第一条特性感兴趣的的读者可以再阅读我另外一篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDMwNzIyNTE=" title="https://zhuanlan.zhihu.com/p/103072251">使用 webpack 构建 chrome 扩展的热更新问题<i class="fa fa-external-link"></i></span>。</p><h2 id="chrome-应用商店的新政策"><a href="#chrome-应用商店的新政策" class="headerlink" title="chrome 应用商店的新政策"></a><strong>chrome 应用商店的新政策</strong></h2><p>最近我在逛 V2EX 的时候看到有人提到 FEHelper 被下架的事情。我到<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHVmZS5jb20vaXRlbS85NTY1YzQ1NDUwZDJmZWU4ZTNlZS5odG1s" title="https://www.baidufe.com/item/9565c45450d2fee8e3ee.html">作者的博客<i class="fa fa-external-link"></i></span>看了一下，了解到是因为违反了 chrome 应用商店的新政策。新政策规定发布的所有扩展必须遵守单一用途原则，否则强制下架。联想到最近我发布 chrome 扩展的时候，看到 chrome 控制台将要改版，我觉得可能 google 这两年有意要整改 chrome 扩展生态了。</p><p>另一个要说的事情是在知乎上我看到有人评论 _chrome 应用商店今年就关了_。我特意去查了一下相关资讯，其实是他理解错了，不是 chrome 应用商店要关闭了，只是将停止对 chrome App 的支持。可以看一下雷锋网的这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTY1NTkzMTM1ODkwNDk3MDIzOSZ3ZnI9c3BpZGVyJmZvcj1wYw==" title="https://baijiahao.baidu.com/s?id=1655931358904970239&wfr=spider&for=pc">谷歌宣布两年内关闭 Chrome Apps<i class="fa fa-external-link"></i></span>。我贴一下时间表：</p><blockquote><p><strong>雷锋网整理出的正式时间表：</strong> 2020 年 3 月：Chrome 网上应用商店停止接受新的 Chrome Apps。开发者可以在 2022 年 6 月之前更新现有的 Chrome Apps。 2020 年 6 月：终止对 Windows，Mac 和 Linux 上的 Chrome Apps 的支持。拥有 Chrome Enterprise 和 Chrome Education Upgrade 的客户可以访问一项政策，将支持延长至 2020 年 12 月。 2020 年 12 月：终止对 Windows，Mac 和 Linux 上的 Chrome Apps 的支持。 2021 年 6 月：终止对 NaCl，PNaCl 和 PPAPI API 的支持。 2021 年 6 月：终止对 Chrome 操作系统上的 Chrome Apps 的支持。拥有 Chrome 企业升级版的客户可以访问一项政策，但是仅支持期限延长至 2022 年 6 月。 2022 年 6 月：对所有客户停止支持 Chrome OS 上的 Chrome Apps。 雷锋网总结这份时间表，Chrome Apps 在上市近 7 年之后，将从 2020 年 3 月开始一步步消失，届时 Chrome Apps 将不再接受新的应用，虽然现有的 App 将一直保持可用状态，但是最终仅维持到 2022 年 6 月。</p></blockquote><p>这篇文章也提到了为什么 Google 对 chrome App 不上心了。其实主要还是因为要推 PWA 嘛，19 年的 Google 开发者大会上，重点之一就是 PWA。我猜那几款 chrome app 到时候有可能会被移植到 PWA 上，不过我觉得更有可能的是 electron。其实已经有很成功的先例了，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pncmFwaC9kcmF3aW8tZGVza3RvcA==" title="https://github.com/jgraph/drawio-desktop">draw.io<i class="fa fa-external-link"></i></span> 这款非常强大的 web 流程图工具就已经被移植到了 electron 上。</p><h2 id="写在最后的一些话"><a href="#写在最后的一些话" class="headerlink" title="写在最后的一些话"></a>写在最后的一些话</h2><p>这篇文章有点长，能看到这也是不容易。很多人是文章太长就不看的（＞人＜；）。别看我说了这么多扩展，我平时也不会把这么多插件全开着，有些扩展还是挺占用内存的。点击 chrome 右上角三个点，选择更多工具 -&gt; 任务管理器就可以打开 chrome 中个进程占用资源情况：</p><p><img data-src="https://pic3.zhimg.com/v2-92ac7cdcbcb0a4f43240d5fda65ebba2_b.png" alt="img"></p><p>如果有什么问题或者你有更好的扩展推荐，不妨在评论区留言，我一般都会积极回复。最后，<strong>感谢广大 chrome 扩展开发者，是你们的无私奉献让我们能够用上这些这么棒的扩展。</strong>我觉得吧，如果说某款扩展确实给自己的生活和工作带来了很大帮助，不妨在能力之内捐赠支持一下扩展的作者，毕竟扩展的维护需要作者的精力甚至说不小的资金。</p><p>再补充一句：知乎 markdown 导入真垃圾，图片总是无法上传 😤</p><p>感谢您的阅读，如果对你有所帮助不妨加个关注，点个赞支持一下 O(∩_∩)O。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29tLw==" title="http://www.lyreal666.com/">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>chrome extension</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 nodejs 写爬虫(二): 抓取 github 热门项目</title>
    <url>/%E4%BD%BF%E7%94%A8-nodejs-%E5%86%99%E7%88%AC%E8%99%AB-%E4%BA%8C-%E6%8A%93%E5%8F%96-github-%E7%83%AD%E9%97%A8%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>其实爬虫是一个对计算机综合能力要求比较高的技术活。</p><p>首先是要对网络协议尤其是 <code>http</code> 协议有基本的了解, 能够分析网站的数据请求响应。学会使用一些工具，简单的情况使用 chrome devtools 的 network 面板就够了。我一般还会配合 postman 或者 charles 来分析，更复杂的情况可能举要使用专业的抓包工具比如 wireshark 了。你对一个网站了解的越深，越容易想出简单的方式来爬取你想获取的信息。</p><p>除了要了解一些计算机网络的知识，你还需要具备一定的字符串处理能力，具体来说就是正则表达式玩的溜，其实正则表达式一般的使用场景下用不到很多高级知识，比较常用的有点小复杂的就是分组，非贪婪匹配等。俗话说，学好正则表达式，处理字符串都不怕 🤣。</p><p>还有就是掌握一些反爬虫技巧，写爬虫你可能会碰到各种各样的问题，但是不要怕，再复杂的 12306 都有人能够爬，还有什么是能难到我们的。常见的爬虫碰到的问题比如服务器会检查 cookies, 检查 host 和 referer 头，表单中有隐藏字段，验证码，访问频率限制，需要代理, spa 网站等等。其实啊，绝大多数爬虫碰到的问题最终都可以通过操纵浏览器爬取的。</p><p>这篇使用 nodejs 写爬虫系列第二篇。实战一个小爬虫，抓取 github 热门项目。想要达到目标:</p><ol><li>学会从网页源代码中提取数据这种最基本的爬虫</li><li>使用 json 文件保存抓取的数据</li><li>熟悉我上一篇介绍的一些模块</li><li>学会 node 中怎样处理用户输入</li></ol><a id="more"></a><h2 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h2><p>我们的需求是从 github 上抓取热门项目数据，也就是 star 数排名靠前的项目。但是 github 好像没有哪个页面可以看到排名靠前的项目。<strong>往往网站提供的搜索功能是我们写爬虫的人分析的重点对象</strong>。</p><p>我之前在 v2ex 灌水的时候，看到一个讨论 <code>996</code> 的帖子上刚好教了一个查看 github stars 数前几的仓库的方法。其实很简单，就是在 github 搜索时加上 star 数的过滤条件比如: <code>stars:&gt;60000</code>，就可以搜索到 github 上所有 star 数大于 60000 的仓库。分析下面的截图，注意图片中的注释:</p><p><img data-src="https://i.loli.net/2019/04/04/5ca59077e7a3e.png" alt="github-hot-projects"></p><p>分析一下可以得出以下信息:</p><ol><li>这个搜索结果页面是通过 get 请求返回 html 文档的，因为我 network 选择了 <code>Doc</code> 过滤</li><li>url 中的请求的参数有 3 个，p(page) 代表页面数，q(query) 代表搜索内容，type 代表搜索内容的类型</li></ol><p>然后我又想 github 会不会检查 cookies 和其它请求头比如 referer，host 等，根据是否有这些请求头决定是否返回页面。</p><p><img data-src="https://i.loli.net/2019/04/04/5ca592da2bb41.png" alt="request headers"></p><p>比较简单的测试方法是直接用命令行工具 <code>curl</code> 来测试, 在 gitbash 中输入下面命令即 <code>curl &quot;请求的url&quot;</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">"https://github.com/search?p=2&amp;q=stars%3A%3E60000&amp;type=Repositories"</span></span><br></pre></td></tr></table></figure><p>不出意外的正常的返回了页面的源代码, 这样的话我们的爬虫脚本就不用加上请求头和 cookies 了。</p><p><img data-src="https://i.loli.net/2019/04/04/5ca594909a591.png" alt="gitbash-curl-github"></p><p>通过 chrome 的搜索功能，我们可以看到网页源代码中就有我们需要的项目信息</p><p><img data-src="https://i.loli.net/2019/04/04/5ca595318c77b.png" alt="source code search"></p><p>分析到此结束，这其实就是一个很简单的小爬虫，我们只需要配置好查询参数，通过 http 请求获取到网页源代码，然后利用解析库解析，获取源代码中我们需要的和项目相关的信息，再处理一下数据成数组，最后序列化成 json 字符串存储到到 json 文件中。</p><p><img data-src="https://i.loli.net/2019/04/04/5ca5bb4f43e12.png" alt="postman-github-search"></p><h2 id="动手来实现这个小爬虫"><a href="#动手来实现这个小爬虫" class="headerlink" title="动手来实现这个小爬虫"></a>动手来实现这个小爬虫</h2><h3 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h3><p>想要通过 node 获取源代码，我们需要先配置好 url 参数， 再通过 superagent 这个发送 http 请求的模块来访问配置好的 url。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> requests = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> constants = <span class="built_in">require</span>(<span class="string">'../config/constants'</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'../config/log4jsConfig'</span>).log4js.getLogger(<span class="string">'githubHotProjects'</span>);</span><br><span class="line"><span class="keyword">const</span> requestUtil = <span class="built_in">require</span>(<span class="string">'./utils/request'</span>);</span><br><span class="line"><span class="keyword">const</span> models = <span class="built_in">require</span>(<span class="string">'./models'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 star 数不低于 starCount k 的项目第 page 页的源代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>starCount star 数量下限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>page 页数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> crawlSourceCode = <span class="keyword">async</span> (starCount, page = <span class="number">1</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 下限为 starCount k star 数</span></span><br><span class="line">  starCount = starCount * <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 替换 url 中的参数</span></span><br><span class="line">  <span class="keyword">const</span> url = constants.searchUrl.replace(<span class="string">'$&#123;starCount&#125;'</span>, starCount).replace(<span class="string">'$&#123;page&#125;'</span>, page);</span><br><span class="line">  <span class="comment">// response.text 即为返回的源代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">text</span>: sourceCode &#125; = <span class="keyword">await</span> requestUtil.logRequest(requests.get(<span class="built_in">encodeURI</span>(url)));</span><br><span class="line">  <span class="keyword">return</span> sourceCode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中的 constants 模块是用来保存项目中的一些常量配置的，到时候需要改常量直接改这个配置文件就行了，而且配置信息更集中，便于查看。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  searchUrl: <span class="string">'https://github.com/search?q=stars:&gt;$&#123;starCount&#125;&amp;p=$&#123;page&#125;&amp;type=Repositories'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析源代码获取项目信息"><a href="#解析源代码获取项目信息" class="headerlink" title="解析源代码获取项目信息"></a>解析源代码获取项目信息</h3><p>这里我把项目信息抽象成了一个 Repository 类了。在项目的 models 目录下的 Repository.js 中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> saveToLocal(repositories, indent = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> fs.writeJSON(path.resolve(__dirname, <span class="string">'../../out/repositories.json'</span>), repositories, &#123; <span class="attr">spaces</span>: indent &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(&#123; name, author, language, digest, starCount, lastUpdate &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.language = language;</span><br><span class="line">    <span class="keyword">this</span>.digest = digest;</span><br><span class="line">    <span class="keyword">this</span>.starCount = starCount;</span><br><span class="line">    <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`   项目: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 作者: <span class="subst">$&#123;<span class="keyword">this</span>.author&#125;</span> 语言: <span class="subst">$&#123;<span class="keyword">this</span>.language&#125;</span> star: <span class="subst">$&#123;<span class="keyword">this</span>.starCount&#125;</span></span></span><br><span class="line"><span class="string">摘要: <span class="subst">$&#123;<span class="keyword">this</span>.digest&#125;</span></span></span><br><span class="line"><span class="string">最后更新: <span class="subst">$&#123;<span class="keyword">this</span>.lastUpdate&#125;</span></span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析获取到的源代码我们需要使用 cheerio 这个解析库，使用方式和 jquery 很相似。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 star 数不低于 starCount k 的项目页表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>starCount star 数量下限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>page 页数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> crawlProjectsByPage = <span class="keyword">async</span> (starCount, page = <span class="number">1</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sourceCode = <span class="keyword">await</span> crawlSourceCode(starCount, page);</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(sourceCode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面 cheerio 如果 jquery 比较熟应该没有障碍, 不熟的话 github 官方仓库可以查看 api, api 并不是很多</span></span><br><span class="line">  <span class="comment">// 查看 elements 面板, 发现每个仓库的信息在一个 li 标签内, 下面的代码时建议打开开发者工具的 elements 面板, 参照着阅读</span></span><br><span class="line">  <span class="keyword">const</span> repositoryLiSelector = <span class="string">'.repo-list-item'</span>;</span><br><span class="line">  <span class="keyword">const</span> repositoryLis = $(repositoryLiSelector);</span><br><span class="line">  <span class="keyword">const</span> repositories = [];</span><br><span class="line">  repositoryLis.each(<span class="function">(<span class="params">index, li</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> $li = $(li);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取带有仓库作者和仓库名的 a 链接</span></span><br><span class="line">    <span class="keyword">const</span> nameLink = $li.find(<span class="string">'h3 a'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取出仓库名和作者名</span></span><br><span class="line">    <span class="keyword">const</span> [author, name] = nameLink.text().split(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取项目摘要</span></span><br><span class="line">    <span class="keyword">const</span> digestP = $($li.find(<span class="string">'p'</span>)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> digest = digestP.text().trim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取语言</span></span><br><span class="line">    <span class="comment">// 先获取类名为 .repo-language-color 的那个 span, 在获取包含语言文字的父 div</span></span><br><span class="line">    <span class="comment">// 这里要注意有些仓库是没有语言的, 是获取不到那个 span 的, language 为空字符串</span></span><br><span class="line">    <span class="keyword">const</span> languageDiv = $li.find(<span class="string">'.repo-language-color'</span>).parent();</span><br><span class="line">    <span class="comment">// 这里注意使用 String.trim() 去除两侧的空白符</span></span><br><span class="line">    <span class="keyword">const</span> language = languageDiv.text().trim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 star 数量</span></span><br><span class="line">    <span class="keyword">const</span> starCountLinkSelector = <span class="string">'.muted-link'</span>;</span><br><span class="line">    <span class="keyword">const</span> links = $li.find(starCountLinkSelector);</span><br><span class="line">    <span class="comment">// 选择器为 .muted-link 还有可能是那个 issues 链接</span></span><br><span class="line">    <span class="keyword">const</span> starCountLink = $(links.length === <span class="number">2</span> ? links[<span class="number">1</span>] : links[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> starCount = starCountLink.text().trim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后更新时间</span></span><br><span class="line">    <span class="keyword">const</span> lastUpdateElementSelector = <span class="string">'relative-time'</span>;</span><br><span class="line">    <span class="keyword">const</span> lastUpdate = $li</span><br><span class="line">      .find(lastUpdateElementSelector)</span><br><span class="line">      .text()</span><br><span class="line">      .trim();</span><br><span class="line">    <span class="keyword">const</span> repository = <span class="keyword">new</span> models.Repository(&#123;</span><br><span class="line">      name,</span><br><span class="line">      author,</span><br><span class="line">      language,</span><br><span class="line">      digest,</span><br><span class="line">      starCount,</span><br><span class="line">      lastUpdate,</span><br><span class="line">    &#125;);</span><br><span class="line">    repositories.push(repository);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> repositories;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有时候搜索结果是有很多页的，所以我这里又写了一个新的函数用来获取指定页面数量的仓库。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crawlProjectsByPagesCount = <span class="keyword">async</span> (starCount, pagesCount) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (pagesCount === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    pagesCount = <span class="keyword">await</span> getPagesCount(starCount);</span><br><span class="line">    logger.warn(<span class="string">`未指定抓取的页面数量, 将抓取所有仓库, 总共<span class="subst">$&#123;pagesCount&#125;</span>页`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allRepositories = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tasks = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: pagesCount &#125;, (ele, index) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 因为页数是从 1 开始的, 所以这里要 i + 1</span></span><br><span class="line">    <span class="keyword">return</span> crawlProjectsByPage(starCount, index + <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Promise.all 来并发操作</span></span><br><span class="line">  <span class="keyword">const</span> resultRepositoriesArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">  resultRepositoriesArray.forEach(<span class="function"><span class="params">repositories</span> =&gt;</span> allRepositories.push(...repositories));</span><br><span class="line">  <span class="keyword">return</span> allRepositories;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="让爬虫项目更人性化"><a href="#让爬虫项目更人性化" class="headerlink" title="让爬虫项目更人性化"></a>让爬虫项目更人性化</h3><p>只是写个脚本，在代码里面配置参数然后去爬，这有点太简陋了。这里我使用了一个可以同步获取用户输入的库<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fuc2VraS9yZWFkbGluZS1zeW5j" title="https://github.com/anseki/readline-sync">readline-sync<i class="fa fa-external-link"></i></span>，加了一点用户交互，后续的爬虫教程我可能会考虑使用 electron 来做个简单的界面, 下面是程序的启动代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readlineSync = <span class="built_in">require</span>(<span class="string">'readline-sync'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; crawlProjectsByPage, crawlProjectsByPagesCount &#125; = <span class="built_in">require</span>(<span class="string">'./crawlHotProjects'</span>);</span><br><span class="line"><span class="keyword">const</span> models = <span class="built_in">require</span>(<span class="string">'./models'</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'../config/log4jsConfig'</span>).log4js.getLogger(<span class="string">'githubHotProjects'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> isContinue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> starCount = readlineSync.questionInt(<span class="string">`输入你想要抓取的 github 上项目的 star 数量下限, 单位(k): `</span>, &#123;</span><br><span class="line">      encoding: <span class="string">'utf-8'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> crawlModes = [<span class="string">'抓取某一页'</span>, <span class="string">'抓取一定数量页数'</span>, <span class="string">'抓取所有页'</span>];</span><br><span class="line">    <span class="keyword">const</span> index = readlineSync.keyInSelect(crawlModes, <span class="string">'请选择一种抓取模式'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repositories = [];</span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">        <span class="keyword">const</span> page = readlineSync.questionInt(<span class="string">'请输入你要抓取的具体页数: '</span>);</span><br><span class="line">        repositories = <span class="keyword">await</span> crawlProjectsByPage(starCount, page);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="keyword">const</span> pagesCount = readlineSync.questionInt(<span class="string">'请输入你要抓取的页面数量: '</span>);</span><br><span class="line">        repositories = <span class="keyword">await</span> crawlProjectsByPagesCount(starCount, pagesCount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">        repositories = <span class="keyword">await</span> crawlProjectsByPagesCount(starCount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories.forEach(<span class="function"><span class="params">repository</span> =&gt;</span> repository.display());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isSave = readlineSync.keyInYN(<span class="string">'请问是否要保存到本地(json 格式) ?'</span>);</span><br><span class="line">    isSave &amp;&amp; models.Repository.saveToLocal(repositories);</span><br><span class="line">    isContinue = readlineSync.keyInYN(<span class="string">'继续还是退出 ?'</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> (isContinue);</span><br><span class="line">  logger.info(<span class="string">'程序正常退出...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h3 id="来看看最后的效果"><a href="#来看看最后的效果" class="headerlink" title="来看看最后的效果"></a>来看看最后的效果</h3><p>这里要提一下 readline-sync 的一个 bug,，在 windows 上, vscode 中使用 git bash 时，中文会乱码，无论你文件格式是不是 utf-8。搜了一些 issues， 在 powershell 中切换编码为 utf-8 就可以正常显示，也就是把页码切到 <code>65001</code>。</p><p><img data-src="https://i.loli.net/2019/04/05/5ca71256f4137.png" alt="example"></p><p><img data-src="https://i.loli.net/2019/04/05/5ca711441ccb8.png" alt="repositories-json"></p><p>项目的完整源代码以及后续的教程源代码都会保存在我的 github 仓库: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqeDY2Ni9TcGlkZXJz" title="https://github.com/tjx666/Spiders">Spiders<i class="fa fa-external-link"></i></span>。如果我的教程对您有帮助，希望不要吝啬您的 star 😊。后续的教程可能就是一个更复杂的案例，通过分析 ajax 请求来直接访问接口。</p>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>spider</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>总结下 javascript 中的一些小技巧</title>
    <url>/%E6%80%BB%E7%BB%93%E4%B8%8B-javascript-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>这篇文章主要记录一下平时自己实践得到的, 博客中学习的以及在一些项目源码中看到的 javascript 技巧。有些东西可以说是奇淫技巧，有些可能是 ES6+ 中一些比较具有实用性的新语法。</p><a id="more"></a><h3 id="amp-amp-和-的妙用"><a href="#amp-amp-和-的妙用" class="headerlink" title="&amp;&amp; 和 || 的妙用"></a>&amp;&amp; 和 || 的妙用</h3><p>有时候我们需要在某个函数或变量为 true 时执行另外一个函数。例如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行 task1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt;= <span class="number">0.5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'task1 执行成功后执行 task2'</span>);</span><br><span class="line"><span class="keyword">if</span> (task1()) task2();</span><br></pre></td></tr></table></figure><p>上面的 if 语句可以使用 <code>&amp;&amp;</code> 直接简写为:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">task1() &amp;&amp; task2();</span><br></pre></td></tr></table></figure><p>如果还要在 task1 失败(也就是 task1 返回 false)后执行 task3, 可以使用:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task3 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'task1 执行失败后执行 task3'</span>);</span><br><span class="line">(task1() &amp;&amp; task2()) || task3();</span><br></pre></td></tr></table></figure><p>本质上还是利用了 <code>&amp;&amp;</code> 和 <code>||</code> 的短路特性。</p><p>其实这里使用条件运算符也是可以的:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">task1() ? task2() : task3();</span><br></pre></td></tr></table></figure><p>下面展示的我最近的一个使用 <strong>react hooks</strong> 开发的项目中的一个代码片段，这里利用了 <strong>render props</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ProfileItem = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, value, render &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"profile-item"</span>&gt;</span><br><span class="line">      &lt;span className=<span class="string">"item-name"</span>&gt;&#123;name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form action=""&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 根据是否有 render 这个 props 来返回不同的内容 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;(render &amp;&amp; render(props)) || &lt;SimpleProfileItemContent value=&#123;value&#125; /</span>&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><h4 id="ES5-版本"><a href="#ES5-版本" class="headerlink" title="ES5 版本"></a>ES5 版本</h4><p>使用短路或操作符来设置函数默认值的方式其实很常见。但是有一些坑，下面展示的代码中当默认值参数为一个数字时，传参为 0 还是会使用默认值，必须对 y 为 0 的时候单独进行判断。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  y = y || <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, max = y; i &lt; max; i++) &#123;</span><br><span class="line">    result *= x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>)); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 y 传值为 0 时, y 取值 2</span></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure><h4 id="ES6-版本"><a href="#ES6-版本" class="headerlink" title="ES6 版本"></a>ES6 版本</h4><p>ES6 在语法层面提供的默认值语法就靠谱的多了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, y = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, max = y; i &lt; max; i++) &#123;</span><br><span class="line">    result *= x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>)); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 8</span></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="类数组转数组"><a href="#类数组转数组" class="headerlink" title="类数组转数组"></a>类数组转数组</h3><p>类数组指的是像 <code>arguments</code> ，<code>jquery</code> 对象一样可以使用下标访问还有 length 属性的和数组很像但并不是数组的一类对象。</p><p>类数组没有 <code>slice</code>, <code>map</code> 等集合函数，这也是为什么我们有时候需要将类数组转换成数组的原因。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, max = <span class="built_in">arguments</span>.length; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line">  <span class="comment">// 类数组没有 slice, forEach, map 等集合函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.slice === <span class="literal">undefined</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Google'</span>, <span class="string">'facebook'</span>, <span class="string">'Microsoft'</span>);</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">// Google</span></span><br><span class="line"><span class="comment">// facebook</span></span><br><span class="line"><span class="comment">// Microsoft</span></span><br></pre></td></tr></table></figure><h4 id="ES5-中的转换方法"><a href="#ES5-中的转换方法" class="headerlink" title="ES5 中的转换方法"></a>ES5 中的转换方法</h4><p>将 Array 原型中的 slice 方法绑定到 arguments 对象上调用，并且不传参数目的为了让其返回所有的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(array.slice(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Google'</span>, <span class="string">'facebook'</span>, <span class="string">'Microsoft'</span>); <span class="comment">// =&gt; [ 'Google' ]</span></span><br></pre></td></tr></table></figure><h4 id="ES6-中的转换方法"><a href="#ES6-中的转换方法" class="headerlink" title="ES6 中的转换方法"></a>ES6 中的转换方法</h4><p>ES6 将类数组转换成数组的方法多一些。</p><p>使用扩展运算符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([...arguments]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Google'</span>, <span class="string">'facebook'</span>, <span class="string">'Microsoft'</span>); <span class="comment">// [ 'Google', 'facebook', 'Microsoft' ]</span></span><br></pre></td></tr></table></figure><p>使用 Array.from</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Google'</span>, <span class="string">'facebook'</span>, <span class="string">'Microsoft'</span>); <span class="comment">// [ 'Google', 'facebook', 'Microsoft' ]</span></span><br></pre></td></tr></table></figure><h3 id="构造一个连续整数的数组"><a href="#构造一个连续整数的数组" class="headerlink" title="构造一个连续整数的数组"></a>构造一个连续整数的数组</h3><p>这里就直接给出我觉得最好的方法了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 2 开始连续的8个整数</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">8</span> &#125;).map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> index + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; [ 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 评论区指出有更简洁的版本, Array.from 自带的映射函数</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">8</span> &#125;, (ele, index) =&gt; index + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; [ 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有一个网友指出可以利用 Array.prototype.keys 来构造</span></span><br><span class="line"><span class="keyword">const</span> array = [...Array(<span class="number">8</span>).keys()].map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> index + <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="函数参数使用解构赋值"><a href="#函数参数使用解构赋值" class="headerlink" title="函数参数使用解构赋值"></a>函数参数使用解构赋值</h3><p>函数参数比较多的时候我们往往会让参数直接接受一个配置对象。但是使用对象参数我们无法设置默认值，在函数体中使用对象参数时还需要使用通过对象参数来访问，当访问次数比较多或者嵌套比较深就会觉得不方便。在函数参数中使用解构赋值就解决了上面的问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须给对象参数设置默认值, 不然传参数时因为没有解构对象会报错</span></span><br><span class="line"><span class="keyword">const</span> getUsers = <span class="function">(<span class="params">&#123; offset = <span class="number">0</span>, limit = <span class="number">1</span>, orderBy = <span class="string">'salary'</span> &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 根据条件查询数据库返回用户数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(&#123; offset, limit, orderBy &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getUsers(&#123; <span class="attr">offset</span>: <span class="number">10</span>, <span class="attr">limit</span>: <span class="number">20</span>, <span class="attr">orderBy</span>: <span class="string">'age'</span> &#125;); <span class="comment">// =&gt; &#123; offset: 10, limit: 20, orderBy: 'age' &#125;</span></span><br><span class="line">getUsers(); <span class="comment">// =&gt; &#123; offset: 0, limit: 1, orderBy: 'salary' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用-将其它类型转换成-bool-型"><a href="#使用-将其它类型转换成-bool-型" class="headerlink" title="使用 !! 将其它类型转换成 bool 型"></a>使用 !! 将其它类型转换成 bool 型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!![]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpGet = <span class="function">(<span class="params">url, retry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!!retry) &#123;</span><br><span class="line">    <span class="comment">// 超时重发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><h4 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h4><p>使用先序列化再反序列化这种方式来深度克隆对象在一般情况下很方便，缺点就是无法克隆函数以及继承的属性。</p><p>如果还要克隆函数属性，推荐使用 lodash 的 cloneDeep。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">  name: <span class="string">'lyreal666'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, I'm ly!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clonedMe = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(me));</span><br><span class="line"><span class="built_in">console</span>.log(clonedMe); <span class="comment">// =&gt; &#123; name: 'lyreal666', age: 23 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(clonedMe.speak === <span class="literal">undefined</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="使用第二个和第三参数"><a href="#使用第二个和第三参数" class="headerlink" title="使用第二个和第三参数"></a>使用第二个和第三参数</h4><p>JSON.stringify 的第二个参数是用来对属性值进行处理的，第三个参数则是用来指定输出的 json 字符串的缩进长度，可以传数字也可以传字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">  name: <span class="string">'lyreal666'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, I'm ly!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonStr = <span class="built_in">JSON</span>.stringify(me, (key, value) =&gt; (key === <span class="string">'name'</span> ? <span class="string">'老余'</span> : value), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonStr);</span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "name": "老余",</span></span><br><span class="line"><span class="comment">  "age": 23</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="优雅的遍历对像"><a href="#优雅的遍历对像" class="headerlink" title="优雅的遍历对像"></a>优雅的遍历对像</h3><p>使用解构赋值和 Object.entries。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">  name: <span class="string">'lyreal666'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, I'm ly!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(me)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">name: lyreal666</span></span><br><span class="line"><span class="comment">age: 23</span></span><br><span class="line"><span class="comment">speak: speak() &#123;</span></span><br><span class="line"><span class="comment">        console.log(`Hello, I'm ly!`);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="清空数组的最快方法"><a href="#清空数组的最快方法" class="headerlink" title="清空数组的最快方法"></a>清空数组的最快方法</h3><p>评论区有人说这种直接修改 <code>length</code> 的做法是有问题的, 我之前也看过关于清空数组的方法的讨论, 但是我觉得一般情况下这样用是没什么问题的, 既简单, 又不用重新分配内存给新数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">array.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网友指出可以更好的方式是直接赋值空数组</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">array = [];</span><br></pre></td></tr></table></figure><h3 id="判断一个整数是否是-1"><a href="#判断一个整数是否是-1" class="headerlink" title="判断一个整数是否是 -1"></a>判断一个整数是否是 -1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~ 操作符的运算规律可以简单记作将加一的结果取反</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">1</span>); <span class="comment">// =&gt; -2</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">0</span>); <span class="comment">// =&gt; -1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">-3</span>); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">-1</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> number = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否为 -1</span></span><br><span class="line"><span class="keyword">if</span> (!~number) &#123;</span><br><span class="line">  <span class="comment">// 当 number 是 -1 的操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>立即执行函数可以让我们的代码中的变量不污染外部变量，常见的使用方式是像下面这样的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用括号将函数括起来调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, $</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 内部代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><p>更优雅的方式是下面这种，事实上很多其它的算术运算符比如 +, -, *, ~ 等也是可以的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">! <span class="function"><span class="keyword">function</span>(<span class="params">window, $</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 内部代码</span></span><br><span class="line">&#125; (<span class="built_in">window</span>, jQuery)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用 +, -, * 等</span></span><br><span class="line">+ <span class="function"><span class="keyword">function</span>(<span class="params">window, $</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 内部代码</span></span><br><span class="line">&#125; (<span class="built_in">window</span>, jQuery)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更神奇的是还可以用 new, typeof 等操作符</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params">window, $</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 内部代码</span></span><br><span class="line">&#125; (<span class="built_in">window</span>, jQuery)；</span><br></pre></td></tr></table></figure><h3 id="使用-set-来对数组去重复"><a href="#使用-set-来对数组去重复" class="headerlink" title="使用 set 来对数组去重复"></a>使用 set 来对数组去重复</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])]); <span class="comment">// =&gt; [ 1, 3, 2 ]</span></span><br></pre></td></tr></table></figure><h3 id="使用-reduce-连乘或连加"><a href="#使用-reduce-连乘或连加" class="headerlink" title="使用 reduce 连乘或连加"></a>使用 reduce 连乘或连加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 连加</span></span><br><span class="line"><span class="built_in">console</span>.log(array.reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c)); <span class="comment">// =&gt; 10</span></span><br><span class="line"><span class="comment">// 连乘</span></span><br><span class="line"><span class="built_in">console</span>.log(array.reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p * c)); <span class="comment">// =&gt; 24</span></span><br></pre></td></tr></table></figure><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><p>Math 中的一堆取整函数这里就不说了，主要是提一些比较巧妙地取整方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~~<span class="number">3.14</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">-2.5</span>); <span class="comment">// =&gt; -2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6.18</span> | <span class="number">0</span>); <span class="comment">// =&gt; 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-3.6</span> | <span class="number">0</span>); <span class="comment">// =&gt; -3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9.9</span> &gt;&gt; <span class="number">0</span>); <span class="comment">// =&gt; 9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-2.1</span> &gt;&gt; <span class="number">0</span>); <span class="comment">// =&gt; -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// superagent 是一个很实用的发送 http 请求的 node 模块，它对返回码的处理就用到了 |</span></span><br><span class="line"><span class="keyword">var</span> type = (status / <span class="number">100</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// status / class</span></span><br><span class="line">res.status = status;</span><br><span class="line">res.statusType = type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basics</span></span><br><span class="line">res.info = <span class="number">1</span> == type;</span><br><span class="line">res.ok = <span class="number">2</span> == type;</span><br><span class="line">res.clientError = <span class="number">4</span> == type;</span><br><span class="line">res.serverError = <span class="number">5</span> == type;</span><br><span class="line">res.error = <span class="number">4</span> == type || <span class="number">5</span> == type;</span><br></pre></td></tr></table></figure><h3 id="使用-将其它类型转换成-number-类型"><a href="#使用-将其它类型转换成-number-类型" class="headerlink" title="使用 + 将其它类型转换成 number 类型"></a>使用 + 将其它类型转换成 number 类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">'3.14'</span>); <span class="comment">// =&gt; 3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +<span class="string">'3.14'</span>); <span class="comment">// =&gt; number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">milliseconds</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), milliseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然这里可以考虑使用 console.time 来测试</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> end = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`执行了<span class="subst">$&#123;end - start&#125;</span>`</span>); <span class="comment">// 执行了 3002</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="使用科学计数法表示大数字"><a href="#使用科学计数法表示大数字" class="headerlink" title="使用科学计数法表示大数字"></a>使用科学计数法表示大数字</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">' world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'测试 + 拼接字符串'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> joinedStr = str1 + str2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'测试 + 拼接字符串'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'测试模板字符串拼接字符串'</span>);</span><br><span class="line"><span class="comment">// 使用科学计数法比打 8 个 0 方便不少</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2e8</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> joinedStr = <span class="string">`<span class="subst">$&#123;str1&#125;</span><span class="subst">$&#123;str2&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'测试模板字符串拼接字符串'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =&gt;</span></span><br><span class="line"><span class="comment">测试 + 拼接字符串: 3238.037ms</span></span><br><span class="line"><span class="comment">测试模板字符串拼接字符串: 3680.225ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="交换变量值"><a href="#交换变量值" class="headerlink" title="交换变量值"></a>交换变量值</h3><p>直接利用解构赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">999</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(&#123; a, b &#125;); <span class="comment">// =&gt; &#123; a: 999, b: 666 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="获取随机字符串"><a href="#获取随机字符串" class="headerlink" title="获取随机字符串"></a>获取随机字符串</h3><p>截取下标 2 开始后的字符串是因为不需要 Math.random() 返回的小数构成的字符串的 <code>0.</code> 这两个字符。使用 36 进制可以制造字符种类更多些的随机字符串</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Math.random().toString(16).substring(2)); &#x2F;&#x2F; 13位 &#x3D;&gt; 45d9d0bb10b31</span><br><span class="line">console.log(Math.random().toString(36).substring(2)); &#x2F;&#x2F; 11位 &#x3D;&gt; zwcx1yewjvj</span><br></pre></td></tr></table></figure><h3 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h3><p>ES 2019 新增了 Array.prototype.flat，目前 chrome 最新正式版 73.0.3683.103 已经支持了, node 最新的 LTS 10.15.3 还不支持, node 最新开发版 11.13.0 是支持的。这里贴一个在掘金一个兄弟面经里面看到的比较 hack 的方法，这里要注意根据情况做类型转换。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  array</span><br><span class="line">    .toString()</span><br><span class="line">    .split(<span class="string">','</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">ele</span> =&gt;</span> <span class="built_in">Number</span>.parseInt(ele))</span><br><span class="line">); <span class="comment">// =&gt; [ 1, 2, 3, 4, 5, 6, 7 ]</span></span><br></pre></td></tr></table></figure><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>，转载请注明出处。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 nodejs 写爬虫(一): 常用模块和 js 语法</title>
    <url>/%E4%BD%BF%E7%94%A8-nodejs-%E5%86%99%E7%88%AC%E8%99%AB-%E4%B8%80-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%92%8C-js-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>本篇是使用 nodejs 写爬虫系列教程的第一篇, 介绍了使用 nodejs 写爬虫过程中常用的模块和一些必须掌握的 js 语法</p><a id="more"></a><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><p>常用模块有以下几个:</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJh" title="https://github.com/jprichardson/node-fs-extra">fs-extra<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpc2lvbm1lZGlhL3N1cGVyYWdlbnQ=" title="https://github.com/visionmedia/superagent">superagent<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWVyaW9qcy9jaGVlcmlv" title="https://github.com/cheeriojs/cheerio">cheerio<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvZzRqcy1ub2RlL2xvZzRqcy1ub2Rl" title="https://github.com/log4js-node/log4js-node">log4js<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemU=" title="https://github.com/sequelize/sequelize">sequelize<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxr" title="https://github.com/chalk/chalk">chalk<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9wdXBwZXRlZXI=" title="https://github.com/GoogleChrome/puppeteer">puppeteer<i class="fa fa-external-link"></i></span></li></ol><h3 id="fs-extra"><a href="#fs-extra" class="headerlink" title="fs-extra"></a>fs-extra</h3><p>使用 async/await 的前提是必须将接口封装成 promise, 看一个简单的例子:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">milliseconds</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), milliseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5秒后...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>通过在 async 函数中使用 await + promise 的方式来组织异步代码就像是同步代码一般，非常的自然和有助于我们分析代码的执行流程。</p><p>在 node 中， fs 模块是一个很常用的操作文件的 native 模块，fs (file system) 模块提供了和文件系统相关的一些同步和异步的 api, 有时候使用同步 api 非常有必要，比如你要在一个自己写的模块中的在访问文件后导出一些接口时，这个时候用同步的 api 就很实用。看个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; log4js &#125; = <span class="built_in">require</span>(<span class="string">'../../config/log4jsConfig'</span>);</span><br><span class="line"><span class="keyword">const</span> log = log4js.getLogger(<span class="string">'qupingce'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createModels = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> models = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> fileNames = fs.readdirSync(path.resolve(__dirname, <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">  fileNames</span><br><span class="line">    .filter(<span class="function"><span class="params">fileName</span> =&gt;</span> fileName !== <span class="string">'index.js'</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">fileName</span> =&gt;</span> fileName.slice(<span class="number">0</span>, <span class="number">-3</span>))</span><br><span class="line">    .forEach(<span class="function"><span class="params">modelName</span> =&gt;</span> &#123;</span><br><span class="line">      log.info(<span class="string">`Sequelize define model <span class="subst">$&#123;modelName&#125;</span>!`</span>);</span><br><span class="line">      models[modelName] = <span class="built_in">require</span>(path.resolve(__dirname, <span class="string">`./<span class="subst">$&#123;modelName&#125;</span>.js`</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> models;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createModels();</span><br></pre></td></tr></table></figure><p>这个模块访问了当前目录下所有的 model 模块并导出 models, 如果是使用异步接口也就是 fs.readdir, 这样的话你在别的模块导入这个模块是获取不到 models 的， 原因是 require 是同步操作，而接口是异步的，同步代码无法立即获得异步操作的结果。</p><p>为了充分发挥 node 异步的优势，我们还是应该尽量使用异步接口。</p><p>我们完全可以使用 fs-extra 模块来代替 fs 模块, 类似的模块还有 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9teg==" title="https://github.com/normalize/mz">mz<i class="fa fa-external-link"></i></span>。fs-extra 包含了所有的 fs 模块的接口，还对每个异步接口提供了 promise 支持，更棒的是 fs-extra 还提供了一些其它的实用文件操作函数， 比如删除移动文件的操作。更详细的介绍请查看官方仓库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJh" title="https://github.com/jprichardson/node-fs-extra">fs-extra<i class="fa fa-external-link"></i></span>。</p><h3 id="superagent"><a href="#superagent" class="headerlink" title="superagent"></a>superagent</h3><p>superagent 是一个 node 的 http client, 可以类比 java 中的 httpclient 和 okhttp, python 中的 requests。可以让我们模拟 http 请求。superagent 这个库有很多实用的特点。</p><ol><li><p>superagent 会根据 response 的 content-type 自动序列化，通过 response.body 就可以获取到序列化后的返回内容</p></li><li><p>这个库会自动缓存和发送 cookies, 不需要我们手动管理 cookies</p></li><li><p>再来就是它的 api 是链式调用风格的，调用起来很爽，不过使用的时候要注意调用顺序</p></li><li><p>它的异步 api 都是返回 promise 的。</p></li></ol><p>非常方便有木有 😋。官方文档就是很长的一页，目录清晰，很容易就搜索到你需要的内容。最后，superagent 还支持插件集成，比如你需要在超时后自动重发，可以使用 superagent-retry。更多插件可以去 npm 官网上搜索关键字 <code>superagent-</code>。更多详情查看官方文档<span class="exturl" data-url="aHR0cHM6Ly92aXNpb25tZWRpYS5naXRodWIuaW8vc3VwZXJhZ2VudC8=" title="https://visionmedia.github.io/superagent/">superagent<i class="fa fa-external-link"></i></span></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方文档的一个调用示例</span></span><br><span class="line">request</span><br><span class="line">  .post(<span class="string">'/api/pet'</span>)</span><br><span class="line">  .send(&#123; <span class="attr">name</span>: <span class="string">'Manny'</span>, <span class="attr">species</span>: <span class="string">'cat'</span> &#125;)</span><br><span class="line">  .set(<span class="string">'X-API-Key'</span>, <span class="string">'foobar'</span>)</span><br><span class="line">  .set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'yay got '</span> + <span class="built_in">JSON</span>.stringify(res.body));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a>cheerio</h3><p>写过爬虫的人都知道, 我们经常会有解析 html 的需求, 从网页源代码中爬取信息应该是最基础的爬虫手段了。python 中有 beautifulsoup, java 中有 jsoup, node 中有 cheerio。</p><p>cheerio 是为服务器端设计的，给你近乎完整的 jquery 体验。使用 cheerio 来解析 html 获取元素，调用方式和 jquery 操作 dom 元素用法完全一致。而且还提供了一些方便的接口, 比如获取 html, 看一个例子:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> $ = cheerio.load(<span class="string">'&lt;h2 class="title"&gt;Hello world&lt;/h2&gt;'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'h2.title'</span>).text(<span class="string">'Hello there!'</span>);</span><br><span class="line">$(<span class="string">'h2'</span>).addClass(<span class="string">'welcome'</span>);</span><br><span class="line"></span><br><span class="line">$.html();</span><br><span class="line"><span class="comment">//=&gt; &lt;h2 class="title welcome"&gt;Hello there!&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure><p>官方仓库: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWVyaW9qcy9jaGVlcmlv" title="https://github.com/cheeriojs/cheerio">cheerio<i class="fa fa-external-link"></i></span></p><h3 id="log4js"><a href="#log4js" class="headerlink" title="log4js"></a>log4js</h3><p>log4j 是一个为 node 设计的日志模块。 场景简单情况下可以考虑使用 debug 模块。 log4js 比较符合我对日志库的需求，其实他俩定位也不一样，debug 模块是为调试而设计的，log4js 则是一个日志库，肯定得提供文件输出和分级等常规功能。</p><p>log4js 模块看名字有点向 java 中很有名的日志库 log4j 看齐的节奏。log4j 有以下特点:</p><ol><li>可以自定义 appender(输出目标)，lo4js 甚至提供了输出到邮件等目标的 appender</li><li>通过组合不同的 appender, 可以实现不同目的的 logger(日志器)</li><li>提供了日志分级功能，官方的 FAQ 中提到了如果要对 appender 实现级别过滤，可以使用 <strong>logLevelFilter</strong></li><li>提供了滚动日志和自定义输出格式</li></ol><p>下面通过我最近一个爬虫项目的配置文件来感受以下这个库的特点:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> infoFilePath = path.resolve(__dirname, <span class="string">'../out/log/info.log'</span>);</span><br><span class="line"><span class="keyword">const</span> errorFilePath = path.resolve(__dirname, <span class="string">'../out/log/error.log'</span>);</span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    dateFile: &#123;</span><br><span class="line">      type: <span class="string">'dateFile'</span>,</span><br><span class="line">      filename: infoFilePath,</span><br><span class="line">      pattern: <span class="string">'yyyy-MM-dd'</span>,</span><br><span class="line">      compress: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    errorDateFile: &#123;</span><br><span class="line">      type: <span class="string">'dateFile'</span>,</span><br><span class="line">      filename: errorFilePath,</span><br><span class="line">      pattern: <span class="string">'yyyy-MM-dd'</span>,</span><br><span class="line">      compress: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    justErrorsToFile: &#123;</span><br><span class="line">      type: <span class="string">'logLevelFilter'</span>,</span><br><span class="line">      appender: <span class="string">'errorDateFile'</span>,</span><br><span class="line">      level: <span class="string">'error'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    out: &#123;</span><br><span class="line">      type: <span class="string">'console'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      appenders: [<span class="string">'out'</span>],</span><br><span class="line">      level: <span class="string">'trace'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    qupingce: &#123;</span><br><span class="line">      appenders: [<span class="string">'out'</span>, <span class="string">'dateFile'</span>, <span class="string">'justErrorsToFile'</span>],</span><br><span class="line">      level: <span class="string">'trace'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clear = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> files = <span class="keyword">await</span> fs.readdir(path.resolve(__dirname, <span class="string">'../out/log'</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fileName <span class="keyword">of</span> files) &#123;</span><br><span class="line">    fs.remove(path.resolve(__dirname, <span class="string">`../out/log/<span class="subst">$&#123;fileName&#125;</span>`</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  log4js,</span><br><span class="line">  clear,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a>sequelize</h3><p>写项目我们往往会有持久化的需求，简单的场景可以使用 JSON 保存数据，如果数据量比较大还要便于管理，那么我们就要考虑用数据库了。如果是操作 mysql 和 sqllite 建议使用 sequelize, 如果是 mongodb, 我更推荐用专门为 mongodb 设计的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2U=" title="https://github.com/Automattic/mongoose">mongoose<i class="fa fa-external-link"></i></span></p><p>sequelize 有几点我觉得还是有点不太好，比如默认生成 <code>id</code> (primary key), <code>createdAt</code> 和 <code>updatedAt</code>。</p><p>抛开一些自作主张的小毛病，sequelize 设计的还是很好的。内置的操作符，hooks, 还有 validators 很有意思。sequelize 还提供了 promise 和 typescript 支持。如果是使用 typescript 开发项目，还有另外一个很好的 orm 选择 : <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGVvcm0vdHlwZW9ybQ==" title="https://github.com/typeorm/typeorm">typeorm<i class="fa fa-external-link"></i></span>。更多内容可以查看官方文档: <span class="exturl" data-url="aHR0cDovL2RvY3Muc2VxdWVsaXplanMuY29tLw==" title="http://docs.sequelizejs.com/">sequelize<i class="fa fa-external-link"></i></span></p><h3 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a>chalk</h3><p>chalk 中文意思是粉笔的意思，这个模块是 node 很有特色和实用的一个模块，它可以为你输出的内容添加颜色， 下划线， 背景色等装饰。当我们写项目的时候往往需要记录一些步骤和事件，比如打开数据库链接，发出 http 请求等。我们可以适当使用 chalk 来突出某些内容，例如请求的 url 加上下划线。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logRequest = <span class="function">(<span class="params">response, isDetailed = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> URL = chalk.underline.yellow(response.request.url);</span><br><span class="line">  <span class="keyword">const</span> basicInfo = <span class="string">`<span class="subst">$&#123;response.request.method&#125;</span> Status: <span class="subst">$&#123;response.status&#125;</span> Content-Type: <span class="subst">$&#123;response.type&#125;</span> URL=<span class="subst">$&#123;URL&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (!isDetailed) &#123;</span><br><span class="line">    logger.info(basicInfo);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> detailInfo = <span class="string">`<span class="subst">$&#123;basicInfo&#125;</span>\ntext: <span class="subst">$&#123;response.text&#125;</span>`</span>;</span><br><span class="line">    logger.info(detailInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用上面的 logRequest 效果:</p><p><img data-src="https://i.loli.net/2019/04/02/5ca3724e74da1.png" alt="chalk"></p><p>更多内容查看官方仓库<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxr" title="https://github.com/chalk/chalk">chalk<i class="fa fa-external-link"></i></span></p><h3 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h3><p>如果这个库没听说过，你可能听说过 selenium。puppeteer 是 Google Chrome 团队开源的一个通过 devtools 协议操纵 chrome 或者 Chromium 的 node 模块。Google 出品，质量有所保证。这个模块提供了一些高级的 api, 默认情况下，这个库操纵的浏览器用户是看不到界面的，也就是所谓的无头(headless)浏览器。当然可以通过配置一些参数来启动有界面的模式。在 chrome 中还有一些专门录制 puppeteer 操作的扩展, 比如<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcHVwcGV0ZWVyLXJlY29yZGVyL2RqZWVnaWdnZWdsZWFka2tiZ29wb29uaGppbWdlaGRh" title="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjimgehda">Puppeteer Recorder<i class="fa fa-external-link"></i></span>。使用这个库我们可以用来抓取一些通过 js 渲染而不是直接存在于页面源代码中的信息。比如 spa 页面，页面内容都是 js 渲染出来的。这个时候 puppeteer 就为我们解决了这个问题，我们可以调用 puppeteer 在页面某个标签出现时获取到页面当时的渲染出来的 html。事实上，往往很多比较困难的爬虫解决的最终法宝就是操纵浏览器。</p><h2 id="前置的-js-语法"><a href="#前置的-js-语法" class="headerlink" title="前置的 js 语法"></a>前置的 js 语法</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>首先要提的就是 async/await, 因为 node 在很早的时候(node 8 LTS)就已经支持 async/await, 现在写后端项目没理由不用 async/await 了。使用 async/await 可以让我们从回调炼狱的困境中解脱出来。这里主要提一下关于使用 async/await 时可能会碰到的问题</p><h4 id="使用-async-await-怎样并发？"><a href="#使用-async-await-怎样并发？" class="headerlink" title="使用 async/await 怎样并发？"></a>使用 async/await 怎样并发？</h4><p>来看一段测试代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">milliseconds</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), milliseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, max = <span class="number">3</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;).forEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'测试 for 循环使用 await'</span>);</span><br><span class="line">  <span class="keyword">await</span> test1();</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'测试 for 循环使用 await'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'测试 forEach 调用 async 函数'</span>);</span><br><span class="line">  <span class="keyword">await</span> test2();</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'测试 forEach 调用 async 函数'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>运行结果是:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试 for 循环使用 await: 3003.905ms</span><br><span class="line">测试 forEach 调用 async 函数: 0.372ms</span><br></pre></td></tr></table></figure><p>我想可能会有些人会认为测试 forEach 的结果会是 1 秒左右，事实上测试 2 等同于以下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test2 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Array.from(&#123;length: 3&#125;).forEach(async () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     await sleep(1000);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;).forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的运行结果也可以看出直接在 for 循环中使用 await + promise, 这样等同于<strong>同步</strong>调用, 所以耗时是 3 秒左右。如果要并发则应该直接调用 promise, 因为 forEach 是不会帮你 await 的，所以等价于上面的代码，三个任务直接异步并发了。</p><h4 id="处理多个异步任务"><a href="#处理多个异步任务" class="headerlink" title="处理多个异步任务"></a>处理多个异步任务</h4><p>上面的代码还有一个问题，那就是测试 2 中并没有等待三个任务都执行完就直接结束了，有时候我们需要等待多个并发任务结束之后再执行后续任务。其实很简单，利用下 Promise 提供的几个工具函数就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">milliseconds, id = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`任务<span class="subst">$&#123;id&#125;</span>执行结束`</span>);</span><br><span class="line">      resolve(id);</span><br><span class="line">    &#125;, milliseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tasks = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;).map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> sleep(<span class="number">1000</span>, index));</span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">  <span class="built_in">console</span>.log(&#123; resultArray &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有任务执行结束'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'使用 Promise.all 处理多个并发任务'</span>);</span><br><span class="line">  <span class="keyword">await</span> test2();</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'使用 Promise.all 处理多个并发任务'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务0执行结束</span><br><span class="line">任务1执行结束</span><br><span class="line">任务2执行结束</span><br><span class="line">&#123; resultArray: [ 0, 1, 2 ] &#125;</span><br><span class="line">所有任务执行结束</span><br><span class="line">使用 Promise.all 处理多个并发任务: 1018.628ms</span><br></pre></td></tr></table></figure><p>除了 Promise.all, Promise 还有 race 等接口，不过最常用应该就是 all 和 race 了。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式是处理字符串强有力的工具。核心是匹配，由此衍生出提取，查找， 替换的等操作。</p><p>有时候我们通过 cheerio 中获取到某个标签内的文本时，我们需要提取其中的部分信息，这个时候正则表达式就该上场了。正则表达式的相关语法这里就不详细说明了， 入门推荐看<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5NTAzOTIwYmI3YjQyZmY2NjI3NDIwZGEyY2VhZTRiYWJmNmM0ZjIwMDA=" title="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499503920bb7b42ff6627420da2ceae4babf6c4f2000">廖雪峰的正则表达式教程<i class="fa fa-external-link"></i></span>。来看个实例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器返回的 img url 是: /GetFile/getUploadImg?fileName=9b1cc22c74bc44c8af78b46e0ca4c352.png</span></span><br><span class="line"><span class="comment">// 现在我只想提取文件名，后缀名也不要</span></span><br><span class="line"><span class="keyword">const</span> imgUrl = <span class="string">'/GetFile/getUploadImg?fileName=9b1cc22c74bc44c8af78b46e0ca4c352.png'</span>;</span><br><span class="line"><span class="keyword">const</span> imgReg = <span class="regexp">/\/GetFile\/getUploadImg\?fileName=(.+)\..+/</span>;</span><br><span class="line"><span class="keyword">const</span> imgName = imgUrl.match(imgReg)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(imgName); <span class="comment">// =&gt; 9b1cc22c74bc44c8af78b46e0ca4c352</span></span><br></pre></td></tr></table></figure><p>暂时先介绍到这里了，后续有更多内容会继续补充。</p><p>本文为原创内容，首发于<span class="exturl" data-url="aHR0cDovL3d3dy5seXJlYWw2NjYuY29t" title="http://www.lyreal666.com">个人博客<i class="fa fa-external-link"></i></span>, 转载请注明出处。如果有问题欢迎邮件骚扰 <span class="exturl" data-url="bWFpbHRvOnl0ajI3MTMxNTE3MTNAZ21haWwuY29t" title="mailto:ytj2713151713@gmail.com">ytj2713151713@gmail.com<i class="fa fa-external-link"></i></span>。</p>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node</tag>
        <tag>spider</tag>
        <tag>package</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>react native 总结</title>
    <url>/react-native-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近用 react native 做了一个移动端跨平台 App。<strong>Learn once, write everywhere</strong> 确实不是吹的。</p><p>本文主要由以下几部分构成:</p><ol><li>为什么我选择了 react native</li><li>react natve 开发 App 体验</li><li>react native 的有哪些坑</li><li>对未来移动跨平台开发的展望</li></ol><a id="more"></a><h2 id="为什么我选择了-react-native"><a href="#为什么我选择了-react-native" class="headerlink" title="为什么我选择了 react native"></a>为什么我选择了 react native</h2><p>当前比较火的开发原生 APP 的跨平台技术其实挺多的，h5+, mui, uniAPP, hybird, react native, weex, flutter。最具竞争力当属 react native, weex, lutter 了。</p><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><p>对于 weex 我一开始是很看好的，又是基于 vue, 又比 react native 开源的晚，然后又是阿里开源的, 觉得应该在设计上不会差于 react native。之所以不用 weex, 有几个原因。首先是我对 vue 的熟练度是不及 react 的，我之前用 react 独立开发过比较大的网站以及小程序，小程序的风格和 react 的风格还是很像的， 但是 vue 我只是看过两遍文档，做过一些小 demo。然后就是我在一些技术论坛比如: 知乎, v2ex，搜索了一些关于 weex 的评价，普遍都认为 weex 坑多，当然是相对与 react native 来说， 其实我开发过 react native 之后就发现 react native 也有很多坑。最后就是当时闲鱼官方宣布使用 flutter 的消息，让我彻底的否决了选择 weex。现在打开 github 上 weex 官方仓库，发现 weex 已经托管给 apache 了…</p><h3 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h3><p>flutter 应该是这三个里面最晚开源的了，由 Google 开源的一个跨平台 UI 框架。flutter 使用 Google 公司开发的 dart 语言开发，而另外两个都是使用 javascript。看了一些关于 flutter 的评测文章，普遍都是 flutter 的性能要好于 react native。国内第一家公开使用 flutter 的大厂应该就是阿里闲鱼了，好像还和 flutter 官方有深度合作。对于 flutter 我是很看好的，因为 flutter 背靠 Google, Google 正在开发的 Fusion 操作系统的官方语言就是 dart, 甚至有可能以后 android 系统就会将底层的 linux 系统换成了 fusion 系统。学习 flutter 一举多得啊。如果时间允许的话我可能会选择 fluter 来开发我那个项目了。但是我没时间啊，大概两三个星期就要交产品，我对 dart 不熟，对 flutter 开发流程更是一点都不了解。</p><h3 id="react-native"><a href="#react-native" class="headerlink" title="react native"></a>react native</h3><p>看看 github 上 react native 的 star <strong>74.3k</strong>，其受欢迎程度可想而知。时至今日，我仍然认为开发一些小型的 App 使用 react native 是个很好的选择，react native 相对与另外两者最大的优势就是生态。</p><blockquote><p>所以我最后选择了 react native。</p></blockquote><h2 id="react-native-的开发体验"><a href="#react-native-的开发体验" class="headerlink" title="react native 的开发体验"></a>react native 的开发体验</h2><h3 id="和-react-开发区别并不大"><a href="#和-react-开发区别并不大" class="headerlink" title="和 react 开发区别并不大"></a>和 react 开发区别并不大</h3><p>在学习 react native 之前我还担心会不会和 react 的区别挺大的，看完了官方文档前几节后，我完全打消了这个顾虑。使用 react native 开发 APP 和使用 react 开发网页并没有什么大区别，react 全家桶完全可用。由于 react native 开发的 APP 最后是使用原生控件渲染的，所以肯定是不能是 html 那一套标签了，不然要做的适配工作太大太复杂了。使用 react native 开发必须用 react native 设计的一套组件库。react native 官方的组件库其实相对与 html 来说还是少很多的， 比如没有标题组件等。但是也够用了，不够用自己造，也有很多优秀的第三方组件库或者组件。github 上 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvbmRvdC9hd2Vzb21lLXJlYWN0LW5hdGl2ZQ==" title="https://github.com/jondot/awesome-react-native">awesome-react-native<i class="fa fa-external-link"></i></span> 上列出了很多优秀的 rn 资源，我在开发 APP 的时候经常去这个仓库看是否有合适的可以拿来用。html 中的 div 对应与 rn 中 View, span 对应 Text。在 react native 中我们仍然可以获取到组件对象，并调用组件对象的一些函数。</p><h3 id="开发效率比原生开发高很多"><a href="#开发效率比原生开发高很多" class="headerlink" title="开发效率比原生开发高很多"></a>开发效率比原生开发高很多</h3><p>我以前也开发过简单的原生 APP， 使用 xml 那非人类标记语言，java 代码的啰嗦， 记忆犹新。使用 react native 开发 App, 其实只要你懂 js 和组件化技术就可以上手了，并且 react native 还有跨平台和热更新两大杀手级特性，如果团队中有会 rn 开发的，使用 rn 来代替 h5 是个很好的选择。跨平台对于小公司来说可以减少招人成本，诱惑力不小，热更新可以让 APP 在不升级版本的情况下升级 APP 页面，由于是渲染为原生控件，还有各种方便的和系统交互的 API，肯定比 h5 技术要好。使用 rn 开发，还可以避开 Apple store 的审核，快速升级应用。</p><h2 id="react-native-中的那些坑"><a href="#react-native-中的那些坑" class="headerlink" title="react native 中的那些坑"></a>react native 中的那些坑</h2><p>react native 中有很多坑，而且有些坑还是注定无法解决的，因为这是 react native 本身的技术架构决定的，尽管有很多坑，但是一般都有解决办法，但是这些坑确实是 react native 这个框架本身的 bug, 不应该由开发者来解决。而且有些解决办法很 hack, 不一定适用你的使用场景。下面列举一些 react native 中的坑。</p><h3 id="跨平台不彻底"><a href="#跨平台不彻底" class="headerlink" title="跨平台不彻底"></a>跨平台不彻底</h3><p>众所周知，选择 rn 这类跨平台框架，很大一部分原因就是看重了其跨平台能力，但是当我使用 rn 时，打开官方文档查看基础组件 <code>Text</code> 的属性看到的是这样的</p><img data-src="/react-native-%E6%80%BB%E7%BB%93/android-ios-difference.png" title="平台差异"><p>在不久前 Airbnb 公司宣布放弃 react native 的文章中就说到了这一点，说是因为跨平台的不彻底，需要对维持 android 和 ios 的一致性要投入很大的精力。其实作为前端工程建设极为优秀的 facebook 公司，讲道理开源出来的框架不应该做不好平台一致性啊。其实原因还是 rn 本身的技术架构的局限性导致的。由于 rn 最终渲染控件时是调用原生的控件，比如在安卓平台 rn 的 Text 组件调用的可能就是原生的 TextView。那 android 和 ios 两个移动操作系统本身原生组件就是有不同的，有些特性可能 ios 有，android 并没有， 所以这一类属性在 rn 中就只好做平台区分了。flutter 是没问题的，因为 flutter 的视图是自绘的，并不依赖原生控件。</p><h3 id="导航-路由-很混乱"><a href="#导航-路由-很混乱" class="headerlink" title="导航(路由)很混乱"></a>导航(路由)很混乱</h3><p>时至今日，官方推荐使用<span class="exturl" data-url="aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QtbmF0aXZlL2RvY3MvbmF2aWdhdGlvbiNyZWFjdC1uYXZpZ2F0aW9u" title="https://facebook.github.io/react-native/docs/navigation#react-navigation">React Navigation<i class="fa fa-external-link"></i></span>来处理页面之间的跳转。但是呢，当我在 windows 系统使用开发的时候，发现这个库 link 后生产的构建脚本中的路径都是错误的，需要我手动转义，这开发态度也太差劲了吧？并且 react native 的路由历史上发生过好几次大改，只学最新版的 react navigation 的我看到 github 上的 rn 开源项目的时候，别人用的路由看的我很懵逼，虽然不至于看不懂，但是写法完全不一样。</p><h3 id="开发工具有待完善"><a href="#开发工具有待完善" class="headerlink" title="开发工具有待完善"></a>开发工具有待完善</h3><p>使用官方脚手架 react-native-cli 开发时，热重载基本上是废的，大概率热重载会有问题，我一般都是只用自动重载。有时候还会出现一个很恶心的情况，就是当出现语法错误时，你即便是修复错误了， reload 后还是报同一个语法错误，只有退出 cli, 重新 <strong>react-native run-android</strong> 才行。</p><h3 id="调式体验极差"><a href="#调式体验极差" class="headerlink" title="调式体验极差"></a>调式体验极差</h3><p>使用<code>react-native-debugger</code> 来 debug rn app，打开 dom 视图，估计你要打开 二，三十层嵌套才能看到你想看到的部分。不解决嵌套层次过多的问题，这调试器体验也太差了。</p><img data-src="/react-native-%E6%80%BB%E7%BB%93/react-native-debugger.png" title="调式体验极差"><h3 id="ScrollView-中的-TextInput"><a href="#ScrollView-中的-TextInput" class="headerlink" title="ScrollView 中的 TextInput"></a>ScrollView 中的 TextInput</h3><p>当 ScrollView 中有 TextInput 时, 如果滑在 TextInput 上面屏幕不会滚动。这么基础的体验不应该有开发者来解决吧，github 上面针对这个 issue 有人提出了解决办法， 但是并不适合我的使用场景。</p><img data-src="/react-native-%E6%80%BB%E7%BB%93/TextInputInScrollView.png" title="TextInput 在 ScrollView 中的 bug"><h2 id="对未来移动跨平台开发的展望"><a href="#对未来移动跨平台开发的展望" class="headerlink" title="对未来移动跨平台开发的展望"></a>对未来移动跨平台开发的展望</h2><p>看好 flutter，我最近在学习 dart 语法，感觉 dart 非常不错，感觉糅合了 js 和 java 的很多特点。不过我还要时间去深入学习，强类型 + 组件化开发，开发体验很好。flutter 在架构风格上和 react 很像，react 没白学啊。现在 flutter 差的就是时间，等生态建立好了，各方面插件都有了以后，估计有一批原生开发要失业喽。最近看到 React Native 官方 twitter 说 react native 正在由内到外大重构，不知道重构完会不会有惊喜，facebook 说不定能大力出奇迹 😍。有可能等重构完就出 1.0 稳定版了，现在 react native 还停留在 0.58 …</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react native</tag>
      </tags>
  </entry>
</search>
